F00:0001       .include "Routines.inc"
F01:0001       
F01:0002       # address where user programs load
F01:0003       .include "SERIAL.inc"
F02:0001       .equ SERIALPORT , 0x01
F02:0002       
F01:0004       .include "SDCARD.inc"
F03:0001       .equ SDCARD,0x05
F03:0002       ; ******* SDCARD *********
F03:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F03:0004       .equ FILENAMECLEAR ,1
F03:0005       
F03:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F03:0007       .equ OPEN ,2
F03:0008       
F03:0009       ; z80 out - close: no return value
F03:0010       .equ CLOSE ,3
F03:0011       
F03:0012       ; z80 out + out - filenameappend: no return value
F03:0013       .equ FILENAMEAPPEND ,4
F03:0014       
F03:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F03:0016       .equ READNEXTBYTE ,5
F03:0017       
F03:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F03:0019       .equ AVAILABLE ,6
F03:0020       
F03:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F03:0022       .equ OPENWRITE,7
F03:0023       
F03:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F03:0025       .equ WRITEBYTE,8
F03:0026       
F03:0027       ;#===============================
F03:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F03:0029       .equ GETNAME,0x20
F03:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F03:0031       .equ NAMEAVAILABLE,0x21
F03:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F03:0033       .equ OPENDIRECTORY,0x31
F03:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F03:0035       .equ NEXTFILE,0x32
F01:0005       .equ commandMemory, 0x1000
F01:0006       .equ userMemory,0x2000
F01:0007       
F01:0008       .equ TRUE, 1
F01:0009       .equ FALSE, 0
F01:0010       
F01:0011       # the only fixed address (i hope), use it to get the address of utilities methods
F01:0012       # ld a, PRINT
F01:0013       # call GetAddress
F01:0014       # address for print loaded into hl
F01:0015       # the value in hl can change between os versions so do not hard code the values
F01:0016       
F01:0017       .equ GetAddress, 0x0804
F01:0018       .equ PRINT,		1
F01:0019       .equ PRINTLN,	9
F01:0020       .equ PRINTHEX,	2
F01:0021       .equ LOADFILE,	3
F01:0022       .equ MEMSET,	4
F01:0023       .equ STRLEN,	5
F01:0024       .equ PUTC,		6
F01:0025       .equ TOUPPERCASE,7
F01:0026       .equ HEXTOBYTE,	8
F01:0027       .equ STRNCPY,10
F01:0028       # filesystem - primitive functions, probably going to change 
F01:0029       .equ DIRECTORYOPEN,13
F01:0030       .equ DIRECTORYNEXTFILE,14
F01:0031       .equ GETFILENAME,15
F01:0032       
F01:0033       
F01:0034       
F01:0035       .equ NEXTNUMBER,16
F01:0036       
F01:0037       
F00:0002       .include "libs.inc"
F04:0001       
F04:0002       .ifndef __CMD__
F04:0003       	.org userMemory
F04:0004       .endif
F04:0005       	ld a,PRINT
               S01:00002000:  3E 01
F04:0006       	call GetAddress
               S01:00002002:  CD 04 08
F04:0007       	ld (printadr),hl
               S01:00002005:  22 65 20
F04:0008       	ld a,PRINTHEX
               S01:00002008:  3E 02
F04:0009       	call GetAddress
               S01:0000200A:  CD 04 08
F04:0010       	ld (printhexadr),hl
               S01:0000200D:  22 6B 20
F04:0011       	ld a,LOADFILE
               S01:00002010:  3E 03
F04:0012       	call GetAddress
               S01:00002012:  CD 04 08
F04:0013       	ld (loadfileadr),hl
               S01:00002015:  22 6E 20
F04:0014       	ld a,MEMSET
               S01:00002018:  3E 04
F04:0015       	call GetAddress
               S01:0000201A:  CD 04 08
F04:0016       	ld (memsetadr),hl
               S01:0000201D:  22 71 20
F04:0017       	ld a,STRLEN
               S01:00002020:  3E 05
F04:0018       	call GetAddress
               S01:00002022:  CD 04 08
F04:0019       	ld (strlenadr),hl
               S01:00002025:  22 74 20
F04:0020       	ld a,PUTC
               S01:00002028:  3E 06
F04:0021       	call GetAddress
               S01:0000202A:  CD 04 08
F04:0022       	ld (putcadr),hl
               S01:0000202D:  22 77 20
F04:0023       	ld a,TOUPPERCASE
               S01:00002030:  3E 07
F04:0024       	call GetAddress
               S01:00002032:  CD 04 08
F04:0025       	ld (touppercaseadr),hl
               S01:00002035:  22 7A 20
F04:0026       	ld a,HEXTOBYTE
               S01:00002038:  3E 08
F04:0027       	call GetAddress
               S01:0000203A:  CD 04 08
F04:0028       	ld (hextobyteadr),hl
               S01:0000203D:  22 7D 20
F04:0029       	ld a,PRINTLN
               S01:00002040:  3E 09
F04:0030       	call GetAddress
               S01:00002042:  CD 04 08
F04:0031       	ld (printlnadr),hl
               S01:00002045:  22 68 20
F04:0032       	ld a,DIRECTORYOPEN
               S01:00002048:  3E 0D
F04:0033       	call GetAddress
               S01:0000204A:  CD 04 08
F04:0034       	ld (directoryopenadr),hl
               S01:0000204D:  22 80 20
F04:0035       	ld a,NEXTFILE
               S01:00002050:  3E 32
F04:0036       	call GetAddress
               S01:00002052:  CD 04 08
F04:0037       	ld (directorynextfileadr),hl
               S01:00002055:  22 83 20
F04:0038       	ld a,GETFILENAME
               S01:00002058:  3E 0F
F04:0039       	call GetAddress
               S01:0000205A:  CD 04 08
F04:0040       	ld (getfilenameadr),hl
               S01:0000205D:  22 86 20
F04:0041       
F04:0042       	jp _main
               S01:00002060:  C3 88 20
F04:0043       
F04:0044       	functionlookups:
F04:0045       	.align 2
F04:0046       	print: .byte 0xc3
               S01:00002064:  C3
F04:0047       	printadr: .2byte 0
               S01:00002065:  00 00
F04:0048       	println: .byte 0xc3
               S01:00002067:  C3
F04:0049       	printlnadr: .2byte 0
               S01:00002068:  00 00
F04:0050       	printhex: .byte 0xc3
               S01:0000206A:  C3
F04:0051       	printhexadr: .2byte 0
               S01:0000206B:  00 00
F04:0052       	loadfile: .byte 0xc3
               S01:0000206D:  C3
F04:0053       	loadfileadr: .2byte 0
               S01:0000206E:  00 00
F04:0054       	memset: .byte 0xc3
               S01:00002070:  C3
F04:0055       	memsetadr: .2byte 0
               S01:00002071:  00 00
F04:0056       	strlen: .byte 0xc3
               S01:00002073:  C3
F04:0057       	strlenadr: .2byte 0
               S01:00002074:  00 00
F04:0058       	putc: .byte 0xc3
               S01:00002076:  C3
F04:0059       	putcadr: .2byte 0
               S01:00002077:  00 00
F04:0060       	touppercase: .byte 0xc3
               S01:00002079:  C3
F04:0061       	touppercaseadr: .2byte 0
               S01:0000207A:  00 00
F04:0062       	hextobyte: .byte 0xc3
               S01:0000207C:  C3
F04:0063       	hextobyteadr: .2byte 0
               S01:0000207D:  00 00
F04:0064       	directoryopen: .byte 0xc3
               S01:0000207F:  C3
F04:0065       	directoryopenadr: .2byte 0
               S01:00002080:  00 00
F04:0066       	directorynextfile: .byte 0xc3
               S01:00002082:  C3
F04:0067       	directorynextfileadr: .2byte 0
               S01:00002083:  00 00
F04:0068       	getfilename: .byte 0xc3
               S01:00002085:  C3
F04:0069       	getfilenameadr: .2byte 0
               S01:00002086:  00 00
F04:0070       
F04:0071       _main:
F00:0003       
F00:0004       
F00:0005       
F00:0006       	di
               S01:00002088:  F3
F00:0007       	im 2
               S01:00002089:  ED 5E
F00:0008       	ld a, interruptvectors/256
               S01:0000208B:  3E 20
F00:0009       	ld i,a
               S01:0000208D:  ED 47
F00:0010       	ei
               S01:0000208F:  FB
F00:0011       
F00:0012       loop:
F00:0013       	call available
               S01:00002090:  CD 9A 20
F00:0014       	jp z,loop
               S01:00002093:  CA 90 20
F00:0015       
F00:0016       	jp loop
               S01:00002096:  C3 90 20
F00:0017       
F00:0018       
F00:0019       exit:
F00:0020       	ret
               S01:00002099:  C9
F00:0021       
F00:0022       	;# check if a key is available in the buffer
F00:0023       	;# if bufferwrite is # bufferread then there's a byte available
F00:0024       	;# check Z flag on return
F00:0025       	;# call available
F00:0026       	;# jp z, no data
F00:0027       	;# jp nz, has data
F00:0028       available:
F00:0029       	push bc
               S01:0000209A:  C5
F00:0030       	ld a,(bufferread)
               S01:0000209B:  3A D4 20
F00:0031       	ld b,a
               S01:0000209E:  47
F00:0032       	ld a,(bufferwrite)
               S01:0000209F:  3A D3 20
F00:0033       	cp b
               S01:000020A2:  B8
F00:0034       	pop bc
               S01:000020A3:  C1
F00:0035       	ret
               S01:000020A4:  C9
F00:0036       
F00:0037       	#return next character from keybuffer
F00:0038       	#tryagain:
F00:0039       	#call available
F00:0040       	#jp nz, tryagain
F00:0041       	#call getc
F00:0042       	# register A has the byte
F00:0043       getc:
F00:0044       	ld ix,keybuffer
               S01:000020A5:  DD 21 C9 20
F00:0045       	ld bc,(bufferread)
               S01:000020A9:  ED 4B D4 20
F00:0046       	add ix,bc
               S01:000020AD:  DD 09
F00:0047       	ld a,(ix) ;# contains byte from keybuffer
               S01:000020AF:  DD 7E 00
F00:0048       	ld a,(bufferread)
               S01:000020B2:  3A D4 20
F00:0049       	push af
               S01:000020B5:  F5
F00:0050       	inc a
               S01:000020B6:  3C
F00:0051       	cp 10
               S01:000020B7:  FE 0A
F00:0052       	jp m,_$ ;#  if A < 10 continue
               S01:000020B9:  FA BE 20
F00:0053       	ld a,0 ;# reset to 0
               S01:000020BC:  3E 00
F00:0054       _$:
F00:0055       	ld (bufferread),a ;# save readbuffer
               S01:000020BE:  32 D4 20
F00:0056       	pop af
               S01:000020C1:  F1
F00:0057       	ret
               S01:000020C2:  C9
F00:0058       
F00:0059       
F00:0060       interrupthandler:
F00:0061       	push af
               S01:000020C3:  F5
F00:0062       	in a,(SERIALPORT)
               S01:000020C4:  DB 01
F00:0063       	
F00:0064       	pop af
               S01:000020C6:  F1
F00:0065       	reti
               S01:000020C7:  ED 4D
F00:0066       
F00:0067       
F00:0068       keybuffer: .space 10
F00:0069       bufferwrite: .byte 0
               S01:000020D3:  00
F00:0070       bufferread: .byte 0
               S01:000020D4:  00
F00:0071       
F00:0072       interruptvectors:
F00:0073       .org 0x100
F00:0074       	jumptable: ;# for keyboard interrupts
F00:0075       	.2byte interrupthandler ;0
               S01:00002100:  C3 20
F00:0076       	.2byte interrupthandler ;0
               S01:00002102:  C3 20


Sections:
S01  seg2000


Sources:
F00  edit.s
F01  Routines.inc
F02  SERIAL.inc
F03  SDCARD.inc
F04  libs.inc


Symbols:
jumptable EXPR(8448=0x2100) UNUSED ABS 
interrupthandler EXPR(8387=0x20c3) ABS 
_$ EXPR(8382=0x20be) ABS 
keybuffer EXPR(8393=0x20c9) ABS 
getc EXPR(8357=0x20a5) UNUSED ABS 
bufferwrite EXPR(8403=0x20d3) ABS 
bufferread EXPR(8404=0x20d4) ABS 
exit EXPR(8345=0x2099) UNUSED ABS 
available EXPR(8346=0x209a) ABS 
loop EXPR(8336=0x2090) ABS 
interruptvectors EXPR(8405=0x20d5) ABS 
getfilename EXPR(8325=0x2085) UNUSED ABS 
directorynextfile EXPR(8322=0x2082) UNUSED ABS 
directoryopen EXPR(8319=0x207f) UNUSED ABS 
hextobyte EXPR(8316=0x207c) UNUSED ABS 
touppercase EXPR(8313=0x2079) UNUSED ABS 
putc EXPR(8310=0x2076) UNUSED ABS 
strlen EXPR(8307=0x2073) UNUSED ABS 
memset EXPR(8304=0x2070) UNUSED ABS 
loadfile EXPR(8301=0x206d) UNUSED ABS 
printhex EXPR(8298=0x206a) UNUSED ABS 
println EXPR(8295=0x2067) UNUSED ABS 
print EXPR(8292=0x2064) UNUSED ABS 
functionlookups EXPR(8291=0x2063) UNUSED ABS 
_main EXPR(8328=0x2088) ABS 
getfilenameadr EXPR(8326=0x2086) ABS 
directorynextfileadr EXPR(8323=0x2083) ABS 
directoryopenadr EXPR(8320=0x2080) ABS 
printlnadr EXPR(8296=0x2068) ABS 
hextobyteadr EXPR(8317=0x207d) ABS 
touppercaseadr EXPR(8314=0x207a) ABS 
putcadr EXPR(8311=0x2077) ABS 
strlenadr EXPR(8308=0x2074) ABS 
memsetadr EXPR(8305=0x2071) ABS 
loadfileadr EXPR(8302=0x206e) ABS 
printhexadr EXPR(8299=0x206b) ABS 
printadr EXPR(8293=0x2065) ABS 
NEXTNUMBER EXPR(16=0x10) UNUSED 
GETFILENAME EXPR(15=0xf) 
DIRECTORYNEXTFILE EXPR(14=0xe) UNUSED 
DIRECTORYOPEN EXPR(13=0xd) 
STRNCPY EXPR(10=0xa) UNUSED 
HEXTOBYTE EXPR(8=0x8) 
TOUPPERCASE EXPR(7=0x7) 
PUTC EXPR(6=0x6) 
STRLEN EXPR(5=0x5) 
MEMSET EXPR(4=0x4) 
LOADFILE EXPR(3=0x3) 
PRINTHEX EXPR(2=0x2) 
PRINTLN EXPR(9=0x9) 
PRINT EXPR(1=0x1) 
GetAddress EXPR(2052=0x804) 
FALSE EXPR(0=0x0) UNUSED 
TRUE EXPR(1=0x1) UNUSED 
userMemory EXPR(8192=0x2000) 
commandMemory EXPR(4096=0x1000) UNUSED 
NEXTFILE EXPR(50=0x32) 
OPENDIRECTORY EXPR(49=0x31) UNUSED 
NAMEAVAILABLE EXPR(33=0x21) UNUSED 
GETNAME EXPR(32=0x20) UNUSED 
WRITEBYTE EXPR(8=0x8) UNUSED 
OPENWRITE EXPR(7=0x7) UNUSED 
AVAILABLE EXPR(6=0x6) UNUSED 
READNEXTBYTE EXPR(5=0x5) UNUSED 
FILENAMEAPPEND EXPR(4=0x4) UNUSED 
CLOSE EXPR(3=0x3) UNUSED 
OPEN EXPR(2=0x2) UNUSED 
FILENAMECLEAR EXPR(1=0x1) UNUSED 
SDCARD EXPR(5=0x5) UNUSED 
SERIALPORT EXPR(1=0x1) 
__VASM EXPR(0=0x0) INTERNAL 
__MSDOSFS EXPR(0=0x0) INTERNAL 

There have been no errors.

F00:0001       
F00:0002       .include "Routines.inc"
F01:0001       
F01:0002       # address where user programs load
F01:0003       .include "SERIAL.inc"
F02:0001       .equ SERIALPORT , 0x01
F02:0002       
F01:0004       .include "SDCARD.inc"
F03:0001       .equ SDCARD,0x05
F03:0002       ; ******* SDCARD *********
F03:0003       ; z80 out only
F03:0004       .equ FILENAMECLEAR ,1
F03:0005       .equ OPEN ,2
F03:0006       .equ CLOSE ,3
F03:0007       .equ FILENAMEAPPEND ,4
F03:0008       ; z80 out + in
F03:0009       .equ READNEXTBYTE ,5
F03:0010       .equ AVAILABLE ,6
F01:0005       .equ commandMemory, 0x1000
F01:0006       .equ userMemory,0x2000
F01:0007       
F01:0008       .equ TRUE, 1
F01:0009       .equ FALSE, 0
F01:0010       
F01:0011       # the only fixed address (i hope), use it to get the address of utilities methods
F01:0012       # ld a, PRINT
F01:0013       # call GetAddress
F01:0014       # address for print loaded into hl
F01:0015       # the value in hl can change between os versions so do not hard code the values
F01:0016       
F01:0017       .equ GetAddress, 0x0804
F01:0018       .equ PRINT,1
F01:0019       .equ PRINTHEX,2
F01:0020       .equ LOADFILE,3
F01:0021       .equ MEMSET,4
F01:0022       .equ STRLEN,5
F01:0023       .equ PUTC,6
F01:0024       
F01:0025       
F01:0026       
F00:0003       .org commandMemory
F00:0004       
F00:0005       	ld a,PRINT
               S01:00001000:  3E 01
F00:0006       	call GetAddress
               S01:00001002:  CD 04 08
F00:0007       	ld (printadr),hl
               S01:00001005:  22 B1 11
F00:0008       	ld a,PRINTHEX
               S01:00001008:  3E 02
F00:0009       	call GetAddress
               S01:0000100A:  CD 04 08
F00:0010       	ld (printhexadr),hl
               S01:0000100D:  22 B4 11
F00:0011       	ld a,LOADFILE
               S01:00001010:  3E 03
F00:0012       	call GetAddress
               S01:00001012:  CD 04 08
F00:0013       	ld (loadfileadr),hl
               S01:00001015:  22 B7 11
F00:0014       	ld a,MEMSET
               S01:00001018:  3E 04
F00:0015       	call GetAddress
               S01:0000101A:  CD 04 08
F00:0016       	ld (memsetadr),hl
               S01:0000101D:  22 BA 11
F00:0017       	ld a,STRLEN
               S01:00001020:  3E 05
F00:0018       	call GetAddress
               S01:00001022:  CD 04 08
F00:0019       	ld (strlenadr),hl
               S01:00001025:  22 BD 11
F00:0020       	ld a,PUTC
               S01:00001028:  3E 06
F00:0021       	call GetAddress
               S01:0000102A:  CD 04 08
F00:0022       	ld (putcadr),hl
               S01:0000102D:  22 C0 11
F00:0023       
F00:0024       	
F00:0025       
F00:0026       	; setup the interrupt vector
F00:0027       	ld a, jumptable/256 ; initialize the new interrupt vector
               S01:00001030:  3E 12
F00:0028       	ld i,a
               S01:00001032:  ED 47
F00:0029       
F00:0030       newcommand:
F00:0031       	call resetcommandline
               S01:00001034:  CD 92 10
F00:0032       	ld hl,commandPromptmsg ;# display command prompt
               S01:00001037:  21 54 11
F00:0033       	call print
               S01:0000103A:  CD B0 11
F00:0034       loop:
F00:0035       	halt		;# wait for interrupt
               S01:0000103D:  76
F00:0036       	ld hl,cmdlineexecute ;# if user pressed enter then cmdlineexecute will contain 1
               S01:0000103E:  21 79 11
F00:0037       	ld a,(hl)
               S01:00001041:  7E
F00:0038       	cp 1
               S01:00001042:  FE 01
F00:0039       	jp nz,loop ;# nothing to process so repeat
               S01:00001044:  C2 3D 10
F00:0040       
F00:0041       	ld hl,cmdlinebuffer ;# test if user entered a value
               S01:00001047:  21 7B 11
F00:0042       	call strlen
               S01:0000104A:  CD BC 11
F00:0043       	ld a,b
               S01:0000104D:  78
F00:0044       	cp 0
               S01:0000104E:  FE 00
F00:0045       	jp z, newcommand ;# if no commands display prompt and repeat
               S01:00001050:  CA 34 10
F00:0046       
F00:0047       	ld hl,cmdlinebuffer
               S01:00001053:  21 7B 11
F00:0048       	call findbuiltin
               S01:00001056:  CD D4 10
F00:0049       	cp TRUE ;# true if builtin was found
               S01:00001059:  FE 01
F00:0050       	call nz,loadandrun ;# must be something to do
               S01:0000105B:  C4 61 10
F00:0051       	jp newcommand
               S01:0000105E:  C3 34 10
F00:0052       
F00:0053       loadandrun:
F00:0054       	
F00:0055       	ld hl,crlf
               S01:00001061:  21 50 11
F00:0056       	call print ;# display a new line
               S01:00001064:  CD B0 11
F00:0057       	ld hl, cmdlinebuffer ;# load filename of program
               S01:00001067:  21 7B 11
F00:0058       	ld de, userMemory ;# address where to load program
               S01:0000106A:  11 00 20
F00:0059       	call loadfile
               S01:0000106D:  CD B6 11
F00:0060       	cp 0
               S01:00001070:  FE 00
F00:0061       	jp nz,loaderr ;# if load returned anything except 0, its an error
               S01:00001072:  C2 78 10
F00:0062       	jp run
               S01:00001075:  C3 8B 10
F00:0063       
F00:0064       loaderr:
F00:0065       	call printhex ;# print return code
               S01:00001078:  CD B3 11
F00:0066       	ld hl,cmdlinebuffer
               S01:0000107B:  21 7B 11
F00:0067       	call print ;# print the command
               S01:0000107E:  CD B0 11
F00:0068       	ld hl,invalidcommandmsg
               S01:00001081:  21 57 11
F00:0069       	call print ;# print msg
               S01:00001084:  CD B0 11
F00:0070       	call resetcommandline
               S01:00001087:  CD 92 10
F00:0071       	ret
               S01:0000108A:  C9
F00:0072       
F00:0073       run:
F00:0074       	
F00:0075       	call userMemory
               S01:0000108B:  CD 00 20
F00:0076       	call resetcommandline
               S01:0000108E:  CD 92 10
F00:0077       	ret
               S01:00001091:  C9
F00:0078       
F00:0079       resetcommandline:
F00:0080       	push af
               S01:00001092:  F5
F00:0081       	push hl
               S01:00001093:  E5
F00:0082       # reset the command line variables
F00:0083       	ld hl,cmdlinebufferlen
               S01:00001094:  21 7A 11
F00:0084       	ld a,0
               S01:00001097:  3E 00
F00:0085       	ld (hl),a
               S01:00001099:  77
F00:0086       	ld hl, cmdlinebuffer
               S01:0000109A:  21 7B 11
F00:0087       	ld b, cmdlinebuffer$-cmdlinebuffer
               S01:0000109D:  06 32
F00:0088       	call memset
               S01:0000109F:  CD B9 11
F00:0089       	pop hl
               S01:000010A2:  E1
F00:0090       	pop af
               S01:000010A3:  F1
F00:0091       	ret
               S01:000010A4:  C9
F00:0092       
F00:0093       	;##############################################################
F00:0094       	cmdline: ;#/* interrupt 2, echo what was sent*/
F00:0095       		in a,(SERIALPORT)
               S01:000010A5:  DB 01
F00:0096       		cp 0x0d
               S01:000010A7:  FE 0D
F00:0097       		jp z, executecmd
               S01:000010A9:  CA CB 10
F00:0098       		cp 0x0a
               S01:000010AC:  FE 0A
F00:0099       		jp z,executeexit
               S01:000010AE:  CA D1 10
F00:0100       		
F00:0101       
F00:0102       	
F00:0103       		ld hl,cmdlinebufferlen # load the length into b
               S01:000010B1:  21 7A 11
F00:0104       		ld b,0
               S01:000010B4:  06 00
F00:0105       		ld c,(hl)
               S01:000010B6:  4E
F00:0106       
F00:0107       
F00:0108       		ld hl,cmdlinebuffer ;# load buffer address into hl
               S01:000010B7:  21 7B 11
F00:0109       		add hl,bc ;# add the buffer length to get the last character pointer
               S01:000010BA:  09
F00:0110       		ld (hl),a ;# store keyboard character
               S01:000010BB:  77
F00:0111       		
F00:0112       		ld hl,cmdlinebufferlen ;# load buffer length
               S01:000010BC:  21 7A 11
F00:0113       		inc (hl) ;# increment buffer len
               S01:000010BF:  34
F00:0114       		
F00:0115       
F00:0116       		out (SERIALPORT),a
               S01:000010C0:  D3 01
F00:0117       		ld a,0
               S01:000010C2:  3E 00
F00:0118       		ld hl,cmdlineexecute
               S01:000010C4:  21 79 11
F00:0119       		ld (hl),a
               S01:000010C7:  77
F00:0120       		jp executeexit
               S01:000010C8:  C3 D1 10
F00:0121       	executecmd:
F00:0122       		ld a,1
               S01:000010CB:  3E 01
F00:0123       		ld hl,cmdlineexecute
               S01:000010CD:  21 79 11
F00:0124       		ld (hl),a
               S01:000010D0:  77
F00:0125       	executeexit:
F00:0126       		ei
               S01:000010D1:  FB
F00:0127       		reti
               S01:000010D2:  ED 4D
F00:0128       
F00:0129       		
F00:0130       	;# ======================== find builtin function =======
F00:0131       		;# ld hl, buffer (zero terminated string)
F00:0132       		;# call findbuiltin
F00:0133       		;# returns TRUE if builtin command located
F00:0134       		;#         FALSE if no builtin command located
F00:0135       
F00:0136       findbuiltin:
F00:0137       	
F00:0138       	push hl ;# save hl
               S01:000010D4:  E5
F00:0139       	push hl
               S01:000010D5:  E5
F00:0140       
F00:0141       
F00:0142       	pop ix;# copy hl into ix, ix contains the user supplied cmd
               S01:000010D6:  DD E1
F00:0143       
F00:0144       	ld iy,builtin ;# load start of list
               S01:000010D8:  FD 21 6D 11
F00:0145       findbuiltinrestart:
F00:0146       	ld l, (iy)	;# load hl with the pointer address
               S01:000010DC:  FD 6E 00
F00:0147       	ld h, (iy+1)
               S01:000010DF:  FD 66 01
F00:0148       
F00:0149       findbuiltin1:
F00:0150       	ld a,(hl)
               S01:000010E2:  7E
F00:0151       	ld b,(ix)
               S01:000010E3:  DD 46 00
F00:0152       	sub (ix)
               S01:000010E6:  DD 96 00
F00:0153       
F00:0154       	inc ix ;# no flag changes for inc
               S01:000010E9:  DD 23
F00:0155       	inc hl
               S01:000010EB:  23
F00:0156       	jp z,findbuiltin1 ;# if the same characters repeat
               S01:000010EC:  CA E2 10
F00:0157       
F00:0158       	;# if we get here, its because the characters no longer match.
F00:0159       	;# so we need to test the builtin cmd to see if it's a zero,
F00:0160       	;# if it is then we have matched the builtin command
F00:0161       	dec hl ;# need to backup 1 byte because we moved it before the test
               S01:000010EF:  2B
F00:0162       	ld a,(hl)
               S01:000010F0:  7E
F00:0163       	cp 0
               S01:000010F1:  FE 00
F00:0164       	jp z,_findbuiltinSuccess
               S01:000010F3:  CA 14 11
F00:0165       	;# if we reach here then we did not find a match, so
F00:0166       	;# we can load the next builtin cmd and try again.
F00:0167       	pop hl
               S01:000010F6:  E1
F00:0168       	push hl ;# save hl
               S01:000010F7:  E5
F00:0169       	push hl ;# restore the user supplied cmd
               S01:000010F8:  E5
F00:0170       	pop ix ;# now ix contains the user supplied cmd
               S01:000010F9:  DD E1
F00:0171       	;# iy still contains the builtin address pointer.
F00:0172       	;# so if we add 4 bytes to it we will point to the next
F00:0173       	;# table entry for the builtin command.
F00:0174       	ld bc,4
               S01:000010FB:  01 04 00
F00:0175       	add iy,bc
               S01:000010FE:  FD 09
F00:0176       	;# before we try with the current entry we need to check
F00:0177       	;# its not the end of the list
F00:0178       	ld a,(iy)
               S01:00001100:  FD 7E 00
F00:0179       	cp 0
               S01:00001103:  FE 00
F00:0180       	jp nz, findbuiltinrestart
               S01:00001105:  C2 DC 10
F00:0181       	ld a,(iy+1)
               S01:00001108:  FD 7E 01
F00:0182       	cp 0
               S01:0000110B:  FE 00
F00:0183       	jp nz,findbuiltinrestart
               S01:0000110D:  C2 DC 10
F00:0184       	
F00:0185       
F00:0186       _findbuildtinFail:
F00:0187       	pop hl ;# remove the save hl
               S01:00001110:  E1
F00:0188       	ld a,FALSE
               S01:00001111:  3E 00
F00:0189       	ret
               S01:00001113:  C9
F00:0190       _findbuiltinSuccess:
F00:0191       	pop hl ;# remove the saved hl
               S01:00001114:  E1
F00:0192       	ld bc,2 ;# we have a success so now we load the address of the subroutine
               S01:00001115:  01 02 00
F00:0193       	add iy,bc
               S01:00001118:  FD 09
F00:0194       	
F00:0195       	ld l, (iy)	;# load hl with the pointer address
               S01:0000111A:  FD 6E 00
F00:0196       	ld h, (iy+1) ;# to jump into the address I need to use the iy registers
               S01:0000111D:  FD 66 01
F00:0197       	push hl
               S01:00001120:  E5
F00:0198       	pop iy
               S01:00001121:  FD E1
F00:0199       	jp (iy)
               S01:00001123:  FD E9
F00:0200       	halt ;# we will never get here
               S01:00001125:  76
F00:0201       
F00:0202       
F00:0203       
F00:0204       		;#======================= builtin functions ====================
F00:0205       		hexdumpcmd: .string "h,",0
               S01:00001126:  68 2C
               S01:00001128:  00
F00:0206       		smallh: .string "d,",0
               S01:0000112A:  64 2C
               S01:0000112C:  00
F00:0207       	hexdump:
F00:0208       		ld hl,hexdumpmsg
               S01:0000112E:  21 47 11
F00:0209       		call print
               S01:00001131:  CD B0 11
F00:0210       		ld a,TRUE
               S01:00001134:  3E 01
F00:0211       		ret
               S01:00001136:  C9
F00:0212       
F00:0213       
F00:0214       
F00:0215       		;#======================= builtin functions end ================
F00:0216       
F00:0217       messages:
F00:0218       	dbug1: .string "debug1",0
               S01:00001137:  64 65 62 75 67 31
               S01:0000113D:  00
F00:0219       	dbug2: .string "debug2",0
               S01:0000113F:  64 65 62 75 67 32
               S01:00001145:  00
F00:0220       	hexdumpmsg: .string "HEXDUMP\0"
               S01:00001147:  48 45 58 44 55 4D 50 00
F00:0221       	crlf: .string "\r\n",0
               S01:00001150:  0D 0A
               S01:00001152:  00
F00:0222       	commandPromptmsg: .string ">\0";
               S01:00001154:  3E 00
F00:0223       	invalidcommandmsg: .string ": Invalid command.\r\n\0"
               S01:00001157:  3A 20 49 6E 76 61 6C 69 64 20 63 6F 6D 6D 61 6E
               S01:00001167:  64 2E 0D 0A 00
F00:0224       builtin:
F00:0225       	;# 2bytes pointer to command - zero terminated, 2bytes pointer to handler Routines
F00:0226       	;# last item will have 0x000 to indicate end of list
F00:0227       	;#hexdump
F00:0228       		.2byte hexdumpcmd,hexdump
               S01:0000116D:  26 11
               S01:0000116F:  2E 11
F00:0229       		.2byte smallh,hexdump
               S01:00001171:  2A 11
               S01:00001173:  2E 11
F00:0230       
F00:0231       	endoflist: .2byte 0,0
               S01:00001175:  00 00
               S01:00001177:  00 00
F00:0232       
F00:0233       data:
F00:0234       	cmdlineexecute: .byte 0
               S01:00001179:  00
F00:0235       	cmdlinebufferlen: .byte 0
               S01:0000117A:  00
F00:0236       	cmdlinebuffer: .space 50
F00:0237       	cmdlinebuffer$:
F00:0238       
F00:0239       
F00:0240       functionlookups:
F00:0241       	.align 2
F00:0242       	print: .byte 0xc3
               S01:000011B0:  C3
F00:0243       	printadr: .2byte 0
               S01:000011B1:  00 00
F00:0244       	printhex: .byte 0xc3
               S01:000011B3:  C3
F00:0245       	printhexadr: .2byte 0
               S01:000011B4:  00 00
F00:0246       	loadfile: .byte 0xc3
               S01:000011B6:  C3
F00:0247       	loadfileadr: .2byte 0
               S01:000011B7:  00 00
F00:0248       	memset: .byte 0xc3
               S01:000011B9:  C3
F00:0249       	memsetadr: .2byte 0
               S01:000011BA:  00 00
F00:0250       	strlen: .byte 0xc3
               S01:000011BC:  C3
F00:0251       	strlenadr: .2byte 0
               S01:000011BD:  00 00
F00:0252       	putc: .byte 0xc3
               S01:000011BF:  C3
F00:0253       	putcadr: .2byte 0
               S01:000011C0:  00 00
F00:0254       
F00:0255       	.org 0x200
F00:0256       	jumptable: ;# for keyboard interrupts
F00:0257       	.2byte cmdline ;0
               S01:00001200:  A5 10
F00:0258       	.2byte cmdline ;0
               S01:00001202:  A5 10


Sections:
S01  seg1000


Sources:
F00  cmd.s
F01  Routines.inc
F02  SERIAL.inc
F03  SDCARD.inc


Symbols:
putc EXPR(4543=0x11bf) UNUSED ABS 
functionlookups EXPR(4525=0x11ad) UNUSED ABS 
data EXPR(4473=0x1179) UNUSED ABS 
endoflist EXPR(4469=0x1175) UNUSED ABS 
dbug2 EXPR(4415=0x113f) UNUSED ABS 
dbug1 EXPR(4407=0x1137) UNUSED ABS 
messages EXPR(4407=0x1137) UNUSED ABS 
hexdumpmsg EXPR(4423=0x1147) ABS 
hexdump EXPR(4398=0x112e) ABS 
smallh EXPR(4394=0x112a) ABS 
hexdumpcmd EXPR(4390=0x1126) ABS 
_findbuildtinFail EXPR(4368=0x1110) UNUSED ABS 
_findbuiltinSuccess EXPR(4372=0x1114) ABS 
findbuiltin1 EXPR(4322=0x10e2) ABS 
findbuiltinrestart EXPR(4316=0x10dc) ABS 
builtin EXPR(4461=0x116d) ABS 
executeexit EXPR(4305=0x10d1) ABS 
executecmd EXPR(4299=0x10cb) ABS 
cmdline EXPR(4261=0x10a5) ABS 
memset EXPR(4537=0x11b9) ABS 
cmdlinebuffer$ EXPR(4525=0x11ad) ABS 
cmdlinebufferlen EXPR(4474=0x117a) ABS 
invalidcommandmsg EXPR(4439=0x1157) ABS 
printhex EXPR(4531=0x11b3) ABS 
run EXPR(4235=0x108b) ABS 
loaderr EXPR(4216=0x1078) ABS 
loadfile EXPR(4534=0x11b6) ABS 
crlf EXPR(4432=0x1150) ABS 
loadandrun EXPR(4193=0x1061) ABS 
findbuiltin EXPR(4308=0x10d4) ABS 
strlen EXPR(4540=0x11bc) ABS 
cmdlinebuffer EXPR(4475=0x117b) ABS 
cmdlineexecute EXPR(4473=0x1179) ABS 
loop EXPR(4157=0x103d) ABS 
print EXPR(4528=0x11b0) ABS 
commandPromptmsg EXPR(4436=0x1154) ABS 
resetcommandline EXPR(4242=0x1092) ABS 
newcommand EXPR(4148=0x1034) ABS 
jumptable EXPR(4608=0x1200) ABS 
putcadr EXPR(4544=0x11c0) ABS 
strlenadr EXPR(4541=0x11bd) ABS 
memsetadr EXPR(4538=0x11ba) ABS 
loadfileadr EXPR(4535=0x11b7) ABS 
printhexadr EXPR(4532=0x11b4) ABS 
printadr EXPR(4529=0x11b1) ABS 
PUTC EXPR(6=0x6) 
STRLEN EXPR(5=0x5) 
MEMSET EXPR(4=0x4) 
LOADFILE EXPR(3=0x3) 
PRINTHEX EXPR(2=0x2) 
PRINT EXPR(1=0x1) 
GetAddress EXPR(2052=0x804) 
FALSE EXPR(0=0x0) 
TRUE EXPR(1=0x1) 
userMemory EXPR(8192=0x2000) 
commandMemory EXPR(4096=0x1000) 
AVAILABLE EXPR(6=0x6) UNUSED 
READNEXTBYTE EXPR(5=0x5) UNUSED 
FILENAMEAPPEND EXPR(4=0x4) UNUSED 
CLOSE EXPR(3=0x3) UNUSED 
OPEN EXPR(2=0x2) UNUSED 
FILENAMECLEAR EXPR(1=0x1) UNUSED 
SDCARD EXPR(5=0x5) UNUSED 
SERIALPORT EXPR(1=0x1) 
__VASM EXPR(0=0x0) INTERNAL 
__MSDOSFS EXPR(0=0x0) INTERNAL 

There have been no errors.

F00:0001       
F00:0002       
F00:0003       
F00:0004       #define LOWORD(l) ((WORD)(l))
F00:0005       #define HIWORD(l) ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
F00:0006       #define LOBYTE(w) ((BYTE)(w))
F00:0007       #define HIBYTE(w) ((BYTE)(((WORD)(w) >> 8) & 0xFF))
F00:0008       # process table - maximum number of entries - which also means the maximum number of processes
F00:0009       .set MAXPROCESSES,4
F00:0010       .set PROCINFOSIZE,8
F00:0011       
F00:0012       .include "SDCARD.inc"
F01:0001       .equ SDCARD,0x05
F01:0002       ; ******* SDCARD *********
F01:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F01:0004       .equ FILENAMECLEAR ,1
F01:0005       
F01:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F01:0007       .equ OPEN ,2
F01:0008       
F01:0009       ; z80 out - close: no return value
F01:0010       .equ CLOSE ,3
F01:0011       
F01:0012       ; z80 out + out - filenameappend: no return value
F01:0013       .equ FILENAMEAPPEND ,4
F01:0014       
F01:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F01:0016       .equ READNEXTBYTE ,5
F01:0017       
F01:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F01:0019       .equ AVAILABLE ,6
F01:0020       
F01:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F01:0022       .equ OPENWRITE,7
F01:0023       
F01:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F01:0025       .equ WRITEBYTE,8
F01:0026       
F01:0027       ;#===============================
F01:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F01:0029       .equ GETNAME,0x20
F01:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F01:0031       .equ NAMEAVAILABLE,0x21
F01:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F01:0033       .equ OPENDIRECTORY,0x31
F01:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F01:0035       .equ NEXTFILE,0x32
F00:0013       .include "Routines.inc"
F02:0001       
F02:0002       .macro DEBUG CHARACTER='!'
F02:0009       
F02:0010       
F02:0011       .macro DEBUGHEX CHARACTER='!'
F02:0018       
F02:0019       
F02:0020       .macro PRINTLN
F02:0025       
F02:0026       
F02:0027       .macro DPRINTLN MSG=""
F02:0034       
F02:0035       
F02:0036       
F02:0037       # address where user programs load
F02:0038       .include "SERIAL.inc"
F03:0001       .equ SERIALPORT , 0x01
F03:0002       .equ SERIALPORT2, 0x02
F03:0003       
F02:0039       .include "SDCARD.inc"
F04:0001       .equ SDCARD,0x05
F04:0002       ; ******* SDCARD *********
F04:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F04:0004       .equ FILENAMECLEAR ,1
F04:0005       
F04:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F04:0007       .equ OPEN ,2
F04:0008       
F04:0009       ; z80 out - close: no return value
F04:0010       .equ CLOSE ,3
F04:0011       
F04:0012       ; z80 out + out - filenameappend: no return value
F04:0013       .equ FILENAMEAPPEND ,4
F04:0014       
F04:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F04:0016       .equ READNEXTBYTE ,5
F04:0017       
F04:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F04:0019       .equ AVAILABLE ,6
F04:0020       
F04:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F04:0022       .equ OPENWRITE,7
F04:0023       
F04:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F04:0025       .equ WRITEBYTE,8
F04:0026       
F04:0027       ;#===============================
F04:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F04:0029       .equ GETNAME,0x20
F04:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F04:0031       .equ NAMEAVAILABLE,0x21
F04:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F04:0033       .equ OPENDIRECTORY,0x31
F04:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F04:0035       .equ NEXTFILE,0x32
F02:0040       .equ commandMemory, 0x2000
F02:0041       .equ userMemory,0x3000
F02:0042       .equ libMemory,0xF000
F02:0043       
F02:0044       .equ TRUE, 1
F02:0045       .equ FALSE, 0
F02:0046       
F02:0047       # the only fixed address (i hope), use it to get the address of utilities methods
F02:0048       # ld a, PRINT
F02:0049       # call GetAddress
F02:0050       # address for print loaded into hl
F02:0051       # the value in hl can change between os versions so do not hard code the values
F02:0052       
F02:0053       .equ GetAddress, 0x0804
F02:0054       .equ SETPROCID,28
F02:0055       .equ PRINT,		1
F02:0056       .equ PRINTLN,	9
F02:0057       .equ PRINTHEX,	2
F02:0058       .equ PRINTHEXL,21
F02:0059       .equ LOADFILE,	3
F02:0060       .equ MEMSET,	4
F02:0061       .equ STRLEN,	5
F02:0062       .equ STRCPY,24
F02:0063       .equ STRNCPY,10
F02:0064       .equ PUTC,		6
F02:0065       .equ TOUPPERCASE,7
F02:0066       .equ HEXTOBYTE,	8
F02:0067       .equ CREATEPROCESS,16
F02:0068       .equ GETCOMMANDPARAMS,17
F02:0069       # filesystem - primitive functions, probably going to change 
F02:0070       .equ DIRECTORYOPEN,13
F02:0071       .equ DIRECTORYNEXTFILE,14
F02:0072       .equ GETFILENAME,15
F02:0073       .equ GETMALLOCTABLE,18
F02:0074       .equ DIV8,19
F02:0075       .equ SETRESETPAGE,20
F02:0076       .equ STARTPROCESSINFO,22
F02:0077       .equ NEXTPROCESSINFO,23
F02:0078       .equ GETPROCESSBYID,26
F02:0079       .equ MULTIPLY8,27
F02:0080       .equ EXITPROCESS,29
F02:0081       
F02:0082       
F02:0083       
F02:0084       
F02:0085       .equ NEXTNUMBER,30
F02:0086       
F02:0087       
F00:0014       
F00:0015       
F00:0016       	.org 0x800
F00:0017       	jp boot
               S01:00000800:  C3 07 08
F00:0018       	.align 2
F00:0019       	start:
F00:0020       	jp loadaddress
               S01:00000804:  C3 3B 0E
F00:0021       	
F00:0022       boot:
F00:0023       	ld sp,0xffff
               S01:00000807:  31 FF FF
F00:0024       
F00:0025       	di
               S01:0000080A:  F3
F00:0026       	ld hl,readymsg
               S01:0000080B:  21 4F 0F
F00:0027       	call print
               S01:0000080E:  CD A1 08
F00:0028       		;ld b, endlabel2-label2
F00:0029       		;ld c,SERIALPORT
F00:0030       		;otir
F00:0031       		
F00:0032       		im 2 ;/* interrupt mode 2*/
               S01:00000811:  ED 5E
F00:0033       		ld a, jumptable/256 ;// hibyte
               S01:00000813:  3E 11
F00:0034       		ld i,a
               S01:00000815:  ED 47
F00:0035       		ei   ;#/* enable interrupts*/
               S01:00000817:  FB
F00:0036       
F00:0037       		ld hl,loadedmsg
               S01:00000818:  21 46 0F
F00:0038       		call print
               S01:0000081B:  CD A1 08
F00:0039       		#== ******* Command processor Loop ******** ==# I THINK THIS NEEDS A REVIEW IT SHOULD BE USING CREATEPROCESS
F00:0040       	commandprocessloop:	
F00:0041       		ld hl,commandprocessor
               S01:0000081E:  21 5E 0F
F00:0042       #		ld de,commandMemory
F00:0043       		ld de,0
               S01:00000821:  11 00 00
F00:0044       		call loadFILE
               S01:00000824:  CD E3 08
F00:0045       		cp 0
               S01:00000827:  FE 00
F00:0046       		jp nz,errorloading
               S01:00000829:  C2 3B 08
F00:0047       		ld (_cmdlne),hl ;# save the load address
               S01:0000082C:  22 48 08
F00:0048       		ld hl,0
               S01:0000082F:  21 00 00
F00:0049       		call println
               S01:00000832:  CD 93 08
F00:0050       #		call commandMemory # run the file just loaded.
F00:0051       		call commandline
               S01:00000835:  CD 47 08
F00:0052       		jp commandprocessloop
               S01:00000838:  C3 1E 08
F00:0053       
F00:0054       	errorloading:
F00:0055       		call printhex
               S01:0000083B:  CD CA 08
F00:0056       		ld hl,errorloadingmsg
               S01:0000083E:  21 62 0F
F00:0057       		call println
               S01:00000841:  CD 93 08
F00:0058       		jp commandprocessloop
               S01:00000844:  C3 1E 08
F00:0059       
F00:0060       commandline: .byte 0xc3
               S01:00000847:  C3
F00:0061       	_cmdlne: .2byte 0
               S01:00000848:  00 00
F00:0062       
F00:0063       		#======================suboutines===============================================#
F00:0064       	# === memset === #
F00:0065       		# ld hl, address to start
F00:0066       		# ld a,0 byte to write into address
F00:0067       		# ld b,1 count of bytes to write
F00:0068       	memset:
F00:0069       		push af
               S01:0000084A:  F5
F00:0070       		push hl
               S01:0000084B:  E5
F00:0071       	_metset$1:
F00:0072       		ld (hl),a
               S01:0000084C:  77
F00:0073       		inc hl
               S01:0000084D:  23
F00:0074       		djnz _metset$1
               S01:0000084E:  10 FC
F00:0075       		pop hl
               S01:00000850:  E1
F00:0076       		pop af
               S01:00000851:  F1
F00:0077       		ret
               S01:00000852:  C9
F00:0078       	#== strlen ==#
F00:0079       		# ld hl, address to start
F00:0080       		# call strlen
F00:0081       		# return len in b
F00:0082       	strlen:
F00:0083       		push hl
               S01:00000853:  E5
F00:0084       		push af
               S01:00000854:  F5
F00:0085       	
F00:0086       		ld b,0
               S01:00000855:  06 00
F00:0087       	_strlen$:
F00:0088       		ld a,(hl)
               S01:00000857:  7E
F00:0089       		cp 0
               S01:00000858:  FE 00
F00:0090       		jp z, strlenexit
               S01:0000085A:  CA 62 08
F00:0091       		inc b
               S01:0000085D:  04
F00:0092       		inc hl
               S01:0000085E:  23
F00:0093       		jp _strlen$:
               S01:0000085F:  C3 57 08
F00:0094       	strlenexit:
F00:0095       	;#	ld a,b
F00:0096       	;#	call printhex
F00:0097       		pop af
               S01:00000862:  F1
F00:0098       		pop hl
               S01:00000863:  E1
F00:0099       		ret
               S01:00000864:  C9
F00:0100       
F00:0101       	#=== strncpy ==#
F00:0102       	;# copy from source into destination size bytes. no validation is done.
F00:0103       	;# ld hl, source
F00:0104       	;# ld de, destination
F00:0105       	;# ld bc, size
F00:0106       	;# this will copy binary strings??? so this needs fixing to stop on a null byte
F00:0107       
F00:0108       	strncpy:
F00:0109       		ldir
               S01:00000865:  ED B0
F00:0110       		ret
               S01:00000867:  C9
F00:0111       
F00:0112       	# === strcpy == #
F00:0113       	;# copy from source into destination string is zero terminated, no validation is done
F00:0114       	;# ld hl,source
F00:0115       	;# ld de,destination
F00:0116       	;# call strcpy
F00:0117       	strcpy:
F00:0118       		push af
               S01:00000868:  F5
F00:0119       		push hl
               S01:00000869:  E5
F00:0120       		push de
               S01:0000086A:  D5
F00:0121       	_1$:
F00:0122       		ld a,(hl)
               S01:0000086B:  7E
F00:0123       		ld (de),a ;# copy the potential zero before we test because we will need it
               S01:0000086C:  12
F00:0124       		cp 0
               S01:0000086D:  FE 00
F00:0125       		jp z, _strcpyexit$1
               S01:0000086F:  CA 77 08
F00:0126       
F00:0127       		inc de
               S01:00000872:  13
F00:0128       		inc hl
               S01:00000873:  23
F00:0129       		jp _1$
               S01:00000874:  C3 6B 08
F00:0130       	
F00:0131       	_strcpyexit$1:
F00:0132       		pop de
               S01:00000877:  D1
F00:0133       		pop hl
               S01:00000878:  E1
F00:0134       		pop af
               S01:00000879:  F1
F00:0135       		ret
               S01:0000087A:  C9
F00:0136       		# === touppercase ==#
F00:0137       	;#		ld hl,cmd  - zero terminated string
F00:0138       	;#		call touppercase
F00:0139       	;#		ret
F00:0140       	;# the P flag means the comparison was Positive
F00:0141       	;# the M flags means the comparision was Negative
F00:0142       	;# the Z flag means the comparison was equal
F00:0143       	;# the NZ flag means the comparison was not equal.
F00:0144       	;# where:
F00:0145       	;#    A = x  P Positive
F00:0146       	;#			 Z Zero
F00:0147       	;#
F00:0148       	;#    A < x	 M Negative
F00:0149       	;#			 NZ Not zero
F00:0150       	;#
F00:0151       	;#	  A > x  P Positive
F00:0152       	;#			 NZ Not zero
F00:0153       	;#
F00:0154       	;# so a test for JP P,meansSameOrGreater
F00:0155       
F00:0156       
F00:0157       touppercase:
F00:0158       	push af
               S01:0000087B:  F5
F00:0159       	push hl
               S01:0000087C:  E5
F00:0160       	
F00:0161       goagain:
F00:0162       	ld a,(hl)
               S01:0000087D:  7E
F00:0163       	cp 'a'
               S01:0000087E:  FE 61
F00:0164       	jp p, converttouppercaseletter ;# is same or greater then 'a'
               S01:00000880:  F2 86 08
F00:0165       ;# the instructions commented out are implied
F00:0166       	;#cp 'A'
F00:0167       	;#jp p, nextcharacter ;# is same or greater
F00:0168       	;#cp '0'
F00:0169       	;#jp p, nextcharacter
F00:0170       	;# jp nextcharacter replaces the above 4 lines
F00:0171       	jp nextcharacter
               S01:00000883:  C3 89 08
F00:0172       
F00:0173       converttouppercaseletter:
F00:0174       	sub 32
               S01:00000886:  D6 20
F00:0175       	ld (hl),a
               S01:00000888:  77
F00:0176       nextcharacter:
F00:0177       	inc hl
               S01:00000889:  23
F00:0178       	ld a,(hl)
               S01:0000088A:  7E
F00:0179       	cp 0
               S01:0000088B:  FE 00
F00:0180       	jp nz,goagain	
               S01:0000088D:  C2 7D 08
F00:0181       
F00:0182       	pop hl
               S01:00000890:  E1
F00:0183       	pop af
               S01:00000891:  F1
F00:0184       
F00:0185       	ret
               S01:00000892:  C9
F00:0186       	# === PRINTLN == #
F00:0187       	println: ;// same as print but appends CRLF
F00:0188       	call print
               S01:00000893:  CD A1 08
F00:0189       	push hl
               S01:00000896:  E5
F00:0190       	push af
               S01:00000897:  F5
F00:0191       	ld hl,crlf
               S01:00000898:  21 43 0F
F00:0192       	call print
               S01:0000089B:  CD A1 08
F00:0193       	pop af
               S01:0000089E:  F1
F00:0194       	pop hl
               S01:0000089F:  E1
F00:0195       	ret
               S01:000008A0:  C9
F00:0196       
F00:0197       	# === PRINT === #
F00:0198       	print: ;// expecting a zero terminated string
F00:0199       		push hl
               S01:000008A1:  E5
F00:0200       		push af
               S01:000008A2:  F5
F00:0201       		;# hl can be null so check for that first
F00:0202       		ld a,h
               S01:000008A3:  7C
F00:0203       		cp 0
               S01:000008A4:  FE 00
F00:0204       		jp nz,_$1 ;# hibyte not null, no just print it
               S01:000008A6:  C2 AF 08
F00:0205       		ld a,l
               S01:000008A9:  7D
F00:0206       		cp 0
               S01:000008AA:  FE 00
F00:0207       		jp z,_$2 ;# lobyte is null and hibyte is null so just exit
               S01:000008AC:  CA BA 08
F00:0208       		_$1:
F00:0209       			ld a,(hl)
               S01:000008AF:  7E
F00:0210       			cp 0
               S01:000008B0:  FE 00
F00:0211       			jr z,_$2
               S01:000008B2:  28 06
F00:0212       			out (SERIALPORT),a
               S01:000008B4:  D3 01
F00:0213       			inc hl
               S01:000008B6:  23
F00:0214       			jp _$1
               S01:000008B7:  C3 AF 08
F00:0215       _$2:			
F00:0216       		pop af
               S01:000008BA:  F1
F00:0217       		pop hl
               S01:000008BB:  E1
F00:0218       		ret
               S01:000008BC:  C9
F00:0219       ;#=== printhexL ===#
F00:0220       ;# ld hl,passwords
F00:0221       ;# call printhexL
F00:0222       
F00:0223       printhexL:
F00:0224       	push af
               S01:000008BD:  F5
F00:0225       	push hl
               S01:000008BE:  E5
F00:0226       	ld a,h
               S01:000008BF:  7C
F00:0227       	call printhex
               S01:000008C0:  CD CA 08
F00:0228       	ld a,l
               S01:000008C3:  7D
F00:0229       	call printhex
               S01:000008C4:  CD CA 08
F00:0230       	pop hl
               S01:000008C7:  E1
F00:0231       	pop af
               S01:000008C8:  F1
F00:0232       	ret
               S01:000008C9:  C9
F00:0233       # === PRINTHEX === #
F00:0234       		;Display 8-bit number in hex.
F00:0235       		; 	ld a,0xaa
F00:0236       	;       call printhex
F00:0237       printhex:
F00:0238       
F00:0239       ; Input: a
F00:0240       
F00:0241         push af
               S01:000008CA:  F5
F00:0242         ;// remove low nibble
F00:0243          rra
               S01:000008CB:  1F
F00:0244          rra
               S01:000008CC:  1F
F00:0245          rra
               S01:000008CD:  1F
F00:0246          rra
               S01:000008CE:  1F
F00:0247          call  _$
               S01:000008CF:  CD D3 08
F00:0248          ;// restore low nibble
F00:0249          pop af
               S01:000008D2:  F1
F00:0250          
F00:0251       _$:
F00:0252       	push af
               S01:000008D3:  F5
F00:0253       	;// remove high nibble
F00:0254          and  0x0F
               S01:000008D4:  E6 0F
F00:0255          add  a,0x90
               S01:000008D6:  C6 90
F00:0256          ;; bcd adjust
F00:0257          daa
               S01:000008D8:  27
F00:0258          adc  a,0x40
               S01:000008D9:  CE 40
F00:0259          daa
               S01:000008DB:  27
F00:0260          out (SERIALPORT),a 
               S01:000008DC:  D3 01
F00:0261          pop af
               S01:000008DE:  F1
F00:0262          ret
               S01:000008DF:  C9
F00:0263       
F00:0264       # === putc ===== #
F00:0265       ;# ld a,'*'
F00:0266       ;# call putc
F00:0267       ;# no return value
F00:0268       putc:
F00:0269       		out (SERIALPORT),a
               S01:000008E0:  D3 01
F00:0270       		ret
               S01:000008E2:  C9
F00:0271       
F00:0272       		;// end subroutines
F00:0273       # === loadFILE === #
F00:0274       ; ld hl, filename (zero terminated)
F00:0275       ; ld de, memory address to load file into
F00:0276       ; call loadFILE
F00:0277       ; returns 
F00:0278       ;	HL
F00:0279       ;		baseaddress of the dll
F00:0280       ;	A register 
F00:0281       ;			2 = failed to open the file
F00:0282       ;			0 = if file loaded into memory
F00:0283       ;	DE register pair
F00:0284       ;			count of bytes loaded
F00:0285       loadFILE:
F00:0286       	push af
               S01:000008E3:  F5
F00:0287       	push de ; save de for later
               S01:000008E4:  D5
F00:0288       	call sizereset
               S01:000008E5:  CD C7 09
F00:0289       	ld a,0 ;# erase the executable header information
               S01:000008E8:  3E 00
F00:0290       	ld (startaddress),a
               S01:000008EA:  32 F4 09
F00:0291       	ld (startaddress+1),a
               S01:000008ED:  32 F5 09
F00:0292       	ld (startaddress+2),a
               S01:000008F0:  32 F6 09
F00:0293       	ld (startaddress+3),a
               S01:000008F3:  32 F7 09
F00:0294       		; try to open the SD card and read some data
F00:0295       		ld a,FILENAMECLEAR ; // filenameclear
               S01:000008F6:  3E 01
F00:0296       		out (SDCARD),a
               S01:000008F8:  D3 05
F00:0297       
F00:0298       
F00:0299       ;
F00:0300       _$getnextchar:
F00:0301       		ld a,(hl)
               S01:000008FA:  7E
F00:0302       		cp 0
               S01:000008FB:  FE 00
F00:0303       		jp z, _$openfile #; if filename character is null we have finished
               S01:000008FD:  CA 0B 09
F00:0304       		ld a,FILENAMEAPPEND
               S01:00000900:  3E 04
F00:0305       		out (SDCARD),a ; // filenameappend
               S01:00000902:  D3 05
F00:0306       		ld a,(hl)
               S01:00000904:  7E
F00:0307       		out (SDCARD),a
               S01:00000905:  D3 05
F00:0308       		;#out (SERIALPORT),a
F00:0309       		inc hl
               S01:00000907:  23
F00:0310       		jp _$getnextchar
               S01:00000908:  C3 FA 08
F00:0311       
F00:0312       _$openfile:
F00:0313       #openfile will return 1 if the file was opened, 0 if it failed to open
F00:0314       		ld a,OPEN	;// Open
               S01:0000090B:  3E 02
F00:0315       		out (SDCARD),a
               S01:0000090D:  D3 05
F00:0316       		in a,(SDCARD)
               S01:0000090F:  DB 05
F00:0317       		pop hl ; get load address - must pop the stack before returning
               S01:00000911:  E1
F00:0318       		cp 0
               S01:00000912:  FE 00
F00:0319       		jp nz,testloadaddress
               S01:00000914:  C2 1E 09
F00:0320       		pop af ;# a flag not needed now
               S01:00000917:  F1
F00:0321       		call sizeloaded
               S01:00000918:  CD B8 09
F00:0322       		ld a,2 ;we have an error trying to open the file.
               S01:0000091B:  3E 02
F00:0323       		ret
               S01:0000091D:  C9
F00:0324       testloadaddress:
F00:0325       	# if loadaddress (hl) = 0, then the file will have load address information in the 1st 2 bytes
F00:0326       	ld a,0
               S01:0000091E:  3E 00
F00:0327       	cp h
               S01:00000920:  BC
F00:0328       	jp nz,available ;# h is not zero so it must have an address to load into already
               S01:00000921:  C2 84 09
F00:0329       	cp l
               S01:00000924:  BD
F00:0330       	jp nz,available ;# l is not zero so it must have an address to load intop already
               S01:00000925:  C2 84 09
F00:0331       
F00:0332       	ld hl,startaddress ;# this is the place to store the 2 bytes we need to get at the load address
               S01:00000928:  21 F4 09
F00:0333       	call loadheader
               S01:0000092B:  CD 5B 09
F00:0334       	cp 1
               S01:0000092E:  FE 01
F00:0335       	jp nz,_4$
               S01:00000930:  C2 58 09
F00:0336       
F00:0337       	ld hl,(startaddress)
               S01:00000933:  2A F4 09
F00:0338       	inc hl ;#start address
               S01:00000936:  23
F00:0339       	inc hl
               S01:00000937:  23
F00:0340       	inc hl ;# program size in pages
               S01:00000938:  23
F00:0341       	inc hl ;# stack size in pages
               S01:00000939:  23
F00:0342       	ld (startaddress),hl ;# this is now the dll entry point address, will need this later to initialize the library
               S01:0000093A:  22 F4 09
F00:0343       
F00:0344       	ld a,(memorypages)
               S01:0000093D:  3A F6 09
F00:0345       	ld b,a
               S01:00000940:  47
F00:0346       	ld a,h
               S01:00000941:  7C
F00:0347       
F00:0348       45$:	DEBUGHEX a
F05:0001       # example : DEBUGHEX '!'
F05:0002       #      or : DEBUGHEX h
F05:0003       		push af
               S01:00000942:  F5
F05:0004       		ld a,a
               S01:00000943:  7F
F05:0005       		call printhex
               S01:00000944:  CD CA 08
F05:0006       		pop af
               S01:00000947:  F1
F00:0349       	DEBUG '\n'
F06:0001       # example : DEBUG '!'
F06:0002       #      or : DEBUG h
F06:0003       		push af
               S01:00000948:  F5
F06:0004       		ld a,10
               S01:00000949:  3E 0A
F06:0005       		call putc
               S01:0000094B:  CD E0 08
F06:0006       		pop af
               S01:0000094E:  F1
F00:0350       
F00:0351       	call reservemalloc
               S01:0000094F:  CD BC 0D
F00:0352       	inc a
               S01:00000952:  3C
F00:0353       	djnz 45$
               S01:00000953:  10 ED
F00:0354       
F00:0355       	jp available
               S01:00000955:  C3 84 09
F00:0356       _4$:
F00:0357       	ld a,3 ;#new error code
               S01:00000958:  3E 03
F00:0358       	ret
               S01:0000095A:  C9
F00:0359       	#if we reach here then the first 2 bytes have the address information so let read them now
F00:0360       	;# header information
F00:0361       	;# 2bytes program load address
F00:0362       	;# 1byte memory required in pages
F00:0363       	;# 1byte stack required in pages
F00:0364       loadheader:
F00:0365       	ld b,4
               S01:0000095B:  06 04
F00:0366       	ld c,0
               S01:0000095D:  0E 00
F00:0367       _2$:
F00:0368       	ld a, AVAILABLE
               S01:0000095F:  3E 06
F00:0369       	out (SDCARD),a
               S01:00000961:  D3 05
F00:0370       	in a,(SDCARD) ;# is data available?
               S01:00000963:  DB 05
F00:0371       	cp 0
               S01:00000965:  FE 00
F00:0372       	jp nz,_1$
               S01:00000967:  C2 77 09
F00:0373       	pop af ;#restore af
               S01:0000096A:  F1
F00:0374       	ld hl,0
               S01:0000096B:  21 00 00
F00:0375       		call println
               S01:0000096E:  CD 93 08
F00:0376       		call sizeloaded
               S01:00000971:  CD B8 09
F00:0377       		ld a,0 ;# use 0 in A to indicate a fail
               S01:00000974:  3E 00
F00:0378       		ret ;#- exit loadheader because the file read had a problem
               S01:00000976:  C9
F00:0379       _1$:
F00:0380       		;// if we get here then there is data to read
F00:0381       		ld a,READNEXTBYTE
               S01:00000977:  3E 05
F00:0382       		out (SDCARD),a ;// read nextbyte
               S01:00000979:  D3 05
F00:0383       		in a,(SDCARD)
               S01:0000097B:  DB 05
F00:0384       		ld (hl),a ; // store byte in RAM (OSLOAD)
               S01:0000097D:  77
F00:0385       		inc hl 
               S01:0000097E:  23
F00:0386       		djnz _2$
               S01:0000097F:  10 DE
F00:0387       		ld a,1 ;# use 1 in A to indicate a success
               S01:00000981:  3E 01
F00:0388       		ret ;# exit loadheader because we have loaded 4 bytes
               S01:00000983:  C9
F00:0389       available:
F00:0390       	#available will return 1 if there is data to read, 0 if no data to read
F00:0391       		ld a, AVAILABLE ; // available
               S01:00000984:  3E 06
F00:0392       		out (SDCARD),a
               S01:00000986:  D3 05
F00:0393       		in a,(SDCARD) ;// read the value from the device
               S01:00000988:  DB 05
F00:0394       	;	ld b,a ; // going to malipulate the a register so save it as not to destroy the A result
F00:0395       	;	add a,'0' ;// make it printable
F00:0396       	;	out (SERIALPORT),a ;// print response
F00:0397       	;	ld a,b
F00:0398       		cp 0 ;// compare the A reg returned by the device
               S01:0000098A:  FE 00
F00:0399       		jp nz,_$nextbyte
               S01:0000098C:  C2 A7 09
F00:0400       		pop af ;# restore the af registers because it will tell me if I need to zero terminate the loaded file
               S01:0000098F:  F1
F00:0401       		cp 1
               S01:00000990:  FE 01
F00:0402       		jp nz,_1$
               S01:00000992:  C2 98 09
F00:0403       		;# the hl register pair contains the last address we need to write a zero here because the user wants it
F00:0404       		ld a,0
               S01:00000995:  3E 00
F00:0405       		ld (hl),a ;# zero terminated
               S01:00000997:  77
F00:0406       
F00:0407       _1$:
F00:0408       		ld hl,0
               S01:00000998:  21 00 00
F00:0409       		call println
               S01:0000099B:  CD 93 08
F00:0410       		call sizeloaded
               S01:0000099E:  CD B8 09
F00:0411       		ld hl,(startaddress) ;# return the startaddress
               S01:000009A1:  2A F4 09
F00:0412       		ld a,0
               S01:000009A4:  3E 00
F00:0413       		ret
               S01:000009A6:  C9
F00:0414       _$nextbyte:
F00:0415       		;// if we get here then there is data to read
F00:0416       		ld a,READNEXTBYTE
               S01:000009A7:  3E 05
F00:0417       		out (SDCARD),a ;// read nextbyte
               S01:000009A9:  D3 05
F00:0418       		in a,(SDCARD)
               S01:000009AB:  DB 05
F00:0419       		ld (hl),a ; // store byte in RAM (OSLOAD)
               S01:000009AD:  77
F00:0420       		inc hl 
               S01:000009AE:  23
F00:0421       		ld a,'#'
               S01:000009AF:  3E 23
F00:0422       		out (SERIALPORT),a ;// just echo it back for now
               S01:000009B1:  D3 01
F00:0423       		call sizeincrement
               S01:000009B3:  CD DA 09
F00:0424       		jr available ;
               S01:000009B6:  18 CC
F00:0425       
F00:0426       sizeloaded:
F00:0427       	push ix
               S01:000009B8:  DD E5
F00:0428       	ld ix,losize
               S01:000009BA:  DD 21 F2 09
F00:0429       	ld e,(ix)
               S01:000009BE:  DD 5E 00
F00:0430       	ld d,(ix+1)
               S01:000009C1:  DD 56 01
F00:0431       	pop ix
               S01:000009C4:  DD E1
F00:0432       	ret
               S01:000009C6:  C9
F00:0433       sizereset:
F00:0434       	push ix
               S01:000009C7:  DD E5
F00:0435       	push af
               S01:000009C9:  F5
F00:0436       	ld a,0
               S01:000009CA:  3E 00
F00:0437       	ld ix,losize
               S01:000009CC:  DD 21 F2 09
F00:0438       	ld (ix),a
               S01:000009D0:  DD 77 00
F00:0439       	ld (ix+1),a
               S01:000009D3:  DD 77 01
F00:0440       	pop af
               S01:000009D6:  F1
F00:0441       	pop ix
               S01:000009D7:  DD E1
F00:0442       	ret
               S01:000009D9:  C9
F00:0443       sizeincrement:
F00:0444       	push ix
               S01:000009DA:  DD E5
F00:0445       	push hl
               S01:000009DC:  E5
F00:0446       
F00:0447       	ld ix,losize
               S01:000009DD:  DD 21 F2 09
F00:0448       	ld l,(ix)
               S01:000009E1:  DD 6E 00
F00:0449       	ld h,(ix+1)
               S01:000009E4:  DD 66 01
F00:0450       	inc HL
               S01:000009E7:  23
F00:0451       	ld (ix),l
               S01:000009E8:  DD 75 00
F00:0452       	ld (ix+1),h
               S01:000009EB:  DD 74 01
F00:0453       
F00:0454       	pop hl
               S01:000009EE:  E1
F00:0455       	pop ix
               S01:000009EF:  DD E1
F00:0456       	ret
               S01:000009F1:  C9
F00:0457       
F00:0458       losize: .byte 0
               S01:000009F2:  00
F00:0459       hisize: .byte 0
               S01:000009F3:  00
F00:0460       
F00:0461       ;# executable header information
F00:0462       startaddress: .2byte 0
               S01:000009F4:  00 00
F00:0463       memorypages: .byte 0
               S01:000009F6:  00
F00:0464       stackpages: .byte 0
               S01:000009F7:  00
F00:0465       ;# ====== hextobyte ==========
F00:0466       ;#    load HL registers with the 2 ascii characters of a hexadecimal value
F00:0467       ;# note routine does not validate the inputs.
F00:0468       ;# alphabeta expected in uppercase
F00:0469       ;#	ld h,'c'
F00:0470       ;#	ld l,'3'
F00:0471       ;#	call hextobyte
F00:0472       ;#	value stored in A register
F00:0473       
F00:0474       
F00:0475       hextobyte:
F00:0476       	push hl
               S01:000009F8:  E5
F00:0477       	push bc
               S01:000009F9:  C5
F00:0478       	ld a,l ;# prepare the low nibble
               S01:000009FA:  7D
F00:0479       	call workhextobyte
               S01:000009FB:  CD 0B 0A
F00:0480       	ld b,a ;# save it later
               S01:000009FE:  47
F00:0481       	ld a,h ;# prepare the high nibble
               S01:000009FF:  7C
F00:0482       	call workhextobyte
               S01:00000A00:  CD 0B 0A
F00:0483       	rla ;# a contains the result from the high nibble
               S01:00000A03:  17
F00:0484       	rla ;# so move the nibble to make room for the low nibble
               S01:00000A04:  17
F00:0485       	rla
               S01:00000A05:  17
F00:0486       	rla
               S01:00000A06:  17
F00:0487       	or b ;# add the low nibble
               S01:00000A07:  B0
F00:0488       
F00:0489       	pop bc
               S01:00000A08:  C1
F00:0490       	pop hl
               S01:00000A09:  E1
F00:0491       	ret
               S01:00000A0A:  C9
F00:0492       workhextobyte:
F00:0493       	cp 'A' ;# alphabeta sub 55
               S01:00000A0B:  FE 41
F00:0494       	jp m,hextobytenumber
               S01:00000A0D:  FA 13 0A
F00:0495       	sub 55
               S01:00000A10:  D6 37
F00:0496       	ret
               S01:00000A12:  C9
F00:0497       hextobytenumber:
F00:0498       	sub 48 ;# if number sub 48
               S01:00000A13:  D6 30
F00:0499       	ret
               S01:00000A15:  C9
F00:0500       
F00:0501       	;# === directory open === #
F00:0502       
F00:0503       directoryopen:
F00:0504       	push af
               S01:00000A16:  F5
F00:0505       	ld a,OPENDIRECTORY
               S01:00000A17:  3E 31
F00:0506       	out (SDCARD),a
               S01:00000A19:  D3 05
F00:0507       	pop af
               S01:00000A1B:  F1
F00:0508       	ret
               S01:00000A1C:  C9
F00:0509       	;# === nextfile === #
F00:0510       nextfile:
F00:0511       	push af
               S01:00000A1D:  F5
F00:0512       	ld a,NEXTFILE
               S01:00000A1E:  3E 32
F00:0513       	out (SDCARD),a
               S01:00000A20:  D3 05
F00:0514       	pop af
               S01:00000A22:  F1
F00:0515       	ret
               S01:00000A23:  C9
F00:0516       	;# === getfilename or currently open file ===#
F00:0517       	;# ld hl,storagelocation - for the filename
F00:0518       	;# call getfilename
F00:0519       
F00:0520       getfilename:
F00:0521       	push af
               S01:00000A24:  F5
F00:0522       	push hl
               S01:00000A25:  E5
F00:0523       	ld a,GETNAME
               S01:00000A26:  3E 20
F00:0524       	out (SDCARD),a
               S01:00000A28:  D3 05
F00:0525       
F00:0526       _getfilename$1:
F00:0527       	ld a,NAMEAVAILABLE
               S01:00000A2A:  3E 21
F00:0528       	out (SDCARD),a
               S01:00000A2C:  D3 05
F00:0529       	in a,(SDCARD)
               S01:00000A2E:  DB 05
F00:0530       	cp 0
               S01:00000A30:  FE 00
F00:0531       	jp z, _exitgetfilename
               S01:00000A32:  CA 3A 0A
F00:0532       
F00:0533       	ld (hl),a
               S01:00000A35:  77
F00:0534       	inc hl
               S01:00000A36:  23
F00:0535       	
F00:0536       	jp _getfilename$1
               S01:00000A37:  C3 2A 0A
F00:0537       
F00:0538       _exitgetfilename:
F00:0539       	ld a,0
               S01:00000A3A:  3E 00
F00:0540       	ld (hl),a
               S01:00000A3C:  77
F00:0541       	pop hl
               S01:00000A3D:  E1
F00:0542       	pop af
               S01:00000A3E:  F1
F00:0543       	ret
               S01:00000A3F:  C9
F00:0544       
F00:0545       	# === createProcess == #
F00:0546       	;# stack - note the example below is using the registers as an example, it really don't matter
F00:0547       	;# which register pair put that data on the stack, the sequence in which the parameters are put on the stack
F00:0548       	;# does matter.
F00:0549       	;# push hl,program - zero terminated
F00:0550       	;# push de,commandline - zero terminated
F00:0551       	;# call createProcess
F00:0552       	;# that should do for now
F00:0553       	createProcess: ;# this is messy need to have another go at this
F00:0554       		ld a,0
               S01:00000A40:  3E 00
F00:0555       		call printhex
               S01:00000A42:  CD CA 08
F00:0556       
F00:0557       		pop hl ;# get the return address
               S01:00000A45:  E1
F00:0558       		exx ;# exchange with other registers
               S01:00000A46:  D9
F00:0559       
F00:0560       
F00:0561       		ld de,theparams
               S01:00000A47:  11 D0 0A
F00:0562       		;# copy the command params
F00:0563       		pop hl ;# get the command params
               S01:00000A4A:  E1
F00:0564       		ld a,1
               S01:00000A4B:  3E 01
F00:0565       		call printhex
               S01:00000A4D:  CD CA 08
F00:0566       
F00:0567       		call strcpy
               S01:00000A50:  CD 68 08
F00:0568       		ld a,2
               S01:00000A53:  3E 02
F00:0569       		call printhex
               S01:00000A55:  CD CA 08
F00:0570       		push hl
               S01:00000A58:  E5
F00:0571       		ld hl,thecommandlinemsg
               S01:00000A59:  21 C8 0A
F00:0572       		call println
               S01:00000A5C:  CD 93 08
F00:0573       		pop hl
               S01:00000A5F:  E1
F00:0574       		call println ;# print command params
               S01:00000A60:  CD 93 08
F00:0575       
F00:0576       		ld a,3
               S01:00000A63:  3E 03
F00:0577       		call printhex
               S01:00000A65:  CD CA 08
F00:0578       
F00:0579       		pop hl ;# get the program
               S01:00000A68:  E1
F00:0580       		push HL
               S01:00000A69:  E5
F00:0581       		ld hl,theprocessmsg
               S01:00000A6A:  21 BF 0A
F00:0582       		call println
               S01:00000A6D:  CD 93 08
F00:0583       		pop hl
               S01:00000A70:  E1
F00:0584       		call println ;# print program name
               S01:00000A71:  CD 93 08
F00:0585       #		ld de,userMemory
F00:0586       		ld a,0
               S01:00000A74:  3E 00
F00:0587       		ld d,a ;# use dynamic load address if possible
               S01:00000A76:  57
F00:0588       		ld e,a
               S01:00000A77:  5F
F00:0589       		ld a,4
               S01:00000A78:  3E 04
F00:0590       		call printhex
               S01:00000A7A:  CD CA 08
F00:0591       #pih 12/29/2020
F00:0592       		call copyprogramname
               S01:00000A7D:  CD B4 0A
F00:0593       		call loadFILE
               S01:00000A80:  CD E3 08
F00:0594       		cp 0
               S01:00000A83:  FE 00
F00:0595       		jp nz, _createProcesserr$1
               S01:00000A85:  C2 AF 0A
F00:0596       		ld (_progloadaddr),hl ;# save the address the program was loaded into. if null is means use the default userMemory
               S01:00000A88:  22 AD 0A
F00:0597       		
F00:0598       		exx ;# restore the other original registers
               S01:00000A8B:  D9
F00:0599       		push hl ; # restore the return address
               S01:00000A8C:  E5
F00:0600       		# test if we need to use the default address or the program/library supplied address
F00:0601       		# we can do that by checking if the hl pair is null, null = use fault, not null = custom address
F00:0602       		ld hl,(_progloadaddr)
               S01:00000A8D:  2A AD 0A
F00:0603       		ld a,h
               S01:00000A90:  7C
F00:0604       		cp 0
               S01:00000A91:  FE 00
F00:0605       		jp nz, _4$
               S01:00000A93:  C2 A2 0A
F00:0606       		ld a,l
               S01:00000A96:  7D
F00:0607       		cp 0
               S01:00000A97:  FE 00
F00:0608       		jp nz,_4$
               S01:00000A99:  C2 A2 0A
F00:0609       		# hl was null so call the default address
F00:0610       		#pih call printhexL
F00:0611       				### CREATENEWPROCESSINFO
F00:0612       		# just for the fun of it,lets write usermemory into progloadaddr and reuse the dynamic address code
F00:0613       		ld hl,userMemory
               S01:00000A9C:  21 00 30
F00:0614       		ld (_progloadaddr),hl
               S01:00000A9F:  22 AD 0A
F00:0615       		#pih call createnewprocessinfo
F00:0616       		#pih call userMemory
F00:0617       		
F00:0618       		# pih ret
F00:0619       _4$:
F00:0620       	call printhexL
               S01:00000AA2:  CD BD 08
F00:0621       		### CREATENEWPROCESSINFO
F00:0622       		call createnewprocessinfo
               S01:00000AA5:  CD 06 0B
F00:0623       	call progloadaddress
               S01:00000AA8:  CD AC 0A
F00:0624       	ret
               S01:00000AAB:  C9
F00:0625       progloadaddress: .byte 0xc3
               S01:00000AAC:  C3
F00:0626       	_progloadaddr: .2byte 0
               S01:00000AAD:  00 00
F00:0627       
F00:0628       
F00:0629       
F00:0630       _createProcesserr$1:
F00:0631       		push af
               S01:00000AAF:  F5
F00:0632       		exx ;# restore the other original registers
               S01:00000AB0:  D9
F00:0633       		pop af
               S01:00000AB1:  F1
F00:0634       		push hl ; # restore the return address
               S01:00000AB2:  E5
F00:0635       		ret
               S01:00000AB3:  C9
F00:0636       
F00:0637       # helper function to copy the program name into procname , which is used to update the processinfo
F00:0638       copyprogramname:
F00:0639       	push de
               S01:00000AB4:  D5
F00:0640       	push hl
               S01:00000AB5:  E5
F00:0641       	ld de,procname
               S01:00000AB6:  11 7E 0D
F00:0642       	call strcpy
               S01:00000AB9:  CD 68 08
F00:0643       	pop hl
               S01:00000ABC:  E1
F00:0644       	pop de
               S01:00000ABD:  D1
F00:0645       ret
               S01:00000ABE:  C9
F00:0646       
F00:0647       theprocessmsg: .string "process:"
               S01:00000ABF:  70 72 6F 63 65 73 73 3A
F00:0648       thecommandlinemsg: .string "params:"
               S01:00000AC8:  70 61 72 61 6D 73 3A
F00:0649       theparams: .space 50
F00:0650       
F00:0651       ;# === specialfunction this is called by the just lauched program, it allows the program to get it's processid
F00:0652       setprocid:
F00:0653       	ld a,(lastprogramid)
               S01:00000B02:  3A 88 0D
F00:0654       	ret
               S01:00000B05:  C9
F00:0655       
F00:0656       #== createnewprocessinfo ===#
F00:0657       # variable procname is expected to be populated
F00:0658       # variable _progloadaddr contains the program address
F00:0659       # return 
F00:0660       
F00:0661       #dbcreatenewprocessinfomsg: .string 
F00:0662       
F00:0663       createnewprocessinfo:
F00:0664       	DPRINTLN "createnewprocessinfo"
F07:0001       	push hl
               S01:00000B06:  E5
F07:0002       	jp 71$
               S01:00000B07:  C3 1F 0B
F07:0003       99$: .string "createnewprocessinfo"
               S01:00000B0A:  63 72 65 61 74 65 6E 65 77 70 72 6F 63 65 73 73
               S01:00000B1A:  69 6E 66 6F
F07:0004       71$:ld hl,99$
               S01:00000B1F:  21 0A 0B
F07:0005       	call println
               S01:00000B22:  CD 93 08
F07:0006       	pop hl
               S01:00000B25:  E1
F00:0665       	push af
               S01:00000B26:  F5
F00:0666       	push hl
               S01:00000B27:  E5
F00:0667       	push bc
               S01:00000B28:  C5
F00:0668       	push de  ;#just do everything for now - need to look and fix this
               S01:00000B29:  D5
F00:0669       	call getnewprocessid
               S01:00000B2A:  CD CB 0B
F00:0670       	call writeprocessinfo
               S01:00000B2D:  CD 22 0C
F00:0671       	pop de
               S01:00000B30:  D1
F00:0672       	pop bc
               S01:00000B31:  C1
F00:0673       	pop hl
               S01:00000B32:  E1
F00:0674       	pop af
               S01:00000B33:  F1
F00:0675       ret
               S01:00000B34:  C9
F00:0676       
F00:0677       
F00:0678       #== startprocessinfo ==#
F00:0679       # reset the process info list pointer
F00:0680       # no inputs, no outputs
F00:0681       #dbstartprocessinfomsg: .string
F00:0682       startprocessinfo: 
F00:0683       	DPRINTLN "startprocessinfo"
F08:0001       	push hl
               S01:00000B35:  E5
F08:0002       	jp 81$
               S01:00000B36:  C3 4A 0B
F08:0003       99$: .string "startprocessinfo"
               S01:00000B39:  73 74 61 72 74 70 72 6F 63 65 73 73 69 6E 66 6F
F08:0004       81$:ld hl,99$
               S01:00000B4A:  21 39 0B
F08:0005       	call println
               S01:00000B4D:  CD 93 08
F08:0006       	pop hl
               S01:00000B50:  E1
F00:0684       	push af
               S01:00000B51:  F5
F00:0685       	ld a,0
               S01:00000B52:  3E 00
F00:0686       	ld (currentprocessinfo),a
               S01:00000B54:  32 8A 0D
F00:0687       	pop af
               S01:00000B57:  F1
F00:0688       	ld hl,processtable
               S01:00000B58:  21 8B 0D
F00:0689       	ret
               S01:00000B5B:  C9
F00:0690       
F00:0691       #== nextprocessinfo ===#
F00:0692       # return in hl the next processinfo entry
F00:0693       # also updates currentprocessinfo
F00:0694       # if carry flag set, we have reach the end of the process table
F00:0695       nextprocessinfo:
F00:0696       	DPRINTLN "nextprocessinfo"
F09:0001       	push hl
               S01:00000B5C:  E5
F09:0002       	jp 91$
               S01:00000B5D:  C3 70 0B
F09:0003       99$: .string "nextprocessinfo"
               S01:00000B60:  6E 65 78 74 70 72 6F 63 65 73 73 69 6E 66 6F
F09:0004       91$:ld hl,99$
               S01:00000B70:  21 60 0B
F09:0005       	call println
               S01:00000B73:  CD 93 08
F09:0006       	pop hl
               S01:00000B76:  E1
F00:0697       	push af
               S01:00000B77:  F5
F00:0698       	ld a,(currentprocessinfo)
               S01:00000B78:  3A 8A 0D
F00:0699       	ld h,a
               S01:00000B7B:  67
F00:0700       	ld e,PROCINFOSIZE
               S01:00000B7C:  1E 08
F00:0701       	call Mul8b
               S01:00000B7E:  CD 2E 0E
F00:0702       	ex de,hl
               S01:00000B81:  EB
F00:0703       	ld hl,processtable
               S01:00000B82:  21 8B 0D
F00:0704       	add hl,DE
               S01:00000B85:  19
F00:0705       	inc a
               S01:00000B86:  3C
F00:0706       	cp MAXPROCESSES
               S01:00000B87:  FE 04
F00:0707       	jp p, 1$ ;# if we go passed the limit reset back to 0
               S01:00000B89:  F2 93 0B
F00:0708       	ld (currentprocessinfo),a
               S01:00000B8C:  32 8A 0D
F00:0709       	pop af
               S01:00000B8F:  F1
F00:0710       	scf ;# set cf
               S01:00000B90:  37
F00:0711       	ccf ;# invert cf  - more process info's available so return with carry flag not set
               S01:00000B91:  3F
F00:0712       	ret
               S01:00000B92:  C9
F00:0713       1$: ;# if reach maxprocesses, return 0 in a & hl
F00:0714       	ld a,0
               S01:00000B93:  3E 00
F00:0715       	ld (currentprocessinfo),a
               S01:00000B95:  32 8A 0D
F00:0716       	ld h,a
               S01:00000B98:  67
F00:0717       	ld l,a
               S01:00000B99:  6F
F00:0718       	pop af
               S01:00000B9A:  F1
F00:0719       	scf ;# set carry flag  - if no more process return with carry flag set
               S01:00000B9B:  37
F00:0720       	ret
               S01:00000B9C:  C9
F00:0721       
F00:0722       #=== getprocessslot ===#
F00:0723       ;# return the first available slot in hl
F00:0724       ;# a slot is occuppied if the processid is not zero. this routine will locate the first unoccuppied slot
F00:0725       ;# A register returns status where 0=no slots , 1=slot available
F00:0726       ;# if carry flag set, a slot was found
F00:0727       ;# if carry flag not set, it did not find an empty slot
F00:0728       getprocessslot:
F00:0729       	DPRINTLN "getprocessslot"
F10:0001       	push hl
               S01:00000B9D:  E5
F10:0002       	jp 101$
               S01:00000B9E:  C3 B0 0B
F10:0003       99$: .string "getprocessslot"
               S01:00000BA1:  67 65 74 70 72 6F 63 65 73 73 73 6C 6F 74
F10:0004       101$:ld hl,99$
               S01:00000BB0:  21 A1 0B
F10:0005       	call println
               S01:00000BB3:  CD 93 08
F10:0006       	pop hl
               S01:00000BB6:  E1
F00:0730       	call startprocessinfo
               S01:00000BB7:  CD 35 0B
F00:0731       2$:
F00:0732       #	DEBUG '*'
F00:0733       #	PRINTLN
F00:0734       	call nextprocessinfo ;
               S01:00000BBA:  CD 5C 0B
F00:0735       	jp c,1$ ;# if carry flag set, we reached the end
               S01:00000BBD:  DA C8 0B
F00:0736       	ld a,(hl)
               S01:00000BC0:  7E
F00:0737       #	call printhex
F00:0738       #	call printhexL
F00:0739       	cp 0 ;# compare processids
               S01:00000BC1:  FE 00
F00:0740       	jp nz, 2$   ;# we are looking for a zero processid, which means it's an empty slot
               S01:00000BC3:  C2 BA 0B
F00:0741       	#ld hl,didfind
F00:0742       	#call println
F00:0743       #	ld a,1
F00:0744       	scf ;#did find return set carry flag
               S01:00000BC6:  37
F00:0745       	ret ;# found
               S01:00000BC7:  C9
F00:0746       
F00:0747       1$: ;# not found
F00:0748       	#ld hl,notfound
F00:0749       	#call println
F00:0750       #	ld a,0
F00:0751       	scf ;# did not find return unset carry flag
               S01:00000BC8:  37
F00:0752       	ccf
               S01:00000BC9:  3F
F00:0753       ret
               S01:00000BCA:  C9
F00:0754       
F00:0755       ;#=== getnewprocessid ===#
F00:0756       ;# return set the next available processsid in lastprogramid variable
F00:0757       ;# this processid is unique, it cannot be 0
F00:0758       
F00:0759       getnewprocessid:
F00:0760       	DPRINTLN "getnewprocessid"
F11:0001       	push hl
               S01:00000BCB:  E5
F11:0002       	jp 111$
               S01:00000BCC:  C3 DF 0B
F11:0003       99$: .string "getnewprocessid"
               S01:00000BCF:  67 65 74 6E 65 77 70 72 6F 63 65 73 73 69 64
F11:0004       111$:ld hl,99$
               S01:00000BDF:  21 CF 0B
F11:0005       	call println
               S01:00000BE2:  CD 93 08
F11:0006       	pop hl
               S01:00000BE5:  E1
F00:0761       	push af
               S01:00000BE6:  F5
F00:0762       	push hl
               S01:00000BE7:  E5
F00:0763       	push bc
               S01:00000BE8:  C5
F00:0764       
F00:0765       1$: ;#; increment the number thats already there (lastprogramid),  repeat if zero
F00:0766       	DEBUG '!'
F12:0001       # example : DEBUG '!'
F12:0002       #      or : DEBUG h
F12:0003       		push af
               S01:00000BE9:  F5
F12:0004       		ld a,33
               S01:00000BEA:  3E 21
F12:0005       		call putc
               S01:00000BEC:  CD E0 08
F12:0006       		pop af
               S01:00000BEF:  F1
F00:0767       	ld hl,lastprogramid
               S01:00000BF0:  21 88 0D
F00:0768       	inc (hl)
               S01:00000BF3:  34
F00:0769       	ld a,(lastprogramid) ;
               S01:00000BF4:  3A 88 0D
F00:0770       	ld c,0
               S01:00000BF7:  0E 00
F00:0771       	cp c
               S01:00000BF9:  B9
F00:0772       	jp z,1$:
               S01:00000BFA:  CA E9 0B
F00:0773       	ld c,a ;# move new id into c register,# keep if in C register we will use it later
               S01:00000BFD:  4F
F00:0774       	call startprocessinfo
               S01:00000BFE:  CD 35 0B
F00:0775       2$: DEBUG '@'
F13:0001       # example : DEBUG '!'
F13:0002       #      or : DEBUG h
F13:0003       		push af
               S01:00000C01:  F5
F13:0004       		ld a,64
               S01:00000C02:  3E 40
F13:0005       		call putc
               S01:00000C04:  CD E0 08
F13:0006       		pop af
               S01:00000C07:  F1
F00:0776       	call nextprocessinfo
               S01:00000C08:  CD 5C 0B
F00:0777       	jp c,3$ ;# if carry flag set, we reach the end
               S01:00000C0B:  DA 17 0C
F00:0778       	inc hl ;# advance to the process id
               S01:00000C0E:  23
F00:0779       	ld a,(hl)
               S01:00000C0F:  7E
F00:0780       	cp c
               S01:00000C10:  B9
F00:0781       	jp nz,2$ ;# repeat after incrementing the number again
               S01:00000C11:  C2 01 0C
F00:0782       	jp 1$ ;# get the next processinfo item
               S01:00000C14:  C3 E9 0B
F00:0783       3$:
F00:0784       	DEBUG '#'
F14:0001       # example : DEBUG '!'
F14:0002       #      or : DEBUG h
F14:0003       		push af
               S01:00000C17:  F5
F14:0004       		ld a,35
               S01:00000C18:  3E 23
F14:0005       		call putc
               S01:00000C1A:  CD E0 08
F14:0006       		pop af
               S01:00000C1D:  F1
F00:0785       	pop bc
               S01:00000C1E:  C1
F00:0786       	pop hl
               S01:00000C1F:  E1
F00:0787       	pop af
               S01:00000C20:  F1
F00:0788       ret
               S01:00000C21:  C9
F00:0789       
F00:0790       writeprocessinfo:
F00:0791       	DPRINTLN "writeprocessinfo"
F15:0001       	push hl
               S01:00000C22:  E5
F15:0002       	jp 151$
               S01:00000C23:  C3 37 0C
F15:0003       99$: .string "writeprocessinfo"
               S01:00000C26:  77 72 69 74 65 70 72 6F 63 65 73 73 69 6E 66 6F
F15:0004       151$:ld hl,99$
               S01:00000C37:  21 26 0C
F15:0005       	call println
               S01:00000C3A:  CD 93 08
F15:0006       	pop hl
               S01:00000C3D:  E1
F00:0792       # prerequisties : lastprogramid has the programid set 
F00:0793       #               variable   procname: contains the name of the program 
F00:0794       	call getprocessslot
               S01:00000C3E:  CD 9D 0B
F00:0795       	jp nc, failed
               S01:00000C41:  D2 69 0C
F00:0796       #call printhexL
F00:0797       #PRINTLN
F00:0798       	ld a,'R' ;# process is running
               S01:00000C44:  3E 52
F00:0799       	ld (hl),a ;# byte position 1
               S01:00000C46:  77
F00:0800       	inc hl
               S01:00000C47:  23
F00:0801       	ld a,(lastprogramid) ;# it is required this variable is set to the correct id before running this routine
               S01:00000C48:  3A 88 0D
F00:0802       	ld (hl),a ;# byte position 2
               S01:00000C4B:  77
F00:0803       	inc hl
               S01:00000C4C:  23
F00:0804       #call printhexL
F00:0805       #PRINTLN
F00:0806       	push hl ;# save it
               S01:00000C4D:  E5
F00:0807       	ld de,procname
               S01:00000C4E:  11 7E 0D
F00:0808       	ex de,hl
               S01:00000C51:  EB
F00:0809       #call printhexL
F00:0810       #call println
F00:0811       	ld c,4    ;# byte positions 3 , 4 , 5 ,6
               S01:00000C52:  0E 04
F00:0812       	ld b,0
               S01:00000C54:  06 00
F00:0813       	call strncpy ;# problem needs addressing: if the program name is < 4 bytes the copy will more than needed.
               S01:00000C56:  CD 65 08
F00:0814       					;# we need a strncpy that stops on a null byte
F00:0815       	
F00:0816       	pop hl
               S01:00000C59:  E1
F00:0817       	inc hl
               S01:00000C5A:  23
F00:0818       	inc hl
               S01:00000C5B:  23
F00:0819       	inc hl
               S01:00000C5C:  23
F00:0820       	inc hl ;# advance hl to account for the 4 bytes to copy the process name
               S01:00000C5D:  23
F00:0821       	ld de,(_progloadaddr)
               S01:00000C5E:  ED 5B AD 0A
F00:0822       	ld (hl),d   ;# byte position 7
               S01:00000C62:  72
F00:0823       	inc hl
               S01:00000C63:  23
F00:0824       	ld (hl),e   ;# byte position 8
               S01:00000C64:  73
F00:0825       	inc hl ;# ready for the next byte position
               S01:00000C65:  23
F00:0826       	ld a, 0
               S01:00000C66:  3E 00
F00:0827       	ret
               S01:00000C68:  C9
F00:0828       
F00:0829       failed:
F00:0830       	ld hl,errormsg
               S01:00000C69:  21 72 0C
F00:0831       	call println
               S01:00000C6C:  CD 93 08
F00:0832       	ld a,0
               S01:00000C6F:  3E 00
F00:0833       	ret 
               S01:00000C71:  C9
F00:0834       
F00:0835       errormsg: .string "could not find an empty slot, maximum number of processes running\r\n"
               S01:00000C72:  63 6F 75 6C 64 20 6E 6F 74 20 66 69 6E 64 20 61
               S01:00000C82:  6E 20 65 6D 70 74 79 20 73 6C 6F 74 2C 20 6D 61
F00:0836       
F00:0837       #==== getprocessbyid ==#
F00:0838       # ld a,id
F00:0839       # call getprocessbyid
F00:0840       # cp 1             - returns in A : 0 = not found, 1 = found
F00:0841       # jp z,we succeeded
F00:0842       getprocessbyid:
F00:0843       	DPRINTLN "getprocessbyid"
F16:0001       	push hl
               S01:00000CB6:  E5
F16:0002       	jp 161$
               S01:00000CB7:  C3 C9 0C
F16:0003       99$: .string "getprocessbyid"
               S01:00000CBA:  67 65 74 70 72 6F 63 65 73 73 62 79 69 64
F16:0004       161$:ld hl,99$
               S01:00000CC9:  21 BA 0C
F16:0005       	call println
               S01:00000CCC:  CD 93 08
F16:0006       	pop hl
               S01:00000CCF:  E1
F00:0844       	call startprocessinfo
               S01:00000CD0:  CD 35 0B
F00:0845       	push hl
               S01:00000CD3:  E5
F00:0846       	pop ix
               S01:00000CD4:  DD E1
F00:0847       	ld b,(ix+1)
               S01:00000CD6:  DD 46 01
F00:0848       	cp b ;# compare processids
               S01:00000CD9:  B8
F00:0849           jp nz,2$
               S01:00000CDA:  C2 E0 0C
F00:0850       	ld a,1
               S01:00000CDD:  3E 01
F00:0851       	ret ;# found
               S01:00000CDF:  C9
F00:0852       
F00:0853       2$:
F00:0854       
F00:0855       	call nextprocessinfo ;
               S01:00000CE0:  CD 5C 0B
F00:0856       	jp c,1$ ;# if carry flag set, we reached the end
               S01:00000CE3:  DA F3 0C
F00:0857       	push hl
               S01:00000CE6:  E5
F00:0858       	pop ix
               S01:00000CE7:  DD E1
F00:0859       	ld b,(ix+1)
               S01:00000CE9:  DD 46 01
F00:0860       	cp b ;# compare processids
               S01:00000CEC:  B8
F00:0861       	jp nz, 2$
               S01:00000CED:  C2 E0 0C
F00:0862       	ld a,1
               S01:00000CF0:  3E 01
F00:0863       	ret ;# found
               S01:00000CF2:  C9
F00:0864       
F00:0865       1$: ;# not found
F00:0866       	ld a,0
               S01:00000CF3:  3E 00
F00:0867       ret
               S01:00000CF5:  C9
F00:0868       
F00:0869       ;# A = processid to delete
F00:0870       deleteprocessbyid:
F00:0871       	DPRINTLN "deleteprocessbyid"
F17:0001       	push hl
               S01:00000CF6:  E5
F17:0002       	jp 171$
               S01:00000CF7:  C3 0C 0D
F17:0003       99$: .string "deleteprocessbyid"
               S01:00000CFA:  64 65 6C 65 74 65 70 72 6F 63 65 73 73 62 79 69
               S01:00000D0A:  64
F17:0004       171$:ld hl,99$
               S01:00000D0C:  21 FA 0C
F17:0005       	call println
               S01:00000D0F:  CD 93 08
F17:0006       	pop hl
               S01:00000D12:  E1
F00:0872       push af
               S01:00000D13:  F5
F00:0873       	call getprocessbyid
               S01:00000D14:  CD B6 0C
F00:0874       	cp 1 ;# 1 = we found the process
               S01:00000D17:  FE 01
F00:0875       	jp nz,1$
               S01:00000D19:  C2 24 0D
F00:0876       	ld b,PROCINFOSIZE
               S01:00000D1C:  06 08
F00:0877       	ld a,0
               S01:00000D1E:  3E 00
F00:0878       0$: ld (hl),a
               S01:00000D20:  77
F00:0879       	inc hl
               S01:00000D21:  23
F00:0880       	djnz 0$
               S01:00000D22:  10 FC
F00:0881       
F00:0882       1$:
F00:0883       pop af
               S01:00000D24:  F1
F00:0884       ret 
               S01:00000D25:  C9
F00:0885       
F00:0886 E1011 /* you are testing the writezombieprocess as it appears to not be working. you made a change
F00:0887       and want to test it when the computer failed on you.*/
               S01:00000D26:  E6 00 [R]
F00:0888       
F00:0889       ;# == writezombieprocess ==#
F00:0890       #ld a,processid
F00:0891       
F00:0892       writezombieprocess:
F00:0893       	DPRINTLN "writezombieprocess"
F18:0001       	push hl
               S01:00000D28:  E5
F18:0002       	jp 181$
               S01:00000D29:  C3 3F 0D
F18:0003       99$: .string "writezombieprocess"
               S01:00000D2C:  77 72 69 74 65 7A 6F 6D 62 69 65 70 72 6F 63 65
               S01:00000D3C:  73 73
F18:0004       181$:ld hl,99$
               S01:00000D3F:  21 2C 0D
F18:0005       	call println
               S01:00000D42:  CD 93 08
F18:0006       	pop hl
               S01:00000D45:  E1
F00:0894       push af
               S01:00000D46:  F5
F00:0895       	call getprocessbyid
               S01:00000D47:  CD B6 0C
F00:0896       	cp 1 ;# 1 = we found the process
               S01:00000D4A:  FE 01
F00:0897       	jp nz,1$
               S01:00000D4C:  C2 5C 0D
F00:0898       	push HL
               S01:00000D4F:  E5
F00:0899       	pop ix
               S01:00000D50:  DD E1
F00:0900       	ld a,'Z' ;# zombie
               S01:00000D52:  3E 5A
F00:0901       	ld (ix+0),a
               S01:00000D54:  DD 77 00
F00:0902       	pop af
               S01:00000D57:  F1
F00:0903       	ld (ix+6),a
               S01:00000D58:  DD 77 06
F00:0904       	ret
               S01:00000D5B:  C9
F00:0905       1$:
F00:0906       	pop af
               S01:00000D5C:  F1
F00:0907       	ret
               S01:00000D5D:  C9
F00:0908       
F00:0909       
F00:0910       # === exit process ====#
F00:0911       # call getprocid
F00:0912       # call exit
F00:0913       # --
F00:0914       # ld b,processsid
F00:0915       # ld a,exitcode
F00:0916       # call exitprocess
F00:0917       # 
F00:0918       exitprocess:
F00:0919       	DPRINTLN "exitprocess"
F19:0001       	push hl
               S01:00000D5E:  E5
F19:0002       	jp 191$
               S01:00000D5F:  C3 6E 0D
F19:0003       99$: .string "exitprocess"
               S01:00000D62:  65 78 69 74 70 72 6F 63 65 73 73
F19:0004       191$:ld hl,99$
               S01:00000D6E:  21 62 0D
F19:0005       	call println
               S01:00000D71:  CD 93 08
F19:0006       	pop hl
               S01:00000D74:  E1
F00:0920       	push af
               S01:00000D75:  F5
F00:0921       	push bc
               S01:00000D76:  C5
F00:0922       #DEBUG '%'
F00:0923       #	call printhex ;# print exit code for now
F00:0924       	
F00:0925       	ld a,b ;# get the processid and delete it - this is not a good long term solution
               S01:00000D77:  78
F00:0926       #	call printhex
F00:0927       			;# long term we need to mark the process as a zombie for some period of time,
F00:0928       			;# this will allow the exit code to be retreived by other process. need to think about this
F00:0929       	#call deleteprocessbyid
F00:0930       	call writezombieprocess
               S01:00000D78:  CD 28 0D
F00:0931       	pop bc
               S01:00000D7B:  C1
F00:0932       	pop af
               S01:00000D7C:  F1
F00:0933       ret
               S01:00000D7D:  C9
F00:0934       
F00:0935       procname: .space 10 ;# space for the processname, but we really only need 4 or 4+1
F00:0936       lastprogramid: .byte 0
               S01:00000D88:  00
F00:0937       maxprocesses: .byte MAXPROCESSES
               S01:00000D89:  04
F00:0938       currentprocessinfo: .byte 0; # index to a process table entry
               S01:00000D8A:  00
F00:0939       processtable: 
F00:0940       	;# position 0 :  1byte process status - R=running, Z=zombie, 0=no process
F00:0941       	;#			1 : 1byte processID
F00:0942       	;#			2 : 4bytes process name
F00:0943       	;#			6 : 1byte exitcode
F00:0944       	;#			7 : 1byte spare
F00:0945       .rept MAXPROCESSES
F00:0947       
F20:0001       	.space PROCINFOSIZE
F20:0001       	.space PROCINFOSIZE
F20:0001       	.space PROCINFOSIZE
F20:0001       	.space PROCINFOSIZE
F00:0948       endprocesstable: ;# this does nothing and can be deleted. I'm using it to check the listing address
F00:0949       
F00:0950       	# === getcommandparams == #
F00:0951       	;# ld hl,buffer - address of where to copy the data
F00:0952       	;# call getcommandparams
F00:0953       	;# returns zero termined string at buffer 
F00:0954       getcommandparams:
F00:0955       	push de
               S01:00000DAB:  D5
F00:0956       	push hl
               S01:00000DAC:  E5
F00:0957       	push hl ;# save hl to move into de
               S01:00000DAD:  E5
F00:0958       	pop de ;# load hl into de
               S01:00000DAE:  D1
F00:0959       #	ld hl,userMemory-50   ;# ********* I dont remember why I did this, it needs investigating
F00:0960       	ld hl,theparams
               S01:00000DAF:  21 D0 0A
F00:0961       	call strcpy
               S01:00000DB2:  CD 68 08
F00:0962       	pop hl
               S01:00000DB5:  E1
F00:0963       	pop de
               S01:00000DB6:  D1
F00:0964       	ret
               S01:00000DB7:  C9
F00:0965       
F00:0966       ;# ================ getmalloctable ======#
F00:0967       	getmalloctable:
F00:0968       		ld hl,malloctable
               S01:00000DB8:  21 00 10
F00:0969       		ret
               S01:00000DBB:  C9
F00:0970       
F00:0971       ;# ====== reserve memory alloc table entry ===#
F00:0972       
F00:0973       	reservemalloc:
F00:0974       		push bc
               S01:00000DBC:  C5
F00:0975       		push af
               S01:00000DBD:  F5
F00:0976       		ld b,1
               S01:00000DBE:  06 01
F00:0977       		call setresetpage
               S01:00000DC0:  CD C6 0D
F00:0978       		pop af
               S01:00000DC3:  F1
F00:0979       		pop bc
               S01:00000DC4:  C1
F00:0980       	ret
               S01:00000DC5:  C9
F00:0981       ;# ======= setresetpage - memory alloc table management ===#
F00:0982       setresetpage:
F00:0983       ;# ld a, page
F00:0984       ;# ld b, setorreset , 0 = reset, 1 = set
F00:0985       		push hl
               S01:00000DC6:  E5
F00:0986       		push bc
               S01:00000DC7:  C5
F00:0987       		push af
               S01:00000DC8:  F5
F00:0988       	
F00:0989       		
F00:0990       		DEBUG '@'
F21:0001       # example : DEBUG '!'
F21:0002       #      or : DEBUG h
F21:0003       		push af
               S01:00000DC9:  F5
F21:0004       		ld a,64
               S01:00000DCA:  3E 40
F21:0005       		call putc
               S01:00000DCC:  CD E0 08
F21:0006       		pop af
               S01:00000DCF:  F1
F00:0991       
F00:0992       		call getmallocrelativebase
               S01:00000DD0:  CD 00 0E
F00:0993       
F00:0994       		DEBUG '%'
F22:0001       # example : DEBUG '!'
F22:0002       #      or : DEBUG h
F22:0003       		push af
               S01:00000DD3:  F5
F22:0004       		ld a,37
               S01:00000DD4:  3E 25
F22:0005       		call putc
               S01:00000DD6:  CD E0 08
F22:0006       		pop af
               S01:00000DD9:  F1
F00:0995       		pop af
               S01:00000DDA:  F1
F00:0996       		and 0x0f
               S01:00000DDB:  E6 0F
F00:0997       		cp 8
               S01:00000DDD:  FE 08
F00:0998       		jp m,1$
               S01:00000DDF:  FA E5 0D
F00:0999       		inc hl
               S01:00000DE2:  23
F00:1000       		sub 8
               S01:00000DE3:  D6 08
F00:1001       1$:
F00:1002       	
F00:1003       		ld b,a
               S01:00000DE5:  47
F00:1004       		inc b
               S01:00000DE6:  04
F00:1005       		scf
               S01:00000DE7:  37
F00:1006       		ld a,0
               S01:00000DE8:  3E 00
F00:1007       
F00:1008       2$:		rra 	
               S01:00000DEA:  1F
F00:1009       		djnz 2$
               S01:00000DEB:  10 FD
F00:1010       		pop bc
               S01:00000DED:  C1
F00:1011       
F00:1012       		push af
               S01:00000DEE:  F5
F00:1013       		ld a,b
               S01:00000DEF:  78
F00:1014       		cp 0
               S01:00000DF0:  FE 00
F00:1015       		jp z,6$
               S01:00000DF2:  CA FA 0D
F00:1016       ;# set
F00:1017       		pop af
               S01:00000DF5:  F1
F00:1018       		or (hl)
               S01:00000DF6:  B6
F00:1019       		jp 4$
               S01:00000DF7:  C3 FD 0D
F00:1020       
F00:1021       ;# reset
F00:1022       6$:		pop af
               S01:00000DFA:  F1
F00:1023       		cpl
               S01:00000DFB:  2F
F00:1024       		and (hl)
               S01:00000DFC:  A6
F00:1025       
F00:1026       4$:
F00:1027       		ld (hl),a
               S01:00000DFD:  77
F00:1028       		pop hl
               S01:00000DFE:  E1
F00:1029       		ret
               S01:00000DFF:  C9
F00:1030       
F00:1031       getmallocrelativebase:
F00:1032       ;# ld a,page
F00:1033       ;# call getmallocrelativebase
F00:1034       ;# return in hl = malloctable address adjusted for page
F00:1035       	push de
               S01:00000E00:  D5
F00:1036       		and 0xf0
               S01:00000E01:  E6 F0
F00:1037       
F00:1038       		ld l,a
               S01:00000E03:  6F
F00:1039       		ld h,0
               S01:00000E04:  26 00
F00:1040       		ld d,8
               S01:00000E06:  16 08
F00:1041       		call Div8
               S01:00000E08:  CD 20 0E
F00:1042       
F00:1043       		ex de,hl
               S01:00000E0B:  EB
F00:1044       		#.byte 0xeb
F00:1045       
F00:1046       		DEBUG '!'
F23:0001       # example : DEBUG '!'
F23:0002       #      or : DEBUG h
F23:0003       		push af
               S01:00000E0C:  F5
F23:0004       		ld a,33
               S01:00000E0D:  3E 21
F23:0005       		call putc
               S01:00000E0F:  CD E0 08
F23:0006       		pop af
               S01:00000E12:  F1
F00:1047       
F00:1048       		call getmalloctable
               S01:00000E13:  CD B8 0D
F00:1049       		DEBUG '^'
F24:0001       # example : DEBUG '!'
F24:0002       #      or : DEBUG h
F24:0003       		push af
               S01:00000E16:  F5
F24:0004       		ld a,94
               S01:00000E17:  3E 5E
F24:0005       		call putc
               S01:00000E19:  CD E0 08
F24:0006       		pop af
               S01:00000E1C:  F1
F00:1050       		add hl,de
               S01:00000E1D:  19
F00:1051       		pop de
               S01:00000E1E:  D1
F00:1052       		ret
               S01:00000E1F:  C9
F00:1053       
F00:1054       
F00:1055       
F00:1056       ;# ========== Div8 8bit division =======#
F00:1057       ;# http://tutorials.eeems.ca/Z80ASM/part4.htm#div8
F00:1058       ;# result stored in HL
F00:1059       ;# ld hl,4
F00:1060       ;# ld d,2
F00:1061       ;# call Div8
F00:1062       Div8:                            ; this routine performs the operation HL=HL/D
F00:1063         xor a                          ; clearing the upper 8 bits of AHL
               S01:00000E20:  AF
F00:1064         ld b,16                        ; the length of the dividend (16 bits)
               S01:00000E21:  06 10
F00:1065       Div8Loop:
F00:1066         add hl,hl                      ; advancing a bit
               S01:00000E23:  29
F00:1067         rla
               S01:00000E24:  17
F00:1068         cp d                           ; checking if the divisor divides the digits chosen (in A)
               S01:00000E25:  BA
F00:1069         jp c,Div8NextBit               ; if not, advancing without subtraction
               S01:00000E26:  DA 2B 0E
F00:1070         sub d                          ; subtracting the divisor
               S01:00000E29:  92
F00:1071         inc l                          ; and setting the next digit of the quotient
               S01:00000E2A:  2C
F00:1072       Div8NextBit:
F00:1073         djnz Div8Loop
               S01:00000E2B:  10 F6
F00:1074         ret
               S01:00000E2D:  C9
F00:1075       
F00:1076         # ===== Mul8b 8bit multily ===#
F00:1077         # http://tutorials.eeems.ca/Z80ASM/part4.htm
F00:1078         Mul8b:                           ; this routine performs the operation HL=H*E
F00:1079         ld d,0                         ; clearing D and L
               S01:00000E2E:  16 00
F00:1080         ld l,d
               S01:00000E30:  6A
F00:1081         ld b,8                         ; we have 8 bits
               S01:00000E31:  06 08
F00:1082       Mul8bLoop:
F00:1083         add hl,hl                      ; advancing a bit
               S01:00000E33:  29
F00:1084         jp nc,Mul8bSkip                ; if zero, we skip the addition (jp is used for speed)
               S01:00000E34:  D2 38 0E
F00:1085         add hl,de                      ; adding to the product if necessary
               S01:00000E37:  19
F00:1086       Mul8bSkip:
F00:1087         djnz Mul8bLoop
               S01:00000E38:  10 F9
F00:1088         ret
               S01:00000E3A:  C9
F00:1089       
F00:1090       ;================================
F00:1091       ; # === loadaddress == #   THIS NEEDS CHANGING INTO A LOOKUP TABLE - not code
F00:1092       ; ld a,x - where x = instruction id
F00:1093       ;				id = 1, print
F00:1094       ;					 2, printhex
F00:1095       ;					3,loadFILE
F00:1096       loadaddress:
F00:1097       	cp PRINT
               S01:00000E3B:  FE 01
F00:1098       	jp nz,_loadaddress$2
               S01:00000E3D:  C2 44 0E
F00:1099       	ld hl,print
               S01:00000E40:  21 A1 08
F00:1100       	ret
               S01:00000E43:  C9
F00:1101       _loadaddress$2:
F00:1102       	cp PRINTHEX
               S01:00000E44:  FE 02
F00:1103       	jp nz,_loadaddress$3
               S01:00000E46:  C2 4D 0E
F00:1104       	ld hl,printhex
               S01:00000E49:  21 CA 08
F00:1105       	ret
               S01:00000E4C:  C9
F00:1106       _loadaddress$3:
F00:1107       	cp LOADFILE
               S01:00000E4D:  FE 03
F00:1108       	jp nz,_loadaddress$4
               S01:00000E4F:  C2 56 0E
F00:1109       	ld hl,loadFILE
               S01:00000E52:  21 E3 08
F00:1110       	ret
               S01:00000E55:  C9
F00:1111       _loadaddress$4:
F00:1112       	cp MEMSET
               S01:00000E56:  FE 04
F00:1113       	jp nz,_loadaddress$5
               S01:00000E58:  C2 5F 0E
F00:1114       	ld hl,memset
               S01:00000E5B:  21 4A 08
F00:1115       	ret
               S01:00000E5E:  C9
F00:1116       _loadaddress$5:
F00:1117       	cp STRLEN
               S01:00000E5F:  FE 05
F00:1118       	jp nz,_loadaddress$6
               S01:00000E61:  C2 68 0E
F00:1119       	ld hl,strlen
               S01:00000E64:  21 53 08
F00:1120       	ret
               S01:00000E67:  C9
F00:1121       _loadaddress$6:
F00:1122       	cp PUTC
               S01:00000E68:  FE 06
F00:1123       	jp nz,_loadaddress$7
               S01:00000E6A:  C2 71 0E
F00:1124       	ld hl,putc
               S01:00000E6D:  21 E0 08
F00:1125       	ret
               S01:00000E70:  C9
F00:1126       _loadaddress$7:
F00:1127       	cp TOUPPERCASE
               S01:00000E71:  FE 07
F00:1128       	jp nz,_loadaddress$8
               S01:00000E73:  C2 7A 0E
F00:1129       	ld hl,touppercase
               S01:00000E76:  21 7B 08
F00:1130       	ret
               S01:00000E79:  C9
F00:1131       _loadaddress$8:
F00:1132       	cp HEXTOBYTE
               S01:00000E7A:  FE 08
F00:1133       	jp nz,_loadaddress$9
               S01:00000E7C:  C2 83 0E
F00:1134       	ld hl,hextobyte
               S01:00000E7F:  21 F8 09
F00:1135       	ret
               S01:00000E82:  C9
F00:1136       _loadaddress$9:
F00:1137       	cp PRINTLN
               S01:00000E83:  FE 09
F00:1138       	jp nz,_loadaddress$10
               S01:00000E85:  C2 8C 0E
F00:1139       	ld hl,println
               S01:00000E88:  21 93 08
F00:1140       	ret
               S01:00000E8B:  C9
F00:1141       _loadaddress$10:
F00:1142       	cp STRNCPY
               S01:00000E8C:  FE 0A
F00:1143       	jp nz,_loadaddress$11
               S01:00000E8E:  C2 95 0E
F00:1144       	ld hl,strncpy
               S01:00000E91:  21 65 08
F00:1145       	ret
               S01:00000E94:  C9
F00:1146       _loadaddress$11:
F00:1147       	cp DIRECTORYOPEN
               S01:00000E95:  FE 0D
F00:1148       	jp nz,_loadaddress$12
               S01:00000E97:  C2 9E 0E
F00:1149       	ld hl,directoryopen
               S01:00000E9A:  21 16 0A
F00:1150       	ret
               S01:00000E9D:  C9
F00:1151       _loadaddress$12:
F00:1152       	cp GETFILENAME:
               S01:00000E9E:  FE 0F
F00:1153       	jp nz,_loadaddress$13
               S01:00000EA0:  C2 A7 0E
F00:1154       	ld hl,getfilename
               S01:00000EA3:  21 24 0A
F00:1155       	ret
               S01:00000EA6:  C9
F00:1156       _loadaddress$13:
F00:1157       	cp NEXTFILE
               S01:00000EA7:  FE 32
F00:1158       	jp nz,_loadaddress$14
               S01:00000EA9:  C2 B0 0E
F00:1159       	ld hl,nextfile
               S01:00000EAC:  21 1D 0A
F00:1160       	ret
               S01:00000EAF:  C9
F00:1161       _loadaddress$14:
F00:1162       	cp CREATEPROCESS
               S01:00000EB0:  FE 10
F00:1163       	jp nz,_loadaddress$15
               S01:00000EB2:  C2 B9 0E
F00:1164       	ld hl,createProcess
               S01:00000EB5:  21 40 0A
F00:1165       	ret
               S01:00000EB8:  C9
F00:1166       _loadaddress$15:
F00:1167       	cp GETCOMMANDPARAMS
               S01:00000EB9:  FE 11
F00:1168       	jp nz,_loadaddress$16
               S01:00000EBB:  C2 C2 0E
F00:1169       	ld hl,getcommandparams
               S01:00000EBE:  21 AB 0D
F00:1170       	ret
               S01:00000EC1:  C9
F00:1171       _loadaddress$16:
F00:1172       	cp GETMALLOCTABLE
               S01:00000EC2:  FE 12
F00:1173       	jp nz,_loadaddress$17
               S01:00000EC4:  C2 CB 0E
F00:1174       	ld hl,getmalloctable
               S01:00000EC7:  21 B8 0D
F00:1175       	ret
               S01:00000ECA:  C9
F00:1176       _loadaddress$17:
F00:1177       	cp DIV8
               S01:00000ECB:  FE 13
F00:1178       	jp nz,_loadaddress18$
               S01:00000ECD:  C2 D4 0E
F00:1179       	ld hl,Div8
               S01:00000ED0:  21 20 0E
F00:1180       	ret
               S01:00000ED3:  C9
F00:1181       _loadaddress18$:
F00:1182       	cp SETRESETPAGE
               S01:00000ED4:  FE 14
F00:1183       	jp nz,_loadaddress19$
               S01:00000ED6:  C2 DD 0E
F00:1184       	ld hl,setresetpage
               S01:00000ED9:  21 C6 0D
F00:1185       	ret
               S01:00000EDC:  C9
F00:1186       _loadaddress19$:
F00:1187       	cp PRINTHEXL
               S01:00000EDD:  FE 15
F00:1188       	jp nz,_loadaddress20$
               S01:00000EDF:  C2 E6 0E
F00:1189       	ld hl,printhexL
               S01:00000EE2:  21 BD 08
F00:1190       	ret
               S01:00000EE5:  C9
F00:1191       _loadaddress20$:
F00:1192       	cp STARTPROCESSINFO
               S01:00000EE6:  FE 16
F00:1193       	jp nz,_loadaddress21$
               S01:00000EE8:  C2 EF 0E
F00:1194       	ld hl,startprocessinfo
               S01:00000EEB:  21 35 0B
F00:1195       	ret
               S01:00000EEE:  C9
F00:1196       _loadaddress21$:
F00:1197       	cp NEXTPROCESSINFO
               S01:00000EEF:  FE 17
F00:1198       	jp nz, _loadaddress22$
               S01:00000EF1:  C2 F8 0E
F00:1199       	ld hl, nextprocessinfo
               S01:00000EF4:  21 5C 0B
F00:1200       	ret
               S01:00000EF7:  C9
F00:1201       _loadaddress22$:
F00:1202       	cp STRCPY
               S01:00000EF8:  FE 18
F00:1203       	jp nz, _loadaddress23$
               S01:00000EFA:  C2 01 0F
F00:1204       	ld hl, strcpy
               S01:00000EFD:  21 68 08
F00:1205       	ret
               S01:00000F00:  C9
F00:1206       _loadaddress23$:
F00:1207       	cp GETPROCESSBYID
               S01:00000F01:  FE 1A
F00:1208       	jp nz,_loadaddress24$
               S01:00000F03:  C2 0A 0F
F00:1209       	ld hl,getprocessbyid
               S01:00000F06:  21 B6 0C
F00:1210       	ret
               S01:00000F09:  C9
F00:1211       _loadaddress24$:
F00:1212       	cp MULTIPLY8
               S01:00000F0A:  FE 1B
F00:1213       	jp nz,_loadaddress25$
               S01:00000F0C:  C2 13 0F
F00:1214       	ld hl,Mul8b
               S01:00000F0F:  21 2E 0E
F00:1215       	ret
               S01:00000F12:  C9
F00:1216       _loadaddress25$:
F00:1217       	cp SETPROCID
               S01:00000F13:  FE 1C
F00:1218       	jp nz, _loadaddress26$
               S01:00000F15:  C2 1C 0F
F00:1219       	ld hl,setprocid
               S01:00000F18:  21 02 0B
F00:1220       	ret
               S01:00000F1B:  C9
F00:1221       _loadaddress26$:
F00:1222       	cp EXITPROCESS
               S01:00000F1C:  FE 1D
F00:1223       	jp nz, _loadaddress27$
               S01:00000F1E:  C2 25 0F
F00:1224       	ld hl,exitprocess
               S01:00000F21:  21 5E 0D
F00:1225       	ret
               S01:00000F24:  C9
F00:1226       _loadaddress27$:
F00:1227       	#----- not defined ---
F00:1228       	ld hl,addressfailedmsg
               S01:00000F25:  21 7C 0F
F00:1229       	call print 
               S01:00000F28:  CD A1 08
F00:1230       	call printhex
               S01:00000F2B:  CD CA 08
F00:1231       
F00:1232       	ld hl,0
               S01:00000F2E:  21 00 00
F00:1233       	ret
               S01:00000F31:  C9
F00:1234       
F00:1235       
F00:1236       	# ======================== end subroutines ========== #
F00:1237       	
F00:1238       	nullroutine: 
F00:1239       		ei
               S01:00000F32:  FB
F00:1240       		reti
               S01:00000F33:  ED 4D
F00:1241       
F00:1242       	serialport: ;#/* interrupt 2, echo what was sent*/
F00:1243       	#	di
F00:1244       		#ld a,'*'
F00:1245       		#out (SERIALPORT),a
F00:1246       
F00:1247       		in a,(SERIALPORT)
               S01:00000F35:  DB 01
F00:1248       		cp 0
               S01:00000F37:  FE 00
F00:1249       		jp nz,_1$
               S01:00000F39:  C2 3E 0F
F00:1250       		ld a,'`'
               S01:00000F3C:  3E 60
F00:1251       _1$:
F00:1252       		out (SERIALPORT),a
               S01:00000F3E:  D3 01
F00:1253       		ei
               S01:00000F40:  FB
F00:1254       		reti
               S01:00000F41:  ED 4D
F00:1255       	crlf: .string "\r\n"
               S01:00000F43:  0D 0A
F00:1256       	loadedmsg: .string "JOSHUA\r\n"
               S01:00000F46:  4A 4F 53 48 55 41 0D 0A
F00:1257       	readymsg: .string "\r\nReady v0.0\r\n"
               S01:00000F4F:  0D 0A 52 65 61 64 79 20 76 30 2E 30 0D 0A
F00:1258       	commandprocessor: .string "cmd"
               S01:00000F5E:  63 6D 64
F00:1259       	errorloadingmsg: .string "error loading program.\r\n\"
               S01:00000F62:  65 72 72 6F 72 20 6C 6F 61 64 69 6E 67 20 70 72
               S01:00000F72:  6F 67 72 61 6D 2E 0D 0A 22
F00:1260       	addressfailedmsg: .string "GetAddress failed for code:"
               S01:00000F7C:  47 65 74 41 64 64 72 65 73 73 20 66 61 69 6C 65
               S01:00000F8C:  64 20 66 6F 72 20 63 6F 64 65 3A
F00:1261       
F00:1262       	.align 8
F00:1263       malloctable: .space 255
F00:1264       
F00:1265       	; I could set the org address but I'm going to let that move as needed	.org 0x????
F00:1266       	;#.org 0x0A00-start
F00:1267       
F00:1268       	.align 8
F00:1269       	jumptable:
F00:1270       	.2byte nullroutine ;0
               S01:00001100:  32 0F
F00:1271       	.2byte serialport ;2
               S01:00001102:  35 0F
F00:1272       	.2byte nullroutine ;4
               S01:00001104:  32 0F
F00:1273       	.2byte nullroutine ;6
               S01:00001106:  32 0F
F00:1274       	.2byte nullroutine ;0
               S01:00001108:  32 0F
F00:1275       	.2byte nullroutine ;0
               S01:0000110A:  32 0F
F00:1276       	.2byte nullroutine ;0
               S01:0000110C:  32 0F
F00:1277       	.2byte nullroutine ;0
               S01:0000110E:  32 0F
F00:1278       	.2byte nullroutine ;0
               S01:00001110:  32 0F
F00:1279       	.2byte nullroutine ;0
               S01:00001112:  32 0F
F00:1280       #/* 10 */
F00:1281       	.2byte nullroutine ;0
               S01:00001114:  32 0F
F00:1282       	.2byte nullroutine ;0
               S01:00001116:  32 0F
F00:1283       	.2byte nullroutine ;0
               S01:00001118:  32 0F
F00:1284       	.2byte nullroutine ;0
               S01:0000111A:  32 0F
F00:1285       	.2byte nullroutine ;0
               S01:0000111C:  32 0F
F00:1286       	.2byte nullroutine ;0
               S01:0000111E:  32 0F
F00:1287       	.2byte nullroutine ;0
               S01:00001120:  32 0F
F00:1288       	.2byte nullroutine ;0
               S01:00001122:  32 0F
F00:1289       	.2byte nullroutine ;0
               S01:00001124:  32 0F
F00:1290       	.2byte nullroutine ;0
               S01:00001126:  32 0F
F00:1291       #/* 20 */
F00:1292       	.2byte nullroutine ;0
               S01:00001128:  32 0F
F00:1293       	.2byte nullroutine ;0
               S01:0000112A:  32 0F
F00:1294       	.2byte nullroutine ;0
               S01:0000112C:  32 0F
F00:1295       	.2byte nullroutine ;0
               S01:0000112E:  32 0F
F00:1296       	.2byte nullroutine ;0
               S01:00001130:  32 0F
F00:1297       	.2byte nullroutine ;0
               S01:00001132:  32 0F
F00:1298       	.2byte nullroutine ;0
               S01:00001134:  32 0F
F00:1299       	.2byte nullroutine ;0
               S01:00001136:  32 0F
F00:1300       	.2byte nullroutine ;0
               S01:00001138:  32 0F
F00:1301       	.2byte nullroutine ;0
               S01:0000113A:  32 0F
F00:1302       #/* 30 */
F00:1303       	.2byte nullroutine ;0
               S01:0000113C:  32 0F
F00:1304       	.2byte nullroutine ;0
               S01:0000113E:  32 0F
F00:1305       	.2byte nullroutine ;0
               S01:00001140:  32 0F
F00:1306       	.2byte nullroutine ;0
               S01:00001142:  32 0F
F00:1307       	.2byte nullroutine ;0
               S01:00001144:  32 0F
F00:1308       	.2byte nullroutine ;0
               S01:00001146:  32 0F
F00:1309       	.2byte nullroutine ;0
               S01:00001148:  32 0F
F00:1310       	.2byte nullroutine ;0
               S01:0000114A:  32 0F
F00:1311       	.2byte nullroutine ;0
               S01:0000114C:  32 0F
F00:1312       	.2byte nullroutine ;0
               S01:0000114E:  32 0F
F00:1313       #/* 40 */
F00:1314       	.2byte nullroutine ;0
               S01:00001150:  32 0F
F00:1315       	.2byte nullroutine ;0
               S01:00001152:  32 0F
F00:1316       	.2byte nullroutine ;0
               S01:00001154:  32 0F
F00:1317       	.2byte nullroutine ;0
               S01:00001156:  32 0F
F00:1318       	.2byte nullroutine ;0
               S01:00001158:  32 0F
F00:1319       	.2byte nullroutine ;0
               S01:0000115A:  32 0F
F00:1320       	.2byte nullroutine ;0
               S01:0000115C:  32 0F
F00:1321       	.2byte nullroutine ;0
               S01:0000115E:  32 0F
F00:1322       	.2byte nullroutine ;0
               S01:00001160:  32 0F
F00:1323       	.2byte nullroutine ;0
               S01:00001162:  32 0F
F00:1324       #/* 50 */
F00:1325       	.2byte nullroutine ;0
               S01:00001164:  32 0F
F00:1326       	.2byte nullroutine ;0
               S01:00001166:  32 0F
F00:1327       	.2byte nullroutine ;0
               S01:00001168:  32 0F
F00:1328       	.2byte nullroutine ;0
               S01:0000116A:  32 0F
F00:1329       	.2byte nullroutine ;0
               S01:0000116C:  32 0F
F00:1330       	.2byte nullroutine ;0
               S01:0000116E:  32 0F
F00:1331       	.2byte nullroutine ;0
               S01:00001170:  32 0F
F00:1332       	.2byte nullroutine ;0
               S01:00001172:  32 0F
F00:1333       	.2byte nullroutine ;0
               S01:00001174:  32 0F
F00:1334       	.2byte nullroutine ;0
               S01:00001176:  32 0F
F00:1335       #/* 60 */
F00:1336       	.2byte nullroutine ;0
               S01:00001178:  32 0F
F00:1337       	.2byte nullroutine ;0
               S01:0000117A:  32 0F
F00:1338       	.2byte nullroutine ;0
               S01:0000117C:  32 0F
F00:1339       	.2byte nullroutine ;0
               S01:0000117E:  32 0F
F00:1340       	.2byte nullroutine ;0
               S01:00001180:  32 0F
F00:1341       	.2byte nullroutine ;0
               S01:00001182:  32 0F
F00:1342       	.2byte nullroutine ;0
               S01:00001184:  32 0F
F00:1343       	.2byte nullroutine ;0
               S01:00001186:  32 0F
F00:1344       	.2byte nullroutine ;0
               S01:00001188:  32 0F
F00:1345       	.2byte nullroutine ;0
               S01:0000118A:  32 0F
F00:1346       #/* 70 */
F00:1347       	.2byte nullroutine ;0
               S01:0000118C:  32 0F
F00:1348       	.2byte nullroutine ;0
               S01:0000118E:  32 0F
F00:1349       	.2byte nullroutine ;0
               S01:00001190:  32 0F
F00:1350       	.2byte nullroutine ;0
               S01:00001192:  32 0F
F00:1351       	.2byte nullroutine ;0
               S01:00001194:  32 0F
F00:1352       	.2byte nullroutine ;0
               S01:00001196:  32 0F
F00:1353       	.2byte nullroutine ;0
               S01:00001198:  32 0F
F00:1354       	.2byte nullroutine ;0
               S01:0000119A:  32 0F
F00:1355       	.2byte nullroutine ;0
               S01:0000119C:  32 0F
F00:1356       	.2byte nullroutine ;0
               S01:0000119E:  32 0F
F00:1357       #/* 80 */
F00:1358       	.2byte nullroutine ;0
               S01:000011A0:  32 0F
F00:1359       	.2byte nullroutine ;0
               S01:000011A2:  32 0F
F00:1360       	.2byte nullroutine ;0
               S01:000011A4:  32 0F
F00:1361       	.2byte nullroutine ;0
               S01:000011A6:  32 0F
F00:1362       	.2byte nullroutine ;0
               S01:000011A8:  32 0F
F00:1363       	.2byte nullroutine ;0
               S01:000011AA:  32 0F
F00:1364       	.2byte nullroutine ;0
               S01:000011AC:  32 0F
F00:1365       	.2byte nullroutine ;0
               S01:000011AE:  32 0F
F00:1366       	.2byte nullroutine ;0
               S01:000011B0:  32 0F
F00:1367       	.2byte nullroutine ;0
               S01:000011B2:  32 0F
F00:1368       #/* 90 */
F00:1369       	.2byte nullroutine ;0
               S01:000011B4:  32 0F
F00:1370       	.2byte nullroutine ;0
               S01:000011B6:  32 0F
F00:1371       	.2byte nullroutine ;0
               S01:000011B8:  32 0F
F00:1372       	.2byte nullroutine ;0
               S01:000011BA:  32 0F
F00:1373       	.2byte nullroutine ;0
               S01:000011BC:  32 0F
F00:1374       	.2byte nullroutine ;0
               S01:000011BE:  32 0F
F00:1375       	.2byte nullroutine ;0
               S01:000011C0:  32 0F
F00:1376       	.2byte nullroutine ;0
               S01:000011C2:  32 0F
F00:1377       	.2byte nullroutine ;0
               S01:000011C4:  32 0F
F00:1378       	.2byte nullroutine ;0
               S01:000011C6:  32 0F
F00:1379       #/* 100 */
F00:1380       	.2byte nullroutine ;0
               S01:000011C8:  32 0F
F00:1381       	.2byte nullroutine ;0
               S01:000011CA:  32 0F
F00:1382       	.2byte nullroutine ;0
               S01:000011CC:  32 0F
F00:1383       	.2byte nullroutine ;0
               S01:000011CE:  32 0F
F00:1384       	.2byte nullroutine ;0
               S01:000011D0:  32 0F
F00:1385       	.2byte nullroutine ;0
               S01:000011D2:  32 0F
F00:1386       	.2byte nullroutine ;0
               S01:000011D4:  32 0F
F00:1387       	.2byte nullroutine ;0
               S01:000011D6:  32 0F
F00:1388       	.2byte nullroutine ;0
               S01:000011D8:  32 0F
F00:1389       	.2byte nullroutine ;0
               S01:000011DA:  32 0F
F00:1390       #/* 110 */
F00:1391       	.2byte nullroutine ;0
               S01:000011DC:  32 0F
F00:1392       	.2byte nullroutine ;0
               S01:000011DE:  32 0F
F00:1393       	.2byte nullroutine ;0
               S01:000011E0:  32 0F
F00:1394       	.2byte nullroutine ;0
               S01:000011E2:  32 0F
F00:1395       	.2byte nullroutine ;0
               S01:000011E4:  32 0F
F00:1396       	.2byte nullroutine ;0
               S01:000011E6:  32 0F
F00:1397       	.2byte nullroutine ;0
               S01:000011E8:  32 0F
F00:1398       	.2byte nullroutine ;0
               S01:000011EA:  32 0F
F00:1399       	.2byte nullroutine ;0
               S01:000011EC:  32 0F
F00:1400       	.2byte nullroutine ;0
               S01:000011EE:  32 0F
F00:1401       #/* 120 */
F00:1402       	.2byte nullroutine ;0
               S01:000011F0:  32 0F
F00:1403       	.2byte nullroutine ;0
               S01:000011F2:  32 0F
F00:1404       	.2byte nullroutine ;0
               S01:000011F4:  32 0F
F00:1405       	.2byte nullroutine ;0
               S01:000011F6:  32 0F
F00:1406       	.2byte nullroutine ;0
               S01:000011F8:  32 0F
F00:1407       	.2byte nullroutine ;0
               S01:000011FA:  32 0F
F00:1408       	.2byte nullroutine ;0
               S01:000011FC:  32 0F
F00:1409       	.2byte nullroutine ;0
               S01:000011FE:  32 0F
F00:1410       
F00:1411       	ENDOFLINE:
F00:1412       	.if (ENDOFLINE > 0x01fff)
F00:1413       		.abort "PROGRAM TOO LARGE TO FIT BELOW <0x2000"
F00:1414       	.endif
F00:1415       	


Sections:
S01  seg800


Sources:
F00  RAM.s
F01  SDCARD.inc
F02  Routines.inc
F03  SERIAL.inc
F04  SDCARD.inc
F05  debughex
F06  debug
F07  dprintln
F08  dprintln
F09  dprintln
F10  dprintln
F11  dprintln
F12  debug
F13  debug
F14  debug
F15  dprintln
F16  dprintln
F17  dprintln
F18  dprintln
F19  dprintln
F20  REPEAT:RAM.s:line 947
F21  debug
F22  debug
F23  debug
F24  debug


Symbols:
ENDOFLINE EXPR(4608=0x1200) ABS 
 serialport _1$ EXPR(3902=0xf3e) ABS 
serialport EXPR(3893=0xf35) ABS 
nullroutine EXPR(3890=0xf32) ABS 
addressfailedmsg EXPR(3964=0xf7c) ABS 
_loadaddress27$ EXPR(3877=0xf25) ABS 
_loadaddress26$ EXPR(3868=0xf1c) ABS 
_loadaddress25$ EXPR(3859=0xf13) ABS 
_loadaddress24$ EXPR(3850=0xf0a) ABS 
_loadaddress23$ EXPR(3841=0xf01) ABS 
_loadaddress22$ EXPR(3832=0xef8) ABS 
_loadaddress21$ EXPR(3823=0xeef) ABS 
_loadaddress20$ EXPR(3814=0xee6) ABS 
_loadaddress19$ EXPR(3805=0xedd) ABS 
_loadaddress18$ EXPR(3796=0xed4) ABS 
_loadaddress$17 EXPR(3787=0xecb) ABS 
_loadaddress$16 EXPR(3778=0xec2) ABS 
_loadaddress$15 EXPR(3769=0xeb9) ABS 
_loadaddress$14 EXPR(3760=0xeb0) ABS 
_loadaddress$13 EXPR(3751=0xea7) ABS 
_loadaddress$12 EXPR(3742=0xe9e) ABS 
_loadaddress$11 EXPR(3733=0xe95) ABS 
_loadaddress$10 EXPR(3724=0xe8c) ABS 
_loadaddress$9 EXPR(3715=0xe83) ABS 
_loadaddress$8 EXPR(3706=0xe7a) ABS 
_loadaddress$7 EXPR(3697=0xe71) ABS 
_loadaddress$6 EXPR(3688=0xe68) ABS 
_loadaddress$5 EXPR(3679=0xe5f) ABS 
_loadaddress$4 EXPR(3670=0xe56) ABS 
_loadaddress$3 EXPR(3661=0xe4d) ABS 
_loadaddress$2 EXPR(3652=0xe44) ABS 
Mul8bSkip EXPR(3640=0xe38) ABS 
Mul8bLoop EXPR(3635=0xe33) ABS 
Div8NextBit EXPR(3627=0xe2b) ABS 
Div8Loop EXPR(3619=0xe23) ABS 
Div8 EXPR(3616=0xe20) ABS 
 setresetpage 4$ EXPR(3581=0xdfd) ABS 
 setresetpage 6$ EXPR(3578=0xdfa) ABS 
 setresetpage 2$ EXPR(3562=0xdea) ABS 
 setresetpage 1$ EXPR(3557=0xde5) ABS 
getmallocrelativebase EXPR(3584=0xe00) ABS 
setresetpage EXPR(3526=0xdc6) ABS 
malloctable EXPR(4096=0x1000) ABS 
getmalloctable EXPR(3512=0xdb8) ABS 
getcommandparams EXPR(3499=0xdab) ABS 
endprocesstable EXPR(3499=0xdab) UNUSED ABS 
maxprocesses EXPR(3465=0xd89) UNUSED ABS 
 exitprocess 99$ EXPR(3426=0xd62) ABS 
 exitprocess 191$ EXPR(3438=0xd6e) ABS 
exitprocess EXPR(3422=0xd5e) ABS 
 writezombieprocess 1$ EXPR(3420=0xd5c) ABS 
 writezombieprocess 99$ EXPR(3372=0xd2c) ABS 
 writezombieprocess 181$ EXPR(3391=0xd3f) ABS 
writezombieprocess EXPR(3368=0xd28) ABS 
want IMP REF 
 deleteprocessbyid 0$ EXPR(3360=0xd20) ABS 
 deleteprocessbyid 1$ EXPR(3364=0xd24) ABS 
 deleteprocessbyid 99$ EXPR(3322=0xcfa) ABS 
 deleteprocessbyid 171$ EXPR(3340=0xd0c) ABS 
deleteprocessbyid EXPR(3318=0xcf6) UNUSED ABS 
 getprocessbyid 1$ EXPR(3315=0xcf3) ABS 
 getprocessbyid 2$ EXPR(3296=0xce0) ABS 
 getprocessbyid 99$ EXPR(3258=0xcba) ABS 
 getprocessbyid 161$ EXPR(3273=0xcc9) ABS 
getprocessbyid EXPR(3254=0xcb6) ABS 
errormsg EXPR(3186=0xc72) ABS 
failed EXPR(3177=0xc69) ABS 
 writeprocessinfo 99$ EXPR(3110=0xc26) ABS 
 writeprocessinfo 151$ EXPR(3127=0xc37) ABS 
 getnewprocessid 3$ EXPR(3095=0xc17) ABS 
 getnewprocessid 2$ EXPR(3073=0xc01) ABS 
 getnewprocessid 1$ EXPR(3049=0xbe9) ABS 
 getnewprocessid 99$ EXPR(3023=0xbcf) ABS 
 getnewprocessid 111$ EXPR(3039=0xbdf) ABS 
 getprocessslot 1$ EXPR(3016=0xbc8) ABS 
 getprocessslot 2$ EXPR(3002=0xbba) ABS 
 getprocessslot 99$ EXPR(2977=0xba1) ABS 
 getprocessslot 101$ EXPR(2992=0xbb0) ABS 
getprocessslot EXPR(2973=0xb9d) ABS 
 nextprocessinfo 1$ EXPR(2963=0xb93) ABS 
Mul8b EXPR(3630=0xe2e) ABS 
 nextprocessinfo 99$ EXPR(2912=0xb60) ABS 
 nextprocessinfo 91$ EXPR(2928=0xb70) ABS 
nextprocessinfo EXPR(2908=0xb5c) ABS 
processtable EXPR(3467=0xd8b) ABS 
currentprocessinfo EXPR(3466=0xd8a) ABS 
 startprocessinfo 99$ EXPR(2873=0xb39) ABS 
 startprocessinfo 81$ EXPR(2890=0xb4a) ABS 
startprocessinfo EXPR(2869=0xb35) ABS 
writeprocessinfo EXPR(3106=0xc22) ABS 
getnewprocessid EXPR(3019=0xbcb) ABS 
 createnewprocessinfo 99$ EXPR(2826=0xb0a) ABS 
 createnewprocessinfo 71$ EXPR(2847=0xb1f) ABS 
lastprogramid EXPR(3464=0xd88) ABS 
setprocid EXPR(2818=0xb02) ABS 
procname EXPR(3454=0xd7e) ABS 
progloadaddress EXPR(2732=0xaac) ABS 
createnewprocessinfo EXPR(2822=0xb06) ABS 
 createProcess _4$ EXPR(2722=0xaa2) ABS 
_progloadaddr EXPR(2733=0xaad) ABS 
_createProcesserr$1 EXPR(2735=0xaaf) ABS 
copyprogramname EXPR(2740=0xab4) ABS 
theprocessmsg EXPR(2751=0xabf) ABS 
thecommandlinemsg EXPR(2760=0xac8) ABS 
theparams EXPR(2768=0xad0) ABS 
createProcess EXPR(2624=0xa40) ABS 
_exitgetfilename EXPR(2618=0xa3a) ABS 
_getfilename$1 EXPR(2602=0xa2a) ABS 
getfilename EXPR(2596=0xa24) ABS 
nextfile EXPR(2589=0xa1d) ABS 
directoryopen EXPR(2582=0xa16) ABS 
hextobytenumber EXPR(2579=0xa13) ABS 
workhextobyte EXPR(2571=0xa0b) ABS 
hextobyte EXPR(2552=0x9f8) ABS 
stackpages EXPR(2551=0x9f7) UNUSED ABS 
hisize EXPR(2547=0x9f3) UNUSED ABS 
losize EXPR(2546=0x9f2) ABS 
sizeincrement EXPR(2522=0x9da) ABS 
 available _1$ EXPR(2456=0x998) ABS 
_$nextbyte EXPR(2471=0x9a7) ABS 
 loadheader _1$ EXPR(2423=0x977) ABS 
 loadheader _2$ EXPR(2399=0x95f) ABS 
reservemalloc EXPR(3516=0xdbc) ABS 
 testloadaddress 45$ EXPR(2370=0x942) ABS 
memorypages EXPR(2550=0x9f6) ABS 
 testloadaddress _4$ EXPR(2392=0x958) ABS 
loadheader EXPR(2395=0x95b) ABS 
available EXPR(2436=0x984) ABS 
sizeloaded EXPR(2488=0x9b8) ABS 
testloadaddress EXPR(2334=0x91e) ABS 
_$openfile EXPR(2315=0x90b) ABS 
_$getnextchar EXPR(2298=0x8fa) ABS 
startaddress EXPR(2548=0x9f4) ABS 
sizereset EXPR(2503=0x9c7) ABS 
putc EXPR(2272=0x8e0) ABS 
_$ EXPR(2259=0x8d3) ABS 
printhexL EXPR(2237=0x8bd) ABS 
_$2 EXPR(2234=0x8ba) ABS 
_$1 EXPR(2223=0x8af) ABS 
crlf EXPR(3907=0xf43) ABS 
nextcharacter EXPR(2185=0x889) ABS 
converttouppercaseletter EXPR(2182=0x886) ABS 
goagain EXPR(2173=0x87d) ABS 
touppercase EXPR(2171=0x87b) ABS 
_strcpyexit$1 EXPR(2167=0x877) ABS 
 strcpy _1$ EXPR(2155=0x86b) ABS 
strcpy EXPR(2152=0x868) ABS 
strncpy EXPR(2149=0x865) ABS 
strlenexit EXPR(2146=0x862) ABS 
_strlen$ EXPR(2135=0x857) ABS 
strlen EXPR(2131=0x853) ABS 
_metset$1 EXPR(2124=0x84c) ABS 
memset EXPR(2122=0x84a) ABS 
errorloadingmsg EXPR(3938=0xf62) ABS 
printhex EXPR(2250=0x8ca) ABS 
commandline EXPR(2119=0x847) ABS 
println EXPR(2195=0x893) ABS 
_cmdlne EXPR(2120=0x848) ABS 
errorloading EXPR(2107=0x83b) ABS 
loadFILE EXPR(2275=0x8e3) ABS 
commandprocessor EXPR(3934=0xf5e) ABS 
commandprocessloop EXPR(2078=0x81e) ABS 
loadedmsg EXPR(3910=0xf46) ABS 
jumptable EXPR(4352=0x1100) ABS 
print EXPR(2209=0x8a1) ABS 
readymsg EXPR(3919=0xf4f) ABS 
loadaddress EXPR(3643=0xe3b) ABS 
start EXPR(2052=0x804) UNUSED ABS 
boot EXPR(2055=0x807) ABS 
NEXTNUMBER EXPR(30=0x1e) UNUSED 
EXITPROCESS EXPR(29=0x1d) 
MULTIPLY8 EXPR(27=0x1b) 
GETPROCESSBYID EXPR(26=0x1a) 
NEXTPROCESSINFO EXPR(23=0x17) 
STARTPROCESSINFO EXPR(22=0x16) 
SETRESETPAGE EXPR(20=0x14) 
DIV8 EXPR(19=0x13) 
GETMALLOCTABLE EXPR(18=0x12) 
GETFILENAME EXPR(15=0xf) 
DIRECTORYNEXTFILE EXPR(14=0xe) UNUSED 
DIRECTORYOPEN EXPR(13=0xd) 
GETCOMMANDPARAMS EXPR(17=0x11) 
CREATEPROCESS EXPR(16=0x10) 
HEXTOBYTE EXPR(8=0x8) 
TOUPPERCASE EXPR(7=0x7) 
PUTC EXPR(6=0x6) 
STRNCPY EXPR(10=0xa) 
STRCPY EXPR(24=0x18) 
STRLEN EXPR(5=0x5) 
MEMSET EXPR(4=0x4) 
LOADFILE EXPR(3=0x3) 
PRINTHEXL EXPR(21=0x15) 
PRINTHEX EXPR(2=0x2) 
PRINTLN EXPR(9=0x9) 
PRINT EXPR(1=0x1) 
SETPROCID EXPR(28=0x1c) 
GetAddress EXPR(2052=0x804) UNUSED 
FALSE EXPR(0=0x0) UNUSED 
TRUE EXPR(1=0x1) UNUSED 
libMemory EXPR(61440=0xf000) UNUSED 
userMemory EXPR(12288=0x3000) 
commandMemory EXPR(8192=0x2000) UNUSED 
SERIALPORT2 EXPR(2=0x2) UNUSED 
SERIALPORT EXPR(1=0x1) 
NEXTFILE EXPR(50=0x32) 
OPENDIRECTORY EXPR(49=0x31) 
NAMEAVAILABLE EXPR(33=0x21) 
GETNAME EXPR(32=0x20) 
WRITEBYTE EXPR(8=0x8) UNUSED 
OPENWRITE EXPR(7=0x7) UNUSED 
AVAILABLE EXPR(6=0x6) 
READNEXTBYTE EXPR(5=0x5) 
FILENAMEAPPEND EXPR(4=0x4) 
CLOSE EXPR(3=0x3) UNUSED 
OPEN EXPR(2=0x2) 
FILENAMECLEAR EXPR(1=0x1) 
SDCARD EXPR(5=0x5) 
PROCINFOSIZE EXPR(8=0x8) 
MAXPROCESSES EXPR(4=0x4) 
__VASM EXPR(0=0x0) INTERNAL 
__MSDOSFS EXPR(0=0x0) INTERNAL 

There have been 1 errors!

F00:0001       
F00:0002       
F00:0003       
F00:0004       #define LOWORD(l) ((WORD)(l))
F00:0005       #define HIWORD(l) ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
F00:0006       #define LOBYTE(w) ((BYTE)(w))
F00:0007       #define HIBYTE(w) ((BYTE)(((WORD)(w) >> 8) & 0xFF))
F00:0008       # process table - maximum number of entries - which also means the maximum number of processes
F00:0009       .set MAXPROCESSES,4
F00:0010       .set PROCINFOSIZE,8
F00:0011       
F00:0012       .include "SDCARD.inc"
F01:0001       .equ SDCARD,0x05
F01:0002       ; ******* SDCARD *********
F01:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F01:0004       .equ FILENAMECLEAR ,1
F01:0005       
F01:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F01:0007       .equ OPEN ,2
F01:0008       
F01:0009       ; z80 out - close: no return value
F01:0010       .equ CLOSE ,3
F01:0011       
F01:0012       ; z80 out + out - filenameappend: no return value
F01:0013       .equ FILENAMEAPPEND ,4
F01:0014       
F01:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F01:0016       .equ READNEXTBYTE ,5
F01:0017       
F01:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F01:0019       .equ AVAILABLE ,6
F01:0020       
F01:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F01:0022       .equ OPENWRITE,7
F01:0023       
F01:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F01:0025       .equ WRITEBYTE,8
F01:0026       
F01:0027       ;#===============================
F01:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F01:0029       .equ GETNAME,0x20
F01:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F01:0031       .equ NAMEAVAILABLE,0x21
F01:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F01:0033       .equ OPENDIRECTORY,0x31
F01:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F01:0035       .equ NEXTFILE,0x32
F00:0013       .include "Routines.inc"
F02:0001       
F02:0002       .macro DEBUG CHARACTER='!'
F02:0009       
F02:0010       
F02:0011       .macro DEBUGHEX CHARACTER='!'
F02:0018       
F02:0019       
F02:0020       .macro PRINTLN
F02:0025       
F02:0026       
F02:0027       
F02:0028       # address where user programs load
F02:0029       .include "SERIAL.inc"
F03:0001       .equ SERIALPORT , 0x01
F03:0002       .equ SERIALPORT2, 0x02
F03:0003       
F02:0030       .include "SDCARD.inc"
F04:0001       .equ SDCARD,0x05
F04:0002       ; ******* SDCARD *********
F04:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F04:0004       .equ FILENAMECLEAR ,1
F04:0005       
F04:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F04:0007       .equ OPEN ,2
F04:0008       
F04:0009       ; z80 out - close: no return value
F04:0010       .equ CLOSE ,3
F04:0011       
F04:0012       ; z80 out + out - filenameappend: no return value
F04:0013       .equ FILENAMEAPPEND ,4
F04:0014       
F04:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F04:0016       .equ READNEXTBYTE ,5
F04:0017       
F04:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F04:0019       .equ AVAILABLE ,6
F04:0020       
F04:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F04:0022       .equ OPENWRITE,7
F04:0023       
F04:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F04:0025       .equ WRITEBYTE,8
F04:0026       
F04:0027       ;#===============================
F04:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F04:0029       .equ GETNAME,0x20
F04:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F04:0031       .equ NAMEAVAILABLE,0x21
F04:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F04:0033       .equ OPENDIRECTORY,0x31
F04:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F04:0035       .equ NEXTFILE,0x32
F02:0031       .equ commandMemory, 0x2000
F02:0032       .equ userMemory,0x3000
F02:0033       .equ libMemory,0xF000
F02:0034       
F02:0035       .equ TRUE, 1
F02:0036       .equ FALSE, 0
F02:0037       
F02:0038       # the only fixed address (i hope), use it to get the address of utilities methods
F02:0039       # ld a, PRINT
F02:0040       # call GetAddress
F02:0041       # address for print loaded into hl
F02:0042       # the value in hl can change between os versions so do not hard code the values
F02:0043       
F02:0044       .equ GetAddress, 0x0804
F02:0045       .equ SETPROCID,28
F02:0046       .equ PRINT,		1
F02:0047       .equ PRINTLN,	9
F02:0048       .equ PRINTHEX,	2
F02:0049       .equ PRINTHEXL,21
F02:0050       .equ LOADFILE,	3
F02:0051       .equ MEMSET,	4
F02:0052       .equ STRLEN,	5
F02:0053       .equ STRCPY,24
F02:0054       .equ STRNCPY,10
F02:0055       .equ PUTC,		6
F02:0056       .equ TOUPPERCASE,7
F02:0057       .equ HEXTOBYTE,	8
F02:0058       .equ CREATEPROCESS,16
F02:0059       .equ GETCOMMANDPARAMS,17
F02:0060       # filesystem - primitive functions, probably going to change 
F02:0061       .equ DIRECTORYOPEN,13
F02:0062       .equ DIRECTORYNEXTFILE,14
F02:0063       .equ GETFILENAME,15
F02:0064       .equ GETMALLOCTABLE,18
F02:0065       .equ DIV8,19
F02:0066       .equ SETRESETPAGE,20
F02:0067       .equ STARTPROCESSINFO,22
F02:0068       .equ NEXTPROCESSINFO,23
F02:0069       .equ GETPROCESSBYID,26
F02:0070       .equ MULTIPLY8,27
F02:0071       
F02:0072       
F02:0073       
F02:0074       
F02:0075       .equ NEXTNUMBER,29
F02:0076       
F02:0077       
F00:0014       
F00:0015       
F00:0016       	.org 0x800
F00:0017       	jp boot
               S01:00000800:  C3 07 08
F00:0018       	.align 2
F00:0019       	start:
F00:0020       	jp loadaddress
               S01:00000804:  C3 F4 0C
F00:0021       	
F00:0022       boot:
F00:0023       	ld sp,0xffff
               S01:00000807:  31 FF FF
F00:0024       
F00:0025       	di
               S01:0000080A:  F3
F00:0026       	ld hl,readymsg
               S01:0000080B:  21 FF 0D
F00:0027       	call print
               S01:0000080E:  CD A1 08
F00:0028       		;ld b, endlabel2-label2
F00:0029       		;ld c,SERIALPORT
F00:0030       		;otir
F00:0031       		
F00:0032       		im 2 ;/* interrupt mode 2*/
               S01:00000811:  ED 5E
F00:0033       		ld a, jumptable/256 ;// hibyte
               S01:00000813:  3E 10
F00:0034       		ld i,a
               S01:00000815:  ED 47
F00:0035       		ei   ;#/* enable interrupts*/
               S01:00000817:  FB
F00:0036       
F00:0037       		ld hl,loadedmsg
               S01:00000818:  21 F6 0D
F00:0038       		call print
               S01:0000081B:  CD A1 08
F00:0039       		#== ******* Command processor Loop ******** ==# I THINK THIS NEEDS A REVIEW IT SHOULD BE USING CREATEPROCESS
F00:0040       	commandprocessloop:	
F00:0041       		ld hl,commandprocessor
               S01:0000081E:  21 0E 0E
F00:0042       #		ld de,commandMemory
F00:0043       		ld de,0
               S01:00000821:  11 00 00
F00:0044       		call loadFILE
               S01:00000824:  CD E3 08
F00:0045       		cp 0
               S01:00000827:  FE 00
F00:0046       		jp nz,errorloading
               S01:00000829:  C2 3B 08
F00:0047       		ld (_cmdlne),hl ;# save the load address
               S01:0000082C:  22 48 08
F00:0048       		ld hl,0
               S01:0000082F:  21 00 00
F00:0049       		call println
               S01:00000832:  CD 93 08
F00:0050       #		call commandMemory # run the file just loaded.
F00:0051       		call commandline
               S01:00000835:  CD 47 08
F00:0052       		jp commandprocessloop
               S01:00000838:  C3 1E 08
F00:0053       
F00:0054       	errorloading:
F00:0055       		call printhex
               S01:0000083B:  CD CA 08
F00:0056       		ld hl,errorloadingmsg
               S01:0000083E:  21 12 0E
F00:0057       		call println
               S01:00000841:  CD 93 08
F00:0058       		jp commandprocessloop
               S01:00000844:  C3 1E 08
F00:0059       
F00:0060       commandline: .byte 0xc3
               S01:00000847:  C3
F00:0061       	_cmdlne: .2byte 0
               S01:00000848:  00 00
F00:0062       
F00:0063       		#======================suboutines===============================================#
F00:0064       	# === memset === #
F00:0065       		# ld hl, address to start
F00:0066       		# ld a,0 byte to write into address
F00:0067       		# ld b,1 count of bytes to write
F00:0068       	memset:
F00:0069       		push af
               S01:0000084A:  F5
F00:0070       		push hl
               S01:0000084B:  E5
F00:0071       	_metset$1:
F00:0072       		ld (hl),a
               S01:0000084C:  77
F00:0073       		inc hl
               S01:0000084D:  23
F00:0074       		djnz _metset$1
               S01:0000084E:  10 FC
F00:0075       		pop hl
               S01:00000850:  E1
F00:0076       		pop af
               S01:00000851:  F1
F00:0077       		ret
               S01:00000852:  C9
F00:0078       	#== strlen ==#
F00:0079       		# ld hl, address to start
F00:0080       		# call strlen
F00:0081       		# return len in b
F00:0082       	strlen:
F00:0083       		push hl
               S01:00000853:  E5
F00:0084       		push af
               S01:00000854:  F5
F00:0085       	
F00:0086       		ld b,0
               S01:00000855:  06 00
F00:0087       	_strlen$:
F00:0088       		ld a,(hl)
               S01:00000857:  7E
F00:0089       		cp 0
               S01:00000858:  FE 00
F00:0090       		jp z, strlenexit
               S01:0000085A:  CA 62 08
F00:0091       		inc b
               S01:0000085D:  04
F00:0092       		inc hl
               S01:0000085E:  23
F00:0093       		jp _strlen$:
               S01:0000085F:  C3 57 08
F00:0094       	strlenexit:
F00:0095       	;#	ld a,b
F00:0096       	;#	call printhex
F00:0097       		pop af
               S01:00000862:  F1
F00:0098       		pop hl
               S01:00000863:  E1
F00:0099       		ret
               S01:00000864:  C9
F00:0100       
F00:0101       	#=== strncpy ==#
F00:0102       	;# copy from source into destination size bytes. no validation is done.
F00:0103       	;# ld hl, source
F00:0104       	;# ld de, destination
F00:0105       	;# ld bc, size
F00:0106       	;# this will copy binary strings??? so this needs fixing to stop on a null byte
F00:0107       
F00:0108       	strncpy:
F00:0109       		ldir
               S01:00000865:  ED B0
F00:0110       		ret
               S01:00000867:  C9
F00:0111       
F00:0112       	# === strcpy == #
F00:0113       	;# copy from source into destination string is zero terminated, no validation is done
F00:0114       	;# ld hl,source
F00:0115       	;# ld de,destination
F00:0116       	;# call strcpy
F00:0117       	strcpy:
F00:0118       		push af
               S01:00000868:  F5
F00:0119       		push hl
               S01:00000869:  E5
F00:0120       		push de
               S01:0000086A:  D5
F00:0121       	_1$:
F00:0122       		ld a,(hl)
               S01:0000086B:  7E
F00:0123       		ld (de),a ;# copy the potential zero before we test because we will need it
               S01:0000086C:  12
F00:0124       		cp 0
               S01:0000086D:  FE 00
F00:0125       		jp z, _strcpyexit$1
               S01:0000086F:  CA 77 08
F00:0126       
F00:0127       		inc de
               S01:00000872:  13
F00:0128       		inc hl
               S01:00000873:  23
F00:0129       		jp _1$
               S01:00000874:  C3 6B 08
F00:0130       	
F00:0131       	_strcpyexit$1:
F00:0132       		pop de
               S01:00000877:  D1
F00:0133       		pop hl
               S01:00000878:  E1
F00:0134       		pop af
               S01:00000879:  F1
F00:0135       		ret
               S01:0000087A:  C9
F00:0136       		# === touppercase ==#
F00:0137       	;#		ld hl,cmd  - zero terminated string
F00:0138       	;#		call touppercase
F00:0139       	;#		ret
F00:0140       	;# the P flag means the comparison was Positive
F00:0141       	;# the M flags means the comparision was Negative
F00:0142       	;# the Z flag means the comparison was equal
F00:0143       	;# the NZ flag means the comparison was not equal.
F00:0144       	;# where:
F00:0145       	;#    A = x  P Positive
F00:0146       	;#			 Z Zero
F00:0147       	;#
F00:0148       	;#    A < x	 M Negative
F00:0149       	;#			 NZ Not zero
F00:0150       	;#
F00:0151       	;#	  A > x  P Positive
F00:0152       	;#			 NZ Not zero
F00:0153       	;#
F00:0154       	;# so a test for JP P,meansSameOrGreater
F00:0155       
F00:0156       
F00:0157       touppercase:
F00:0158       	push af
               S01:0000087B:  F5
F00:0159       	push hl
               S01:0000087C:  E5
F00:0160       	
F00:0161       goagain:
F00:0162       	ld a,(hl)
               S01:0000087D:  7E
F00:0163       	cp 'a'
               S01:0000087E:  FE 61
F00:0164       	jp p, converttouppercaseletter ;# is same or greater then 'a'
               S01:00000880:  F2 86 08
F00:0165       ;# the instructions commented out are implied
F00:0166       	;#cp 'A'
F00:0167       	;#jp p, nextcharacter ;# is same or greater
F00:0168       	;#cp '0'
F00:0169       	;#jp p, nextcharacter
F00:0170       	;# jp nextcharacter replaces the above 4 lines
F00:0171       	jp nextcharacter
               S01:00000883:  C3 89 08
F00:0172       
F00:0173       converttouppercaseletter:
F00:0174       	sub 32
               S01:00000886:  D6 20
F00:0175       	ld (hl),a
               S01:00000888:  77
F00:0176       nextcharacter:
F00:0177       	inc hl
               S01:00000889:  23
F00:0178       	ld a,(hl)
               S01:0000088A:  7E
F00:0179       	cp 0
               S01:0000088B:  FE 00
F00:0180       	jp nz,goagain	
               S01:0000088D:  C2 7D 08
F00:0181       
F00:0182       	pop hl
               S01:00000890:  E1
F00:0183       	pop af
               S01:00000891:  F1
F00:0184       
F00:0185       	ret
               S01:00000892:  C9
F00:0186       	# === PRINTLN == #
F00:0187       	println: ;// same as print but appends CRLF
F00:0188       	call print
               S01:00000893:  CD A1 08
F00:0189       	push hl
               S01:00000896:  E5
F00:0190       	push af
               S01:00000897:  F5
F00:0191       	ld hl,crlf
               S01:00000898:  21 F3 0D
F00:0192       	call print
               S01:0000089B:  CD A1 08
F00:0193       	pop af
               S01:0000089E:  F1
F00:0194       	pop hl
               S01:0000089F:  E1
F00:0195       	ret
               S01:000008A0:  C9
F00:0196       
F00:0197       	# === PRINT === #
F00:0198       	print: ;// expecting a zero terminated string
F00:0199       		push hl
               S01:000008A1:  E5
F00:0200       		push af
               S01:000008A2:  F5
F00:0201       		;# hl can be null so check for that first
F00:0202       		ld a,h
               S01:000008A3:  7C
F00:0203       		cp 0
               S01:000008A4:  FE 00
F00:0204       		jp nz,_$1 ;# hibyte not null, no just print it
               S01:000008A6:  C2 AF 08
F00:0205       		ld a,l
               S01:000008A9:  7D
F00:0206       		cp 0
               S01:000008AA:  FE 00
F00:0207       		jp z,_$2 ;# lobyte is null and hibyte is null so just exit
               S01:000008AC:  CA BA 08
F00:0208       		_$1:
F00:0209       			ld a,(hl)
               S01:000008AF:  7E
F00:0210       			cp 0
               S01:000008B0:  FE 00
F00:0211       			jr z,_$2
               S01:000008B2:  28 06
F00:0212       			out (SERIALPORT),a
               S01:000008B4:  D3 01
F00:0213       			inc hl
               S01:000008B6:  23
F00:0214       			jp _$1
               S01:000008B7:  C3 AF 08
F00:0215       _$2:			
F00:0216       		pop af
               S01:000008BA:  F1
F00:0217       		pop hl
               S01:000008BB:  E1
F00:0218       		ret
               S01:000008BC:  C9
F00:0219       ;#=== printhexL ===#
F00:0220       ;# ld hl,passwords
F00:0221       ;# call printhexL
F00:0222       
F00:0223       printhexL:
F00:0224       	push af
               S01:000008BD:  F5
F00:0225       	push hl
               S01:000008BE:  E5
F00:0226       	ld a,h
               S01:000008BF:  7C
F00:0227       	call printhex
               S01:000008C0:  CD CA 08
F00:0228       	ld a,l
               S01:000008C3:  7D
F00:0229       	call printhex
               S01:000008C4:  CD CA 08
F00:0230       	pop hl
               S01:000008C7:  E1
F00:0231       	pop af
               S01:000008C8:  F1
F00:0232       	ret
               S01:000008C9:  C9
F00:0233       # === PRINTHEX === #
F00:0234       		;Display 8-bit number in hex.
F00:0235       		; 	ld a,0xaa
F00:0236       	;       call printhex
F00:0237       printhex:
F00:0238       
F00:0239       ; Input: a
F00:0240       
F00:0241         push af
               S01:000008CA:  F5
F00:0242         ;// remove low nibble
F00:0243          rra
               S01:000008CB:  1F
F00:0244          rra
               S01:000008CC:  1F
F00:0245          rra
               S01:000008CD:  1F
F00:0246          rra
               S01:000008CE:  1F
F00:0247          call  _$
               S01:000008CF:  CD D3 08
F00:0248          ;// restore low nibble
F00:0249          pop af
               S01:000008D2:  F1
F00:0250          
F00:0251       _$:
F00:0252       	push af
               S01:000008D3:  F5
F00:0253       	;// remove high nibble
F00:0254          and  0x0F
               S01:000008D4:  E6 0F
F00:0255          add  a,0x90
               S01:000008D6:  C6 90
F00:0256          ;; bcd adjust
F00:0257          daa
               S01:000008D8:  27
F00:0258          adc  a,0x40
               S01:000008D9:  CE 40
F00:0259          daa
               S01:000008DB:  27
F00:0260          out (SERIALPORT),a 
               S01:000008DC:  D3 01
F00:0261          pop af
               S01:000008DE:  F1
F00:0262          ret
               S01:000008DF:  C9
F00:0263       
F00:0264       # === putc ===== #
F00:0265       ;# ld a,'*'
F00:0266       ;# call putc
F00:0267       ;# no return value
F00:0268       putc:
F00:0269       		out (SERIALPORT),a
               S01:000008E0:  D3 01
F00:0270       		ret
               S01:000008E2:  C9
F00:0271       
F00:0272       		;// end subroutines
F00:0273       # === loadFILE === #
F00:0274       ; ld hl, filename (zero terminated)
F00:0275       ; ld de, memory address to load file into
F00:0276       ; call loadFILE
F00:0277       ; returns 
F00:0278       ;	HL
F00:0279       ;		baseaddress of the dll
F00:0280       ;	A register 
F00:0281       ;			2 = failed to open the file
F00:0282       ;			0 = if file loaded into memory
F00:0283       ;	DE register pair
F00:0284       ;			count of bytes loaded
F00:0285       loadFILE:
F00:0286       	push af
               S01:000008E3:  F5
F00:0287       	push de ; save de for later
               S01:000008E4:  D5
F00:0288       	call sizereset
               S01:000008E5:  CD C7 09
F00:0289       	ld a,0 ;# erase the executable header information
               S01:000008E8:  3E 00
F00:0290       	ld (startaddress),a
               S01:000008EA:  32 F4 09
F00:0291       	ld (startaddress+1),a
               S01:000008ED:  32 F5 09
F00:0292       	ld (startaddress+2),a
               S01:000008F0:  32 F6 09
F00:0293       	ld (startaddress+3),a
               S01:000008F3:  32 F7 09
F00:0294       		; try to open the SD card and read some data
F00:0295       		ld a,FILENAMECLEAR ; // filenameclear
               S01:000008F6:  3E 01
F00:0296       		out (SDCARD),a
               S01:000008F8:  D3 05
F00:0297       
F00:0298       
F00:0299       ;
F00:0300       _$getnextchar:
F00:0301       		ld a,(hl)
               S01:000008FA:  7E
F00:0302       		cp 0
               S01:000008FB:  FE 00
F00:0303       		jp z, _$openfile #; if filename character is null we have finished
               S01:000008FD:  CA 0B 09
F00:0304       		ld a,FILENAMEAPPEND
               S01:00000900:  3E 04
F00:0305       		out (SDCARD),a ; // filenameappend
               S01:00000902:  D3 05
F00:0306       		ld a,(hl)
               S01:00000904:  7E
F00:0307       		out (SDCARD),a
               S01:00000905:  D3 05
F00:0308       		;#out (SERIALPORT),a
F00:0309       		inc hl
               S01:00000907:  23
F00:0310       		jp _$getnextchar
               S01:00000908:  C3 FA 08
F00:0311       
F00:0312       _$openfile:
F00:0313       #openfile will return 1 if the file was opened, 0 if it failed to open
F00:0314       		ld a,OPEN	;// Open
               S01:0000090B:  3E 02
F00:0315       		out (SDCARD),a
               S01:0000090D:  D3 05
F00:0316       		in a,(SDCARD)
               S01:0000090F:  DB 05
F00:0317       		pop hl ; get load address - must pop the stack before returning
               S01:00000911:  E1
F00:0318       		cp 0
               S01:00000912:  FE 00
F00:0319       		jp nz,testloadaddress
               S01:00000914:  C2 1E 09
F00:0320       		pop af ;# a flag not needed now
               S01:00000917:  F1
F00:0321       		call sizeloaded
               S01:00000918:  CD B8 09
F00:0322       		ld a,2 ;we have an error trying to open the file.
               S01:0000091B:  3E 02
F00:0323       		ret
               S01:0000091D:  C9
F00:0324       testloadaddress:
F00:0325       	# if loadaddress (hl) = 0, then the file will have load address information in the 1st 2 bytes
F00:0326       	ld a,0
               S01:0000091E:  3E 00
F00:0327       	cp h
               S01:00000920:  BC
F00:0328       	jp nz,available ;# h is not zero so it must have an address to load into already
               S01:00000921:  C2 84 09
F00:0329       	cp l
               S01:00000924:  BD
F00:0330       	jp nz,available ;# l is not zero so it must have an address to load intop already
               S01:00000925:  C2 84 09
F00:0331       
F00:0332       	ld hl,startaddress ;# this is the place to store the 2 bytes we need to get at the load address
               S01:00000928:  21 F4 09
F00:0333       	call loadheader
               S01:0000092B:  CD 5B 09
F00:0334       	cp 1
               S01:0000092E:  FE 01
F00:0335       	jp nz,_4$
               S01:00000930:  C2 58 09
F00:0336       
F00:0337       	ld hl,(startaddress)
               S01:00000933:  2A F4 09
F00:0338       	inc hl ;#start address
               S01:00000936:  23
F00:0339       	inc hl
               S01:00000937:  23
F00:0340       	inc hl ;# program size in pages
               S01:00000938:  23
F00:0341       	inc hl ;# stack size in pages
               S01:00000939:  23
F00:0342       	ld (startaddress),hl ;# this is now the dll entry point address, will need this later to initialize the library
               S01:0000093A:  22 F4 09
F00:0343       
F00:0344       	ld a,(memorypages)
               S01:0000093D:  3A F6 09
F00:0345       	ld b,a
               S01:00000940:  47
F00:0346       	ld a,h
               S01:00000941:  7C
F00:0347       
F00:0348       45$:	DEBUGHEX a
F05:0001       # example : DEBUGHEX '!'
F05:0002       #      or : DEBUGHEX h
F05:0003       		push af
               S01:00000942:  F5
F05:0004       		ld a,a
               S01:00000943:  7F
F05:0005       		call printhex
               S01:00000944:  CD CA 08
F05:0006       		pop af
               S01:00000947:  F1
F00:0349       	DEBUG '\n'
F06:0001       # example : DEBUG '!'
F06:0002       #      or : DEBUG h
F06:0003       		push af
               S01:00000948:  F5
F06:0004       		ld a,10
               S01:00000949:  3E 0A
F06:0005       		call putc
               S01:0000094B:  CD E0 08
F06:0006       		pop af
               S01:0000094E:  F1
F00:0350       
F00:0351       	call reservemalloc
               S01:0000094F:  CD 75 0C
F00:0352       	inc a
               S01:00000952:  3C
F00:0353       	djnz 45$
               S01:00000953:  10 ED
F00:0354       
F00:0355       	jp available
               S01:00000955:  C3 84 09
F00:0356       _4$:
F00:0357       	ld a,3 ;#new error code
               S01:00000958:  3E 03
F00:0358       	ret
               S01:0000095A:  C9
F00:0359       	#if we reach here then the first 2 bytes have the address information so let read them now
F00:0360       	;# header information
F00:0361       	;# 2bytes program load address
F00:0362       	;# 1byte memory required in pages
F00:0363       	;# 1byte stack required in pages
F00:0364       loadheader:
F00:0365       	ld b,4
               S01:0000095B:  06 04
F00:0366       	ld c,0
               S01:0000095D:  0E 00
F00:0367       _2$:
F00:0368       	ld a, AVAILABLE
               S01:0000095F:  3E 06
F00:0369       	out (SDCARD),a
               S01:00000961:  D3 05
F00:0370       	in a,(SDCARD) ;# is data available?
               S01:00000963:  DB 05
F00:0371       	cp 0
               S01:00000965:  FE 00
F00:0372       	jp nz,_1$
               S01:00000967:  C2 77 09
F00:0373       	pop af ;#restore af
               S01:0000096A:  F1
F00:0374       	ld hl,0
               S01:0000096B:  21 00 00
F00:0375       		call println
               S01:0000096E:  CD 93 08
F00:0376       		call sizeloaded
               S01:00000971:  CD B8 09
F00:0377       		ld a,0 ;# use 0 in A to indicate a fail
               S01:00000974:  3E 00
F00:0378       		ret ;#- exit loadheader because the file read had a problem
               S01:00000976:  C9
F00:0379       _1$:
F00:0380       		;// if we get here then there is data to read
F00:0381       		ld a,READNEXTBYTE
               S01:00000977:  3E 05
F00:0382       		out (SDCARD),a ;// read nextbyte
               S01:00000979:  D3 05
F00:0383       		in a,(SDCARD)
               S01:0000097B:  DB 05
F00:0384       		ld (hl),a ; // store byte in RAM (OSLOAD)
               S01:0000097D:  77
F00:0385       		inc hl 
               S01:0000097E:  23
F00:0386       		djnz _2$
               S01:0000097F:  10 DE
F00:0387       		ld a,1 ;# use 1 in A to indicate a success
               S01:00000981:  3E 01
F00:0388       		ret ;# exit loadheader because we have loaded 4 bytes
               S01:00000983:  C9
F00:0389       available:
F00:0390       	#available will return 1 if there is data to read, 0 if no data to read
F00:0391       		ld a, AVAILABLE ; // available
               S01:00000984:  3E 06
F00:0392       		out (SDCARD),a
               S01:00000986:  D3 05
F00:0393       		in a,(SDCARD) ;// read the value from the device
               S01:00000988:  DB 05
F00:0394       	;	ld b,a ; // going to malipulate the a register so save it as not to destroy the A result
F00:0395       	;	add a,'0' ;// make it printable
F00:0396       	;	out (SERIALPORT),a ;// print response
F00:0397       	;	ld a,b
F00:0398       		cp 0 ;// compare the A reg returned by the device
               S01:0000098A:  FE 00
F00:0399       		jp nz,_$nextbyte
               S01:0000098C:  C2 A7 09
F00:0400       		pop af ;# restore the af registers because it will tell me if I need to zero terminate the loaded file
               S01:0000098F:  F1
F00:0401       		cp 1
               S01:00000990:  FE 01
F00:0402       		jp nz,_1$
               S01:00000992:  C2 98 09
F00:0403       		;# the hl register pair contains the last address we need to write a zero here because the user wants it
F00:0404       		ld a,0
               S01:00000995:  3E 00
F00:0405       		ld (hl),a ;# zero terminated
               S01:00000997:  77
F00:0406       
F00:0407       _1$:
F00:0408       		ld hl,0
               S01:00000998:  21 00 00
F00:0409       		call println
               S01:0000099B:  CD 93 08
F00:0410       		call sizeloaded
               S01:0000099E:  CD B8 09
F00:0411       		ld hl,(startaddress) ;# return the startaddress
               S01:000009A1:  2A F4 09
F00:0412       		ld a,0
               S01:000009A4:  3E 00
F00:0413       		ret
               S01:000009A6:  C9
F00:0414       _$nextbyte:
F00:0415       		;// if we get here then there is data to read
F00:0416       		ld a,READNEXTBYTE
               S01:000009A7:  3E 05
F00:0417       		out (SDCARD),a ;// read nextbyte
               S01:000009A9:  D3 05
F00:0418       		in a,(SDCARD)
               S01:000009AB:  DB 05
F00:0419       		ld (hl),a ; // store byte in RAM (OSLOAD)
               S01:000009AD:  77
F00:0420       		inc hl 
               S01:000009AE:  23
F00:0421       		ld a,'#'
               S01:000009AF:  3E 23
F00:0422       		out (SERIALPORT),a ;// just echo it back for now
               S01:000009B1:  D3 01
F00:0423       		call sizeincrement
               S01:000009B3:  CD DA 09
F00:0424       		jr available ;
               S01:000009B6:  18 CC
F00:0425       
F00:0426       sizeloaded:
F00:0427       	push ix
               S01:000009B8:  DD E5
F00:0428       	ld ix,losize
               S01:000009BA:  DD 21 F2 09
F00:0429       	ld e,(ix)
               S01:000009BE:  DD 5E 00
F00:0430       	ld d,(ix+1)
               S01:000009C1:  DD 56 01
F00:0431       	pop ix
               S01:000009C4:  DD E1
F00:0432       	ret
               S01:000009C6:  C9
F00:0433       sizereset:
F00:0434       	push ix
               S01:000009C7:  DD E5
F00:0435       	push af
               S01:000009C9:  F5
F00:0436       	ld a,0
               S01:000009CA:  3E 00
F00:0437       	ld ix,losize
               S01:000009CC:  DD 21 F2 09
F00:0438       	ld (ix),a
               S01:000009D0:  DD 77 00
F00:0439       	ld (ix+1),a
               S01:000009D3:  DD 77 01
F00:0440       	pop af
               S01:000009D6:  F1
F00:0441       	pop ix
               S01:000009D7:  DD E1
F00:0442       	ret
               S01:000009D9:  C9
F00:0443       sizeincrement:
F00:0444       	push ix
               S01:000009DA:  DD E5
F00:0445       	push hl
               S01:000009DC:  E5
F00:0446       
F00:0447       	ld ix,losize
               S01:000009DD:  DD 21 F2 09
F00:0448       	ld l,(ix)
               S01:000009E1:  DD 6E 00
F00:0449       	ld h,(ix+1)
               S01:000009E4:  DD 66 01
F00:0450       	inc HL
               S01:000009E7:  23
F00:0451       	ld (ix),l
               S01:000009E8:  DD 75 00
F00:0452       	ld (ix+1),h
               S01:000009EB:  DD 74 01
F00:0453       
F00:0454       	pop hl
               S01:000009EE:  E1
F00:0455       	pop ix
               S01:000009EF:  DD E1
F00:0456       	ret
               S01:000009F1:  C9
F00:0457       
F00:0458       losize: .byte 0
               S01:000009F2:  00
F00:0459       hisize: .byte 0
               S01:000009F3:  00
F00:0460       
F00:0461       ;# executable header information
F00:0462       startaddress: .2byte 0
               S01:000009F4:  00 00
F00:0463       memorypages: .byte 0
               S01:000009F6:  00
F00:0464       stackpages: .byte 0
               S01:000009F7:  00
F00:0465       ;# ====== hextobyte ==========
F00:0466       ;#    load HL registers with the 2 ascii characters of a hexadecimal value
F00:0467       ;# note routine does not validate the inputs.
F00:0468       ;# alphabeta expected in uppercase
F00:0469       ;#	ld h,'c'
F00:0470       ;#	ld l,'3'
F00:0471       ;#	call hextobyte
F00:0472       ;#	value stored in A register
F00:0473       
F00:0474       
F00:0475       hextobyte:
F00:0476       	push hl
               S01:000009F8:  E5
F00:0477       	push bc
               S01:000009F9:  C5
F00:0478       	ld a,l ;# prepare the low nibble
               S01:000009FA:  7D
F00:0479       	call workhextobyte
               S01:000009FB:  CD 0B 0A
F00:0480       	ld b,a ;# save it later
               S01:000009FE:  47
F00:0481       	ld a,h ;# prepare the high nibble
               S01:000009FF:  7C
F00:0482       	call workhextobyte
               S01:00000A00:  CD 0B 0A
F00:0483       	rla ;# a contains the result from the high nibble
               S01:00000A03:  17
F00:0484       	rla ;# so move the nibble to make room for the low nibble
               S01:00000A04:  17
F00:0485       	rla
               S01:00000A05:  17
F00:0486       	rla
               S01:00000A06:  17
F00:0487       	or b ;# add the low nibble
               S01:00000A07:  B0
F00:0488       
F00:0489       	pop bc
               S01:00000A08:  C1
F00:0490       	pop hl
               S01:00000A09:  E1
F00:0491       	ret
               S01:00000A0A:  C9
F00:0492       workhextobyte:
F00:0493       	cp 'A' ;# alphabeta sub 55
               S01:00000A0B:  FE 41
F00:0494       	jp m,hextobytenumber
               S01:00000A0D:  FA 13 0A
F00:0495       	sub 55
               S01:00000A10:  D6 37
F00:0496       	ret
               S01:00000A12:  C9
F00:0497       hextobytenumber:
F00:0498       	sub 48 ;# if number sub 48
               S01:00000A13:  D6 30
F00:0499       	ret
               S01:00000A15:  C9
F00:0500       
F00:0501       	;# === directory open === #
F00:0502       
F00:0503       directoryopen:
F00:0504       	push af
               S01:00000A16:  F5
F00:0505       	ld a,OPENDIRECTORY
               S01:00000A17:  3E 31
F00:0506       	out (SDCARD),a
               S01:00000A19:  D3 05
F00:0507       	pop af
               S01:00000A1B:  F1
F00:0508       	ret
               S01:00000A1C:  C9
F00:0509       	;# === nextfile === #
F00:0510       nextfile:
F00:0511       	push af
               S01:00000A1D:  F5
F00:0512       	ld a,NEXTFILE
               S01:00000A1E:  3E 32
F00:0513       	out (SDCARD),a
               S01:00000A20:  D3 05
F00:0514       	pop af
               S01:00000A22:  F1
F00:0515       	ret
               S01:00000A23:  C9
F00:0516       	;# === getfilename or currently open file ===#
F00:0517       	;# ld hl,storagelocation - for the filename
F00:0518       	;# call getfilename
F00:0519       
F00:0520       getfilename:
F00:0521       	push af
               S01:00000A24:  F5
F00:0522       	push hl
               S01:00000A25:  E5
F00:0523       	ld a,GETNAME
               S01:00000A26:  3E 20
F00:0524       	out (SDCARD),a
               S01:00000A28:  D3 05
F00:0525       
F00:0526       _getfilename$1:
F00:0527       	ld a,NAMEAVAILABLE
               S01:00000A2A:  3E 21
F00:0528       	out (SDCARD),a
               S01:00000A2C:  D3 05
F00:0529       	in a,(SDCARD)
               S01:00000A2E:  DB 05
F00:0530       	cp 0
               S01:00000A30:  FE 00
F00:0531       	jp z, _exitgetfilename
               S01:00000A32:  CA 3A 0A
F00:0532       
F00:0533       	ld (hl),a
               S01:00000A35:  77
F00:0534       	inc hl
               S01:00000A36:  23
F00:0535       	
F00:0536       	jp _getfilename$1
               S01:00000A37:  C3 2A 0A
F00:0537       
F00:0538       _exitgetfilename:
F00:0539       	ld a,0
               S01:00000A3A:  3E 00
F00:0540       	ld (hl),a
               S01:00000A3C:  77
F00:0541       	pop hl
               S01:00000A3D:  E1
F00:0542       	pop af
               S01:00000A3E:  F1
F00:0543       	ret
               S01:00000A3F:  C9
F00:0544       
F00:0545       	# === createProcess == #
F00:0546       	;# stack - note the example below is using the registers as an example, it really don't matter
F00:0547       	;# which register pair put that data on the stack, the sequence in which the parameters are put on the stack
F00:0548       	;# does matter.
F00:0549       	;# push hl,program - zero terminated
F00:0550       	;# push de,commandline - zero terminated
F00:0551       	;# call createProcess
F00:0552       	;# that should do for now
F00:0553       	createProcess: ;# this is messy need to have another go at this
F00:0554       		ld a,0
               S01:00000A40:  3E 00
F00:0555       		call printhex
               S01:00000A42:  CD CA 08
F00:0556       
F00:0557       		pop hl ;# get the return address
               S01:00000A45:  E1
F00:0558       		exx ;# exchange with other registers
               S01:00000A46:  D9
F00:0559       
F00:0560       
F00:0561       		ld de,theparams
               S01:00000A47:  11 D0 0A
F00:0562       		;# copy the command params
F00:0563       		pop hl ;# get the command params
               S01:00000A4A:  E1
F00:0564       		ld a,1
               S01:00000A4B:  3E 01
F00:0565       		call printhex
               S01:00000A4D:  CD CA 08
F00:0566       
F00:0567       		call strcpy
               S01:00000A50:  CD 68 08
F00:0568       		ld a,2
               S01:00000A53:  3E 02
F00:0569       		call printhex
               S01:00000A55:  CD CA 08
F00:0570       		push hl
               S01:00000A58:  E5
F00:0571       		ld hl,thecommandlinemsg
               S01:00000A59:  21 C8 0A
F00:0572       		call println
               S01:00000A5C:  CD 93 08
F00:0573       		pop hl
               S01:00000A5F:  E1
F00:0574       		call println ;# print command params
               S01:00000A60:  CD 93 08
F00:0575       
F00:0576       		ld a,3
               S01:00000A63:  3E 03
F00:0577       		call printhex
               S01:00000A65:  CD CA 08
F00:0578       
F00:0579       		pop hl ;# get the program
               S01:00000A68:  E1
F00:0580       		push HL
               S01:00000A69:  E5
F00:0581       		ld hl,theprocessmsg
               S01:00000A6A:  21 BF 0A
F00:0582       		call println
               S01:00000A6D:  CD 93 08
F00:0583       		pop hl
               S01:00000A70:  E1
F00:0584       		call println ;# print program name
               S01:00000A71:  CD 93 08
F00:0585       #		ld de,userMemory
F00:0586       		ld a,0
               S01:00000A74:  3E 00
F00:0587       		ld d,a ;# use dynamic load address if possible
               S01:00000A76:  57
F00:0588       		ld e,a
               S01:00000A77:  5F
F00:0589       		ld a,4
               S01:00000A78:  3E 04
F00:0590       		call printhex
               S01:00000A7A:  CD CA 08
F00:0591       #pih 12/29/2020
F00:0592       		call copyprogramname
               S01:00000A7D:  CD B4 0A
F00:0593       		call loadFILE
               S01:00000A80:  CD E3 08
F00:0594       		cp 0
               S01:00000A83:  FE 00
F00:0595       		jp nz, _createProcesserr$1
               S01:00000A85:  C2 AF 0A
F00:0596       		ld (_progloadaddr),hl ;# save the address the program was loaded into. if null is means use the default userMemory
               S01:00000A88:  22 AD 0A
F00:0597       		
F00:0598       		exx ;# restore the other original registers
               S01:00000A8B:  D9
F00:0599       		push hl ; # restore the return address
               S01:00000A8C:  E5
F00:0600       		# test if we need to use the default address or the program/library supplied address
F00:0601       		# we can do that by checking if the hl pair is null, null = use fault, not null = custom address
F00:0602       		ld hl,(_progloadaddr)
               S01:00000A8D:  2A AD 0A
F00:0603       		ld a,h
               S01:00000A90:  7C
F00:0604       		cp 0
               S01:00000A91:  FE 00
F00:0605       		jp nz, _4$
               S01:00000A93:  C2 A2 0A
F00:0606       		ld a,l
               S01:00000A96:  7D
F00:0607       		cp 0
               S01:00000A97:  FE 00
F00:0608       		jp nz,_4$
               S01:00000A99:  C2 A2 0A
F00:0609       		# hl was null so call the default address
F00:0610       		#pih call printhexL
F00:0611       				### CREATENEWPROCESSINFO
F00:0612       		# just for the fun of it,lets write usermemory into progloadaddr and reuse the dynamic address code
F00:0613       		ld hl,userMemory
               S01:00000A9C:  21 00 30
F00:0614       		ld (_progloadaddr),hl
               S01:00000A9F:  22 AD 0A
F00:0615       		#pih call createnewprocessinfo
F00:0616       		#pih call userMemory
F00:0617       		
F00:0618       		# pih ret
F00:0619       _4$:
F00:0620       	call printhexL
               S01:00000AA2:  CD BD 08
F00:0621       		### CREATENEWPROCESSINFO
F00:0622       		call createnewprocessinfo
               S01:00000AA5:  CD 06 0B
F00:0623       	call progloadaddress
               S01:00000AA8:  CD AC 0A
F00:0624       	ret
               S01:00000AAB:  C9
F00:0625       progloadaddress: .byte 0xc3
               S01:00000AAC:  C3
F00:0626       	_progloadaddr: .2byte 0
               S01:00000AAD:  00 00
F00:0627       
F00:0628       
F00:0629       
F00:0630       _createProcesserr$1:
F00:0631       		push af
               S01:00000AAF:  F5
F00:0632       		exx ;# restore the other original registers
               S01:00000AB0:  D9
F00:0633       		pop af
               S01:00000AB1:  F1
F00:0634       		push hl ; # restore the return address
               S01:00000AB2:  E5
F00:0635       		ret
               S01:00000AB3:  C9
F00:0636       
F00:0637       # helper function to copy the program name into procname , which is used to update the processinfo
F00:0638       copyprogramname:
F00:0639       	push de
               S01:00000AB4:  D5
F00:0640       	push hl
               S01:00000AB5:  E5
F00:0641       	ld de,procname
               S01:00000AB6:  11 37 0C
F00:0642       	call strcpy
               S01:00000AB9:  CD 68 08
F00:0643       	pop hl
               S01:00000ABC:  E1
F00:0644       	pop de
               S01:00000ABD:  D1
F00:0645       ret
               S01:00000ABE:  C9
F00:0646       
F00:0647       theprocessmsg: .string "process:"
               S01:00000ABF:  70 72 6F 63 65 73 73 3A
F00:0648       thecommandlinemsg: .string "params:"
               S01:00000AC8:  70 61 72 61 6D 73 3A
F00:0649       theparams: .space 50
F00:0650       
F00:0651       ;# === specialfunction this is called by the just lauched program, it allows the program to get it's processid
F00:0652       setprocid:
F00:0653       	ld a,(lastprogramid)
               S01:00000B02:  3A 41 0C
F00:0654       	ret
               S01:00000B05:  C9
F00:0655       
F00:0656       #== createnewprocessinfo ===#
F00:0657       # variable procname is expected to be populated
F00:0658       # variable _progloadaddr contains the program address
F00:0659       # return 
F00:0660       
F00:0661       createnewprocessinfo:
F00:0662       	push af
               S01:00000B06:  F5
F00:0663       	push hl
               S01:00000B07:  E5
F00:0664       	push bc
               S01:00000B08:  C5
F00:0665       	push de  ;#just do everything for now - need to look and fix this
               S01:00000B09:  D5
F00:0666       	call getnewprocessid
               S01:00000B0A:  CD 57 0B
F00:0667       	call writeprocessinfo
               S01:00000B0D:  CD 93 0B
F00:0668       	pop de
               S01:00000B10:  D1
F00:0669       	pop bc
               S01:00000B11:  C1
F00:0670       	pop hl
               S01:00000B12:  E1
F00:0671       	pop af
               S01:00000B13:  F1
F00:0672       ret
               S01:00000B14:  C9
F00:0673       
F00:0674       
F00:0675       #== startprocessinfo ==#
F00:0676       # reset the process info list pointer
F00:0677       # no inputs, no outputs
F00:0678       startprocessinfo: 
F00:0679       	push af
               S01:00000B15:  F5
F00:0680       	ld a,0
               S01:00000B16:  3E 00
F00:0681       	ld (currentprocessinfo),a
               S01:00000B18:  32 43 0C
F00:0682       	pop af
               S01:00000B1B:  F1
F00:0683       	ret
               S01:00000B1C:  C9
F00:0684       
F00:0685       #== nextprocessinfo ===#
F00:0686       # return in hl the next processinfo entry
F00:0687       # also updates currentprocessinfo
F00:0688       # if carry flag set, we have reach the end of the process table
F00:0689       nextprocessinfo:
F00:0690       	push af
               S01:00000B1D:  F5
F00:0691       	ld a,(currentprocessinfo)
               S01:00000B1E:  3A 43 0C
F00:0692       	ld h,a
               S01:00000B21:  67
F00:0693       	ld e,PROCINFOSIZE
               S01:00000B22:  1E 08
F00:0694       	call Mul8b
               S01:00000B24:  CD E7 0C
F00:0695       	ex de,hl
               S01:00000B27:  EB
F00:0696       	ld hl,processtable
               S01:00000B28:  21 44 0C
F00:0697       	add hl,DE
               S01:00000B2B:  19
F00:0698       	inc a
               S01:00000B2C:  3C
F00:0699       	cp MAXPROCESSES
               S01:00000B2D:  FE 04
F00:0700       	jp p, 1$ ;# if we go passed the limit reset back to 0
               S01:00000B2F:  F2 39 0B
F00:0701       	ld (currentprocessinfo),a
               S01:00000B32:  32 43 0C
F00:0702       	pop af
               S01:00000B35:  F1
F00:0703       	scf ;# set cf
               S01:00000B36:  37
F00:0704       	ccf ;# invert cf  - more process info's available so return with carry flag not set
               S01:00000B37:  3F
F00:0705       	ret
               S01:00000B38:  C9
F00:0706       1$: ;# if reach maxprocesses, return 0 in a & hl
F00:0707       	ld a,0
               S01:00000B39:  3E 00
F00:0708       	ld (currentprocessinfo),a
               S01:00000B3B:  32 43 0C
F00:0709       	ld h,a
               S01:00000B3E:  67
F00:0710       	ld l,a
               S01:00000B3F:  6F
F00:0711       	pop af
               S01:00000B40:  F1
F00:0712       	scf ;# set carry flag  - if no more process return with carry flag set
               S01:00000B41:  37
F00:0713       	ret
               S01:00000B42:  C9
F00:0714       
F00:0715       #=== getprocessslot ===#
F00:0716       ;# return the first available slot in hl
F00:0717       ;# a slot is occuppied if the processid is not zero. this routine will locate the first unoccuppied slot
F00:0718       ;# A register returns status where 0=no slots , 1=slot available
F00:0719       ;# if carry flag set, a slot was found
F00:0720       ;# if carry flag not set, it did not find an empty slot
F00:0721       getprocessslot:
F00:0722       	call startprocessinfo
               S01:00000B43:  CD 15 0B
F00:0723       2$:
F00:0724       #	DEBUG '*'
F00:0725       #	PRINTLN
F00:0726       	call nextprocessinfo ;
               S01:00000B46:  CD 1D 0B
F00:0727       	jp c,1$ ;# if carry flag set, we reached the end
               S01:00000B49:  DA 54 0B
F00:0728       	ld a,(hl)
               S01:00000B4C:  7E
F00:0729       #	call printhex
F00:0730       #	call printhexL
F00:0731       	cp 0 ;# compare processids
               S01:00000B4D:  FE 00
F00:0732       	jp nz, 2$   ;# we are looking for a zero processid, which means it's an empty slot
               S01:00000B4F:  C2 46 0B
F00:0733       	#ld hl,didfind
F00:0734       	#call println
F00:0735       #	ld a,1
F00:0736       	scf ;#did find return set carry flag
               S01:00000B52:  37
F00:0737       	ret ;# found
               S01:00000B53:  C9
F00:0738       
F00:0739       1$: ;# not found
F00:0740       	#ld hl,notfound
F00:0741       	#call println
F00:0742       #	ld a,0
F00:0743       	scf ;# did not find return unset carry flag
               S01:00000B54:  37
F00:0744       	ccf
               S01:00000B55:  3F
F00:0745       ret
               S01:00000B56:  C9
F00:0746       
F00:0747       ;#=== getnewprocessid ===#
F00:0748       ;# return set the next available processsid in lastprogramid variable
F00:0749       ;# this processid is unique, it cannot be 0
F00:0750       
F00:0751       getnewprocessid:
F00:0752       	push af
               S01:00000B57:  F5
F00:0753       	push hl
               S01:00000B58:  E5
F00:0754       	push bc
               S01:00000B59:  C5
F00:0755       
F00:0756       1$: ;#; increment the number thats already there (lastprogramid),  repeat if zero
F00:0757       	DEBUG '!'
F07:0001       # example : DEBUG '!'
F07:0002       #      or : DEBUG h
F07:0003       		push af
               S01:00000B5A:  F5
F07:0004       		ld a,33
               S01:00000B5B:  3E 21
F07:0005       		call putc
               S01:00000B5D:  CD E0 08
F07:0006       		pop af
               S01:00000B60:  F1
F00:0758       	ld hl,lastprogramid
               S01:00000B61:  21 41 0C
F00:0759       	inc (hl)
               S01:00000B64:  34
F00:0760       	ld a,(lastprogramid) ;
               S01:00000B65:  3A 41 0C
F00:0761       	ld c,0
               S01:00000B68:  0E 00
F00:0762       	cp c
               S01:00000B6A:  B9
F00:0763       	jp z,1$:
               S01:00000B6B:  CA 5A 0B
F00:0764       	ld c,a ;# move new id into c register,# keep if in C register we will use it later
               S01:00000B6E:  4F
F00:0765       	call startprocessinfo
               S01:00000B6F:  CD 15 0B
F00:0766       2$: DEBUG '@'
F08:0001       # example : DEBUG '!'
F08:0002       #      or : DEBUG h
F08:0003       		push af
               S01:00000B72:  F5
F08:0004       		ld a,64
               S01:00000B73:  3E 40
F08:0005       		call putc
               S01:00000B75:  CD E0 08
F08:0006       		pop af
               S01:00000B78:  F1
F00:0767       	call nextprocessinfo
               S01:00000B79:  CD 1D 0B
F00:0768       	jp c,3$ ;# if carry flag set, we reach the end
               S01:00000B7C:  DA 88 0B
F00:0769       	inc hl ;# advance to the process id
               S01:00000B7F:  23
F00:0770       	ld a,(hl)
               S01:00000B80:  7E
F00:0771       	cp c
               S01:00000B81:  B9
F00:0772       	jp nz,2$ ;# repeat after incrementing the number again
               S01:00000B82:  C2 72 0B
F00:0773       	jp 1$ ;# get the next processinfo item
               S01:00000B85:  C3 5A 0B
F00:0774       3$:
F00:0775       	DEBUG '#'
F09:0001       # example : DEBUG '!'
F09:0002       #      or : DEBUG h
F09:0003       		push af
               S01:00000B88:  F5
F09:0004       		ld a,35
               S01:00000B89:  3E 23
F09:0005       		call putc
               S01:00000B8B:  CD E0 08
F09:0006       		pop af
               S01:00000B8E:  F1
F00:0776       	pop bc
               S01:00000B8F:  C1
F00:0777       	pop hl
               S01:00000B90:  E1
F00:0778       	pop af
               S01:00000B91:  F1
F00:0779       ret
               S01:00000B92:  C9
F00:0780       
F00:0781       writeprocessinfo:
F00:0782       # prerequisties : lastprogramid has the programid set 
F00:0783       #               variable   procname: contains the name of the program 
F00:0784       	call getprocessslot
               S01:00000B93:  CD 43 0B
F00:0785       	jp nc, failed
               S01:00000B96:  D2 BE 0B
F00:0786       #call printhexL
F00:0787       #PRINTLN
F00:0788       	ld a,'R' ;# process is running
               S01:00000B99:  3E 52
F00:0789       	ld (hl),a ;# byte position 1
               S01:00000B9B:  77
F00:0790       	inc hl
               S01:00000B9C:  23
F00:0791       	ld a,(lastprogramid) ;# it is required this variable is set to the correct id before running this routine
               S01:00000B9D:  3A 41 0C
F00:0792       	ld (hl),a ;# byte position 2
               S01:00000BA0:  77
F00:0793       	inc hl
               S01:00000BA1:  23
F00:0794       #call printhexL
F00:0795       #PRINTLN
F00:0796       	push hl ;# save it
               S01:00000BA2:  E5
F00:0797       	ld de,procname
               S01:00000BA3:  11 37 0C
F00:0798       	ex de,hl
               S01:00000BA6:  EB
F00:0799       #call printhexL
F00:0800       #call println
F00:0801       	ld c,4    ;# byte positions 3 , 4 , 5 ,6
               S01:00000BA7:  0E 04
F00:0802       	ld b,0
               S01:00000BA9:  06 00
F00:0803       	call strncpy ;# problem needs addressing: if the program name is < 4 bytes the copy will more than needed.
               S01:00000BAB:  CD 65 08
F00:0804       					;# we need a strncpy that stops on a null byte
F00:0805       	
F00:0806       	pop hl
               S01:00000BAE:  E1
F00:0807       	inc hl
               S01:00000BAF:  23
F00:0808       	inc hl
               S01:00000BB0:  23
F00:0809       	inc hl
               S01:00000BB1:  23
F00:0810       	inc hl ;# advance hl to account for the 4 bytes to copy the process name
               S01:00000BB2:  23
F00:0811       	ld de,(_progloadaddr)
               S01:00000BB3:  ED 5B AD 0A
F00:0812       	ld (hl),d   ;# byte position 7
               S01:00000BB7:  72
F00:0813       	inc hl
               S01:00000BB8:  23
F00:0814       	ld (hl),e   ;# byte position 8
               S01:00000BB9:  73
F00:0815       	inc hl ;# ready for the next byte position
               S01:00000BBA:  23
F00:0816       	ld a, 0
               S01:00000BBB:  3E 00
F00:0817       	ret
               S01:00000BBD:  C9
F00:0818       
F00:0819       failed:
F00:0820       	ld hl,errormsg
               S01:00000BBE:  21 C7 0B
F00:0821       	call println
               S01:00000BC1:  CD 93 08
F00:0822       	ld a,0
               S01:00000BC4:  3E 00
F00:0823       	ret 
               S01:00000BC6:  C9
F00:0824       
F00:0825       errormsg: .string "could not find an empty slot, maximum number of processes running\r\n"
               S01:00000BC7:  63 6F 75 6C 64 20 6E 6F 74 20 66 69 6E 64 20 61
               S01:00000BD7:  6E 20 65 6D 70 74 79 20 73 6C 6F 74 2C 20 6D 61
F00:0826       
F00:0827       #==== getprocessbyid ==#
F00:0828       # ld a,id
F00:0829       # call getprocessbyid
F00:0830       # cp 1             - returns in A : 0 = not found, 1 = found
F00:0831       # jp z,we succeeded
F00:0832       getprocessbyid:
F00:0833       
F00:0834       	call startprocessinfo
               S01:00000C0B:  CD 15 0B
F00:0835       2$:
F00:0836       
F00:0837       	call nextprocessinfo ;
               S01:00000C0E:  CD 1D 0B
F00:0838       	jp c,1$ ;# if carry flag set, we reached the end
               S01:00000C11:  DA 21 0C
F00:0839       	push hl
               S01:00000C14:  E5
F00:0840       	pop ix
               S01:00000C15:  DD E1
F00:0841       	ld b,(ix+1)
               S01:00000C17:  DD 46 01
F00:0842       	cp b ;# compare processids
               S01:00000C1A:  B8
F00:0843       	jp nz, 2$
               S01:00000C1B:  C2 0E 0C
F00:0844       	ld a,1
               S01:00000C1E:  3E 01
F00:0845       	ret ;# found
               S01:00000C20:  C9
F00:0846       
F00:0847       1$: ;# not found
F00:0848       	ld a,0
               S01:00000C21:  3E 00
F00:0849       ret
               S01:00000C23:  C9
F00:0850       
F00:0851       ;# A = processid to delete
F00:0852       deleteprocessbyid:
F00:0853       push af
               S01:00000C24:  F5
F00:0854       	call getprocessbyid
               S01:00000C25:  CD 0B 0C
F00:0855       	cp 1 ;# 1 = we found the process
               S01:00000C28:  FE 01
F00:0856       	jp nz,1$
               S01:00000C2A:  C2 35 0C
F00:0857       	ld b,PROCINFOSIZE
               S01:00000C2D:  06 08
F00:0858       	ld a,0
               S01:00000C2F:  3E 00
F00:0859       0$: ld (hl),a
               S01:00000C31:  77
F00:0860       	inc hl
               S01:00000C32:  23
F00:0861       	djnz 0$
               S01:00000C33:  10 FC
F00:0862       
F00:0863       1$:
F00:0864       pop af
               S01:00000C35:  F1
F00:0865       ret 
               S01:00000C36:  C9
F00:0866       
F00:0867       procname: .space 10 ;# space for the processname, but we really only need 4 or 4+1
F00:0868       lastprogramid: .byte 0
               S01:00000C41:  00
F00:0869       maxprocesses: .byte MAXPROCESSES
               S01:00000C42:  04
F00:0870       currentprocessinfo: .byte 0; # index to a process table entry
               S01:00000C43:  00
F00:0871       processtable: 
F00:0872       	;# 1byte process status - 1=running, 0=no process
F00:0873       	;# 1byte processID
F00:0874       	;# 4bytes process name
F00:0875       .rept MAXPROCESSES
F00:0877       
F10:0001       	.space PROCINFOSIZE
F10:0001       	.space PROCINFOSIZE
F10:0001       	.space PROCINFOSIZE
F10:0001       	.space PROCINFOSIZE
F00:0878       endprocesstable: ;# this does nothing and can be deleted. I'm using it to check the listing address
F00:0879       
F00:0880       	# === getcommandparams == #
F00:0881       	;# ld hl,buffer - address of where to copy the data
F00:0882       	;# call getcommandparams
F00:0883       	;# returns zero termined string at buffer 
F00:0884       getcommandparams:
F00:0885       	push de
               S01:00000C64:  D5
F00:0886       	push hl
               S01:00000C65:  E5
F00:0887       	push hl ;# save hl to move into de
               S01:00000C66:  E5
F00:0888       	pop de ;# load hl into de
               S01:00000C67:  D1
F00:0889       #	ld hl,userMemory-50   ;# ********* I dont remember why I did this, it needs investigating
F00:0890       	ld hl,theparams
               S01:00000C68:  21 D0 0A
F00:0891       	call strcpy
               S01:00000C6B:  CD 68 08
F00:0892       	pop hl
               S01:00000C6E:  E1
F00:0893       	pop de
               S01:00000C6F:  D1
F00:0894       	ret
               S01:00000C70:  C9
F00:0895       
F00:0896       ;# ================ getmalloctable ======#
F00:0897       	getmalloctable:
F00:0898       		ld hl,malloctable
               S01:00000C71:  21 00 0F
F00:0899       		ret
               S01:00000C74:  C9
F00:0900       
F00:0901       ;# ====== reserve memory alloc table entry ===#
F00:0902       
F00:0903       	reservemalloc:
F00:0904       		push bc
               S01:00000C75:  C5
F00:0905       		push af
               S01:00000C76:  F5
F00:0906       		ld b,1
               S01:00000C77:  06 01
F00:0907       		call setresetpage
               S01:00000C79:  CD 7F 0C
F00:0908       		pop af
               S01:00000C7C:  F1
F00:0909       		pop bc
               S01:00000C7D:  C1
F00:0910       	ret
               S01:00000C7E:  C9
F00:0911       ;# ======= setresetpage - memory alloc table management ===#
F00:0912       setresetpage:
F00:0913       ;# ld a, page
F00:0914       ;# ld b, setorreset , 0 = reset, 1 = set
F00:0915       		push hl
               S01:00000C7F:  E5
F00:0916       		push bc
               S01:00000C80:  C5
F00:0917       		push af
               S01:00000C81:  F5
F00:0918       	
F00:0919       		
F00:0920       		DEBUG '@'
F11:0001       # example : DEBUG '!'
F11:0002       #      or : DEBUG h
F11:0003       		push af
               S01:00000C82:  F5
F11:0004       		ld a,64
               S01:00000C83:  3E 40
F11:0005       		call putc
               S01:00000C85:  CD E0 08
F11:0006       		pop af
               S01:00000C88:  F1
F00:0921       
F00:0922       		call getmallocrelativebase
               S01:00000C89:  CD B9 0C
F00:0923       
F00:0924       		DEBUG '%'
F12:0001       # example : DEBUG '!'
F12:0002       #      or : DEBUG h
F12:0003       		push af
               S01:00000C8C:  F5
F12:0004       		ld a,37
               S01:00000C8D:  3E 25
F12:0005       		call putc
               S01:00000C8F:  CD E0 08
F12:0006       		pop af
               S01:00000C92:  F1
F00:0925       		pop af
               S01:00000C93:  F1
F00:0926       		and 0x0f
               S01:00000C94:  E6 0F
F00:0927       		cp 8
               S01:00000C96:  FE 08
F00:0928       		jp m,1$
               S01:00000C98:  FA 9E 0C
F00:0929       		inc hl
               S01:00000C9B:  23
F00:0930       		sub 8
               S01:00000C9C:  D6 08
F00:0931       1$:
F00:0932       	
F00:0933       		ld b,a
               S01:00000C9E:  47
F00:0934       		inc b
               S01:00000C9F:  04
F00:0935       		scf
               S01:00000CA0:  37
F00:0936       		ld a,0
               S01:00000CA1:  3E 00
F00:0937       
F00:0938       2$:		rra 	
               S01:00000CA3:  1F
F00:0939       		djnz 2$
               S01:00000CA4:  10 FD
F00:0940       		pop bc
               S01:00000CA6:  C1
F00:0941       
F00:0942       		push af
               S01:00000CA7:  F5
F00:0943       		ld a,b
               S01:00000CA8:  78
F00:0944       		cp 0
               S01:00000CA9:  FE 00
F00:0945       		jp z,6$
               S01:00000CAB:  CA B3 0C
F00:0946       ;# set
F00:0947       		pop af
               S01:00000CAE:  F1
F00:0948       		or (hl)
               S01:00000CAF:  B6
F00:0949       		jp 4$
               S01:00000CB0:  C3 B6 0C
F00:0950       
F00:0951       ;# reset
F00:0952       6$:		pop af
               S01:00000CB3:  F1
F00:0953       		cpl
               S01:00000CB4:  2F
F00:0954       		and (hl)
               S01:00000CB5:  A6
F00:0955       
F00:0956       4$:
F00:0957       		ld (hl),a
               S01:00000CB6:  77
F00:0958       		pop hl
               S01:00000CB7:  E1
F00:0959       		ret
               S01:00000CB8:  C9
F00:0960       
F00:0961       getmallocrelativebase:
F00:0962       ;# ld a,page
F00:0963       ;# call getmallocrelativebase
F00:0964       ;# return in hl = malloctable address adjusted for page
F00:0965       	push de
               S01:00000CB9:  D5
F00:0966       		and 0xf0
               S01:00000CBA:  E6 F0
F00:0967       
F00:0968       		ld l,a
               S01:00000CBC:  6F
F00:0969       		ld h,0
               S01:00000CBD:  26 00
F00:0970       		ld d,8
               S01:00000CBF:  16 08
F00:0971       		call Div8
               S01:00000CC1:  CD D9 0C
F00:0972       
F00:0973       		ex de,hl
               S01:00000CC4:  EB
F00:0974       		#.byte 0xeb
F00:0975       
F00:0976       		DEBUG '!'
F13:0001       # example : DEBUG '!'
F13:0002       #      or : DEBUG h
F13:0003       		push af
               S01:00000CC5:  F5
F13:0004       		ld a,33
               S01:00000CC6:  3E 21
F13:0005       		call putc
               S01:00000CC8:  CD E0 08
F13:0006       		pop af
               S01:00000CCB:  F1
F00:0977       
F00:0978       		call getmalloctable
               S01:00000CCC:  CD 71 0C
F00:0979       		DEBUG '^'
F14:0001       # example : DEBUG '!'
F14:0002       #      or : DEBUG h
F14:0003       		push af
               S01:00000CCF:  F5
F14:0004       		ld a,94
               S01:00000CD0:  3E 5E
F14:0005       		call putc
               S01:00000CD2:  CD E0 08
F14:0006       		pop af
               S01:00000CD5:  F1
F00:0980       		add hl,de
               S01:00000CD6:  19
F00:0981       		pop de
               S01:00000CD7:  D1
F00:0982       		ret
               S01:00000CD8:  C9
F00:0983       
F00:0984       
F00:0985       
F00:0986       ;# ========== Div8 8bit division =======#
F00:0987       ;# http://tutorials.eeems.ca/Z80ASM/part4.htm#div8
F00:0988       ;# result stored in HL
F00:0989       ;# ld hl,4
F00:0990       ;# ld d,2
F00:0991       ;# call Div8
F00:0992       Div8:                            ; this routine performs the operation HL=HL/D
F00:0993         xor a                          ; clearing the upper 8 bits of AHL
               S01:00000CD9:  AF
F00:0994         ld b,16                        ; the length of the dividend (16 bits)
               S01:00000CDA:  06 10
F00:0995       Div8Loop:
F00:0996         add hl,hl                      ; advancing a bit
               S01:00000CDC:  29
F00:0997         rla
               S01:00000CDD:  17
F00:0998         cp d                           ; checking if the divisor divides the digits chosen (in A)
               S01:00000CDE:  BA
F00:0999         jp c,Div8NextBit               ; if not, advancing without subtraction
               S01:00000CDF:  DA E4 0C
F00:1000         sub d                          ; subtracting the divisor
               S01:00000CE2:  92
F00:1001         inc l                          ; and setting the next digit of the quotient
               S01:00000CE3:  2C
F00:1002       Div8NextBit:
F00:1003         djnz Div8Loop
               S01:00000CE4:  10 F6
F00:1004         ret
               S01:00000CE6:  C9
F00:1005       
F00:1006         # ===== Mul8b 8bit multily ===#
F00:1007         # http://tutorials.eeems.ca/Z80ASM/part4.htm
F00:1008         Mul8b:                           ; this routine performs the operation HL=H*E
F00:1009         ld d,0                         ; clearing D and L
               S01:00000CE7:  16 00
F00:1010         ld l,d
               S01:00000CE9:  6A
F00:1011         ld b,8                         ; we have 8 bits
               S01:00000CEA:  06 08
F00:1012       Mul8bLoop:
F00:1013         add hl,hl                      ; advancing a bit
               S01:00000CEC:  29
F00:1014         jp nc,Mul8bSkip                ; if zero, we skip the addition (jp is used for speed)
               S01:00000CED:  D2 F1 0C
F00:1015         add hl,de                      ; adding to the product if necessary
               S01:00000CF0:  19
F00:1016       Mul8bSkip:
F00:1017         djnz Mul8bLoop
               S01:00000CF1:  10 F9
F00:1018         ret
               S01:00000CF3:  C9
F00:1019       
F00:1020       ;================================
F00:1021       ; # === loadaddress == #   THIS NEEDS CHANGING INTO A LOOKUP TABLE - not code
F00:1022       ; ld a,x - where x = instruction id
F00:1023       ;				id = 1, print
F00:1024       ;					 2, printhex
F00:1025       ;					3,loadFILE
F00:1026       loadaddress:
F00:1027       	cp PRINT
               S01:00000CF4:  FE 01
F00:1028       	jp nz,_loadaddress$2
               S01:00000CF6:  C2 FD 0C
F00:1029       	ld hl,print
               S01:00000CF9:  21 A1 08
F00:1030       	ret
               S01:00000CFC:  C9
F00:1031       _loadaddress$2:
F00:1032       	cp PRINTHEX
               S01:00000CFD:  FE 02
F00:1033       	jp nz,_loadaddress$3
               S01:00000CFF:  C2 06 0D
F00:1034       	ld hl,printhex
               S01:00000D02:  21 CA 08
F00:1035       	ret
               S01:00000D05:  C9
F00:1036       _loadaddress$3:
F00:1037       	cp LOADFILE
               S01:00000D06:  FE 03
F00:1038       	jp nz,_loadaddress$4
               S01:00000D08:  C2 0F 0D
F00:1039       	ld hl,loadFILE
               S01:00000D0B:  21 E3 08
F00:1040       	ret
               S01:00000D0E:  C9
F00:1041       _loadaddress$4:
F00:1042       	cp MEMSET
               S01:00000D0F:  FE 04
F00:1043       	jp nz,_loadaddress$5
               S01:00000D11:  C2 18 0D
F00:1044       	ld hl,memset
               S01:00000D14:  21 4A 08
F00:1045       	ret
               S01:00000D17:  C9
F00:1046       _loadaddress$5:
F00:1047       	cp STRLEN
               S01:00000D18:  FE 05
F00:1048       	jp nz,_loadaddress$6
               S01:00000D1A:  C2 21 0D
F00:1049       	ld hl,strlen
               S01:00000D1D:  21 53 08
F00:1050       	ret
               S01:00000D20:  C9
F00:1051       _loadaddress$6:
F00:1052       	cp PUTC
               S01:00000D21:  FE 06
F00:1053       	jp nz,_loadaddress$7
               S01:00000D23:  C2 2A 0D
F00:1054       	ld hl,putc
               S01:00000D26:  21 E0 08
F00:1055       	ret
               S01:00000D29:  C9
F00:1056       _loadaddress$7:
F00:1057       	cp TOUPPERCASE
               S01:00000D2A:  FE 07
F00:1058       	jp nz,_loadaddress$8
               S01:00000D2C:  C2 33 0D
F00:1059       	ld hl,touppercase
               S01:00000D2F:  21 7B 08
F00:1060       	ret
               S01:00000D32:  C9
F00:1061       _loadaddress$8:
F00:1062       	cp HEXTOBYTE
               S01:00000D33:  FE 08
F00:1063       	jp nz,_loadaddress$9
               S01:00000D35:  C2 3C 0D
F00:1064       	ld hl,hextobyte
               S01:00000D38:  21 F8 09
F00:1065       	ret
               S01:00000D3B:  C9
F00:1066       _loadaddress$9:
F00:1067       	cp PRINTLN
               S01:00000D3C:  FE 09
F00:1068       	jp nz,_loadaddress$10
               S01:00000D3E:  C2 45 0D
F00:1069       	ld hl,println
               S01:00000D41:  21 93 08
F00:1070       	ret
               S01:00000D44:  C9
F00:1071       _loadaddress$10:
F00:1072       	cp STRNCPY
               S01:00000D45:  FE 0A
F00:1073       	jp nz,_loadaddress$11
               S01:00000D47:  C2 4E 0D
F00:1074       	ld hl,strncpy
               S01:00000D4A:  21 65 08
F00:1075       	ret
               S01:00000D4D:  C9
F00:1076       _loadaddress$11:
F00:1077       	cp DIRECTORYOPEN
               S01:00000D4E:  FE 0D
F00:1078       	jp nz,_loadaddress$12
               S01:00000D50:  C2 57 0D
F00:1079       	ld hl,directoryopen
               S01:00000D53:  21 16 0A
F00:1080       	ret
               S01:00000D56:  C9
F00:1081       _loadaddress$12:
F00:1082       	cp GETFILENAME:
               S01:00000D57:  FE 0F
F00:1083       	jp nz,_loadaddress$13
               S01:00000D59:  C2 60 0D
F00:1084       	ld hl,getfilename
               S01:00000D5C:  21 24 0A
F00:1085       	ret
               S01:00000D5F:  C9
F00:1086       _loadaddress$13:
F00:1087       	cp NEXTFILE
               S01:00000D60:  FE 32
F00:1088       	jp nz,_loadaddress$14
               S01:00000D62:  C2 69 0D
F00:1089       	ld hl,nextfile
               S01:00000D65:  21 1D 0A
F00:1090       	ret
               S01:00000D68:  C9
F00:1091       _loadaddress$14:
F00:1092       	cp CREATEPROCESS
               S01:00000D69:  FE 10
F00:1093       	jp nz,_loadaddress$15
               S01:00000D6B:  C2 72 0D
F00:1094       	ld hl,createProcess
               S01:00000D6E:  21 40 0A
F00:1095       	ret
               S01:00000D71:  C9
F00:1096       _loadaddress$15:
F00:1097       	cp GETCOMMANDPARAMS
               S01:00000D72:  FE 11
F00:1098       	jp nz,_loadaddress$16
               S01:00000D74:  C2 7B 0D
F00:1099       	ld hl,getcommandparams
               S01:00000D77:  21 64 0C
F00:1100       	ret
               S01:00000D7A:  C9
F00:1101       _loadaddress$16:
F00:1102       	cp GETMALLOCTABLE
               S01:00000D7B:  FE 12
F00:1103       	jp nz,_loadaddress$17
               S01:00000D7D:  C2 84 0D
F00:1104       	ld hl,getmalloctable
               S01:00000D80:  21 71 0C
F00:1105       	ret
               S01:00000D83:  C9
F00:1106       _loadaddress$17:
F00:1107       	cp DIV8
               S01:00000D84:  FE 13
F00:1108       	jp nz,_loadaddress18$
               S01:00000D86:  C2 8D 0D
F00:1109       	ld hl,Div8
               S01:00000D89:  21 D9 0C
F00:1110       	ret
               S01:00000D8C:  C9
F00:1111       _loadaddress18$:
F00:1112       	cp SETRESETPAGE
               S01:00000D8D:  FE 14
F00:1113       	jp nz,_loadaddress19$
               S01:00000D8F:  C2 96 0D
F00:1114       	ld hl,setresetpage
               S01:00000D92:  21 7F 0C
F00:1115       	ret
               S01:00000D95:  C9
F00:1116       _loadaddress19$:
F00:1117       	cp PRINTHEXL
               S01:00000D96:  FE 15
F00:1118       	jp nz,_loadaddress20$
               S01:00000D98:  C2 9F 0D
F00:1119       	ld hl,printhexL
               S01:00000D9B:  21 BD 08
F00:1120       	ret
               S01:00000D9E:  C9
F00:1121       _loadaddress20$:
F00:1122       	cp STARTPROCESSINFO
               S01:00000D9F:  FE 16
F00:1123       	jp nz,_loadaddress21$
               S01:00000DA1:  C2 A8 0D
F00:1124       	ld hl,startprocessinfo
               S01:00000DA4:  21 15 0B
F00:1125       	ret
               S01:00000DA7:  C9
F00:1126       _loadaddress21$:
F00:1127       	cp NEXTPROCESSINFO
               S01:00000DA8:  FE 17
F00:1128       	jp nz, _loadaddress22$
               S01:00000DAA:  C2 B1 0D
F00:1129       	ld hl, nextprocessinfo
               S01:00000DAD:  21 1D 0B
F00:1130       	ret
               S01:00000DB0:  C9
F00:1131       _loadaddress22$:
F00:1132       	cp STRCPY
               S01:00000DB1:  FE 18
F00:1133       	jp nz, _loadaddress23$
               S01:00000DB3:  C2 BA 0D
F00:1134       	ld hl, strcpy
               S01:00000DB6:  21 68 08
F00:1135       	ret
               S01:00000DB9:  C9
F00:1136       _loadaddress23$:
F00:1137       	cp GETPROCESSBYID
               S01:00000DBA:  FE 1A
F00:1138       	jp nz,_loadaddress24$
               S01:00000DBC:  C2 C3 0D
F00:1139       	ld hl,getprocessbyid
               S01:00000DBF:  21 0B 0C
F00:1140       	ret
               S01:00000DC2:  C9
F00:1141       _loadaddress24$:
F00:1142       	cp MULTIPLY8
               S01:00000DC3:  FE 1B
F00:1143       	jp nz,_loadaddress25$
               S01:00000DC5:  C2 CC 0D
F00:1144       	ld hl,Mul8b
               S01:00000DC8:  21 E7 0C
F00:1145       	ret
               S01:00000DCB:  C9
F00:1146       _loadaddress25$:
F00:1147       	cp SETPROCID
               S01:00000DCC:  FE 1C
F00:1148       	jp nz, _loadaddress26$
               S01:00000DCE:  C2 D5 0D
F00:1149       	ld hl,setprocid
               S01:00000DD1:  21 02 0B
F00:1150       	ret
               S01:00000DD4:  C9
F00:1151       _loadaddress26$:
F00:1152       	#----- not defined ---
F00:1153       	ld hl,addressfailedmsg
               S01:00000DD5:  21 2C 0E
F00:1154       	call print 
               S01:00000DD8:  CD A1 08
F00:1155       	call printhex
               S01:00000DDB:  CD CA 08
F00:1156       
F00:1157       	ld hl,0
               S01:00000DDE:  21 00 00
F00:1158       	ret
               S01:00000DE1:  C9
F00:1159       
F00:1160       
F00:1161       	# ======================== end subroutines ========== #
F00:1162       	
F00:1163       	nullroutine: 
F00:1164       		ei
               S01:00000DE2:  FB
F00:1165       		reti
               S01:00000DE3:  ED 4D
F00:1166       
F00:1167       	serialport: ;#/* interrupt 2, echo what was sent*/
F00:1168       	#	di
F00:1169       		#ld a,'*'
F00:1170       		#out (SERIALPORT),a
F00:1171       
F00:1172       		in a,(SERIALPORT)
               S01:00000DE5:  DB 01
F00:1173       		cp 0
               S01:00000DE7:  FE 00
F00:1174       		jp nz,_1$
               S01:00000DE9:  C2 EE 0D
F00:1175       		ld a,'`'
               S01:00000DEC:  3E 60
F00:1176       _1$:
F00:1177       		out (SERIALPORT),a
               S01:00000DEE:  D3 01
F00:1178       		ei
               S01:00000DF0:  FB
F00:1179       		reti
               S01:00000DF1:  ED 4D
F00:1180       	crlf: .string "\r\n"
               S01:00000DF3:  0D 0A
F00:1181       	loadedmsg: .string "JOSHUA\r\n"
               S01:00000DF6:  4A 4F 53 48 55 41 0D 0A
F00:1182       	readymsg: .string "\r\nReady v0.0\r\n"
               S01:00000DFF:  0D 0A 52 65 61 64 79 20 76 30 2E 30 0D 0A
F00:1183       	commandprocessor: .string "cmd"
               S01:00000E0E:  63 6D 64
F00:1184       	errorloadingmsg: .string "error loading program.\r\n\"
               S01:00000E12:  65 72 72 6F 72 20 6C 6F 61 64 69 6E 67 20 70 72
               S01:00000E22:  6F 67 72 61 6D 2E 0D 0A 22
F00:1185       	addressfailedmsg: .string "GetAddress failed for code:"
               S01:00000E2C:  47 65 74 41 64 64 72 65 73 73 20 66 61 69 6C 65
               S01:00000E3C:  64 20 66 6F 72 20 63 6F 64 65 3A
F00:1186       
F00:1187       	.align 8
F00:1188       malloctable: .space 255
F00:1189       
F00:1190       	; I could set the org address but I'm going to let that move as needed	.org 0x????
F00:1191       	;#.org 0x0A00-start
F00:1192       
F00:1193       	.align 8
F00:1194       	jumptable:
F00:1195       	.2byte nullroutine ;0
               S01:00001000:  E2 0D
F00:1196       	.2byte serialport ;2
               S01:00001002:  E5 0D
F00:1197       	.2byte nullroutine ;4
               S01:00001004:  E2 0D
F00:1198       	.2byte nullroutine ;6
               S01:00001006:  E2 0D
F00:1199       	.2byte nullroutine ;0
               S01:00001008:  E2 0D
F00:1200       	.2byte nullroutine ;0
               S01:0000100A:  E2 0D
F00:1201       	.2byte nullroutine ;0
               S01:0000100C:  E2 0D
F00:1202       	.2byte nullroutine ;0
               S01:0000100E:  E2 0D
F00:1203       	.2byte nullroutine ;0
               S01:00001010:  E2 0D
F00:1204       	.2byte nullroutine ;0
               S01:00001012:  E2 0D
F00:1205       #/* 10 */
F00:1206       	.2byte nullroutine ;0
               S01:00001014:  E2 0D
F00:1207       	.2byte nullroutine ;0
               S01:00001016:  E2 0D
F00:1208       	.2byte nullroutine ;0
               S01:00001018:  E2 0D
F00:1209       	.2byte nullroutine ;0
               S01:0000101A:  E2 0D
F00:1210       	.2byte nullroutine ;0
               S01:0000101C:  E2 0D
F00:1211       	.2byte nullroutine ;0
               S01:0000101E:  E2 0D
F00:1212       	.2byte nullroutine ;0
               S01:00001020:  E2 0D
F00:1213       	.2byte nullroutine ;0
               S01:00001022:  E2 0D
F00:1214       	.2byte nullroutine ;0
               S01:00001024:  E2 0D
F00:1215       	.2byte nullroutine ;0
               S01:00001026:  E2 0D
F00:1216       #/* 20 */
F00:1217       	.2byte nullroutine ;0
               S01:00001028:  E2 0D
F00:1218       	.2byte nullroutine ;0
               S01:0000102A:  E2 0D
F00:1219       	.2byte nullroutine ;0
               S01:0000102C:  E2 0D
F00:1220       	.2byte nullroutine ;0
               S01:0000102E:  E2 0D
F00:1221       	.2byte nullroutine ;0
               S01:00001030:  E2 0D
F00:1222       	.2byte nullroutine ;0
               S01:00001032:  E2 0D
F00:1223       	.2byte nullroutine ;0
               S01:00001034:  E2 0D
F00:1224       	.2byte nullroutine ;0
               S01:00001036:  E2 0D
F00:1225       	.2byte nullroutine ;0
               S01:00001038:  E2 0D
F00:1226       	.2byte nullroutine ;0
               S01:0000103A:  E2 0D
F00:1227       #/* 30 */
F00:1228       	.2byte nullroutine ;0
               S01:0000103C:  E2 0D
F00:1229       	.2byte nullroutine ;0
               S01:0000103E:  E2 0D
F00:1230       	.2byte nullroutine ;0
               S01:00001040:  E2 0D
F00:1231       	.2byte nullroutine ;0
               S01:00001042:  E2 0D
F00:1232       	.2byte nullroutine ;0
               S01:00001044:  E2 0D
F00:1233       	.2byte nullroutine ;0
               S01:00001046:  E2 0D
F00:1234       	.2byte nullroutine ;0
               S01:00001048:  E2 0D
F00:1235       	.2byte nullroutine ;0
               S01:0000104A:  E2 0D
F00:1236       	.2byte nullroutine ;0
               S01:0000104C:  E2 0D
F00:1237       	.2byte nullroutine ;0
               S01:0000104E:  E2 0D
F00:1238       #/* 40 */
F00:1239       	.2byte nullroutine ;0
               S01:00001050:  E2 0D
F00:1240       	.2byte nullroutine ;0
               S01:00001052:  E2 0D
F00:1241       	.2byte nullroutine ;0
               S01:00001054:  E2 0D
F00:1242       	.2byte nullroutine ;0
               S01:00001056:  E2 0D
F00:1243       	.2byte nullroutine ;0
               S01:00001058:  E2 0D
F00:1244       	.2byte nullroutine ;0
               S01:0000105A:  E2 0D
F00:1245       	.2byte nullroutine ;0
               S01:0000105C:  E2 0D
F00:1246       	.2byte nullroutine ;0
               S01:0000105E:  E2 0D
F00:1247       	.2byte nullroutine ;0
               S01:00001060:  E2 0D
F00:1248       	.2byte nullroutine ;0
               S01:00001062:  E2 0D
F00:1249       #/* 50 */
F00:1250       	.2byte nullroutine ;0
               S01:00001064:  E2 0D
F00:1251       	.2byte nullroutine ;0
               S01:00001066:  E2 0D
F00:1252       	.2byte nullroutine ;0
               S01:00001068:  E2 0D
F00:1253       	.2byte nullroutine ;0
               S01:0000106A:  E2 0D
F00:1254       	.2byte nullroutine ;0
               S01:0000106C:  E2 0D
F00:1255       	.2byte nullroutine ;0
               S01:0000106E:  E2 0D
F00:1256       	.2byte nullroutine ;0
               S01:00001070:  E2 0D
F00:1257       	.2byte nullroutine ;0
               S01:00001072:  E2 0D
F00:1258       	.2byte nullroutine ;0
               S01:00001074:  E2 0D
F00:1259       	.2byte nullroutine ;0
               S01:00001076:  E2 0D
F00:1260       #/* 60 */
F00:1261       	.2byte nullroutine ;0
               S01:00001078:  E2 0D
F00:1262       	.2byte nullroutine ;0
               S01:0000107A:  E2 0D
F00:1263       	.2byte nullroutine ;0
               S01:0000107C:  E2 0D
F00:1264       	.2byte nullroutine ;0
               S01:0000107E:  E2 0D
F00:1265       	.2byte nullroutine ;0
               S01:00001080:  E2 0D
F00:1266       	.2byte nullroutine ;0
               S01:00001082:  E2 0D
F00:1267       	.2byte nullroutine ;0
               S01:00001084:  E2 0D
F00:1268       	.2byte nullroutine ;0
               S01:00001086:  E2 0D
F00:1269       	.2byte nullroutine ;0
               S01:00001088:  E2 0D
F00:1270       	.2byte nullroutine ;0
               S01:0000108A:  E2 0D
F00:1271       #/* 70 */
F00:1272       	.2byte nullroutine ;0
               S01:0000108C:  E2 0D
F00:1273       	.2byte nullroutine ;0
               S01:0000108E:  E2 0D
F00:1274       	.2byte nullroutine ;0
               S01:00001090:  E2 0D
F00:1275       	.2byte nullroutine ;0
               S01:00001092:  E2 0D
F00:1276       	.2byte nullroutine ;0
               S01:00001094:  E2 0D
F00:1277       	.2byte nullroutine ;0
               S01:00001096:  E2 0D
F00:1278       	.2byte nullroutine ;0
               S01:00001098:  E2 0D
F00:1279       	.2byte nullroutine ;0
               S01:0000109A:  E2 0D
F00:1280       	.2byte nullroutine ;0
               S01:0000109C:  E2 0D
F00:1281       	.2byte nullroutine ;0
               S01:0000109E:  E2 0D
F00:1282       #/* 80 */
F00:1283       	.2byte nullroutine ;0
               S01:000010A0:  E2 0D
F00:1284       	.2byte nullroutine ;0
               S01:000010A2:  E2 0D
F00:1285       	.2byte nullroutine ;0
               S01:000010A4:  E2 0D
F00:1286       	.2byte nullroutine ;0
               S01:000010A6:  E2 0D
F00:1287       	.2byte nullroutine ;0
               S01:000010A8:  E2 0D
F00:1288       	.2byte nullroutine ;0
               S01:000010AA:  E2 0D
F00:1289       	.2byte nullroutine ;0
               S01:000010AC:  E2 0D
F00:1290       	.2byte nullroutine ;0
               S01:000010AE:  E2 0D
F00:1291       	.2byte nullroutine ;0
               S01:000010B0:  E2 0D
F00:1292       	.2byte nullroutine ;0
               S01:000010B2:  E2 0D
F00:1293       #/* 90 */
F00:1294       	.2byte nullroutine ;0
               S01:000010B4:  E2 0D
F00:1295       	.2byte nullroutine ;0
               S01:000010B6:  E2 0D
F00:1296       	.2byte nullroutine ;0
               S01:000010B8:  E2 0D
F00:1297       	.2byte nullroutine ;0
               S01:000010BA:  E2 0D
F00:1298       	.2byte nullroutine ;0
               S01:000010BC:  E2 0D
F00:1299       	.2byte nullroutine ;0
               S01:000010BE:  E2 0D
F00:1300       	.2byte nullroutine ;0
               S01:000010C0:  E2 0D
F00:1301       	.2byte nullroutine ;0
               S01:000010C2:  E2 0D
F00:1302       	.2byte nullroutine ;0
               S01:000010C4:  E2 0D
F00:1303       	.2byte nullroutine ;0
               S01:000010C6:  E2 0D
F00:1304       #/* 100 */
F00:1305       	.2byte nullroutine ;0
               S01:000010C8:  E2 0D
F00:1306       	.2byte nullroutine ;0
               S01:000010CA:  E2 0D
F00:1307       	.2byte nullroutine ;0
               S01:000010CC:  E2 0D
F00:1308       	.2byte nullroutine ;0
               S01:000010CE:  E2 0D
F00:1309       	.2byte nullroutine ;0
               S01:000010D0:  E2 0D
F00:1310       	.2byte nullroutine ;0
               S01:000010D2:  E2 0D
F00:1311       	.2byte nullroutine ;0
               S01:000010D4:  E2 0D
F00:1312       	.2byte nullroutine ;0
               S01:000010D6:  E2 0D
F00:1313       	.2byte nullroutine ;0
               S01:000010D8:  E2 0D
F00:1314       	.2byte nullroutine ;0
               S01:000010DA:  E2 0D
F00:1315       #/* 110 */
F00:1316       	.2byte nullroutine ;0
               S01:000010DC:  E2 0D
F00:1317       	.2byte nullroutine ;0
               S01:000010DE:  E2 0D
F00:1318       	.2byte nullroutine ;0
               S01:000010E0:  E2 0D
F00:1319       	.2byte nullroutine ;0
               S01:000010E2:  E2 0D
F00:1320       	.2byte nullroutine ;0
               S01:000010E4:  E2 0D
F00:1321       	.2byte nullroutine ;0
               S01:000010E6:  E2 0D
F00:1322       	.2byte nullroutine ;0
               S01:000010E8:  E2 0D
F00:1323       	.2byte nullroutine ;0
               S01:000010EA:  E2 0D
F00:1324       	.2byte nullroutine ;0
               S01:000010EC:  E2 0D
F00:1325       	.2byte nullroutine ;0
               S01:000010EE:  E2 0D
F00:1326       #/* 120 */
F00:1327       	.2byte nullroutine ;0
               S01:000010F0:  E2 0D
F00:1328       	.2byte nullroutine ;0
               S01:000010F2:  E2 0D
F00:1329       	.2byte nullroutine ;0
               S01:000010F4:  E2 0D
F00:1330       	.2byte nullroutine ;0
               S01:000010F6:  E2 0D
F00:1331       	.2byte nullroutine ;0
               S01:000010F8:  E2 0D
F00:1332       	.2byte nullroutine ;0
               S01:000010FA:  E2 0D
F00:1333       	.2byte nullroutine ;0
               S01:000010FC:  E2 0D
F00:1334       	.2byte nullroutine ;0
               S01:000010FE:  E2 0D
F00:1335       
F00:1336       	ENDOFLINE:
F00:1337       	.if (ENDOFLINE > 0x01fff)
F00:1338       		.abort "PROGRAM TOO LARGE TO FIT BELOW <0x2000"
F00:1339       	.endif
F00:1340       	


Sections:
S01  seg800


Sources:
F00  RAM.s
F01  SDCARD.inc
F02  Routines.inc
F03  SERIAL.inc
F04  SDCARD.inc
F05  debughex
F06  debug
F07  debug
F08  debug
F09  debug
F10  REPEAT:RAM.s:line 877
F11  debug
F12  debug
F13  debug
F14  debug


Symbols:
ENDOFLINE EXPR(4352=0x1100) ABS 
 serialport _1$ EXPR(3566=0xdee) ABS 
serialport EXPR(3557=0xde5) ABS 
nullroutine EXPR(3554=0xde2) ABS 
addressfailedmsg EXPR(3628=0xe2c) ABS 
_loadaddress26$ EXPR(3541=0xdd5) ABS 
_loadaddress25$ EXPR(3532=0xdcc) ABS 
_loadaddress24$ EXPR(3523=0xdc3) ABS 
_loadaddress23$ EXPR(3514=0xdba) ABS 
_loadaddress22$ EXPR(3505=0xdb1) ABS 
_loadaddress21$ EXPR(3496=0xda8) ABS 
_loadaddress20$ EXPR(3487=0xd9f) ABS 
_loadaddress19$ EXPR(3478=0xd96) ABS 
_loadaddress18$ EXPR(3469=0xd8d) ABS 
_loadaddress$17 EXPR(3460=0xd84) ABS 
_loadaddress$16 EXPR(3451=0xd7b) ABS 
_loadaddress$15 EXPR(3442=0xd72) ABS 
_loadaddress$14 EXPR(3433=0xd69) ABS 
_loadaddress$13 EXPR(3424=0xd60) ABS 
_loadaddress$12 EXPR(3415=0xd57) ABS 
_loadaddress$11 EXPR(3406=0xd4e) ABS 
_loadaddress$10 EXPR(3397=0xd45) ABS 
_loadaddress$9 EXPR(3388=0xd3c) ABS 
_loadaddress$8 EXPR(3379=0xd33) ABS 
_loadaddress$7 EXPR(3370=0xd2a) ABS 
_loadaddress$6 EXPR(3361=0xd21) ABS 
_loadaddress$5 EXPR(3352=0xd18) ABS 
_loadaddress$4 EXPR(3343=0xd0f) ABS 
_loadaddress$3 EXPR(3334=0xd06) ABS 
_loadaddress$2 EXPR(3325=0xcfd) ABS 
Mul8bSkip EXPR(3313=0xcf1) ABS 
Mul8bLoop EXPR(3308=0xcec) ABS 
Div8NextBit EXPR(3300=0xce4) ABS 
Div8Loop EXPR(3292=0xcdc) ABS 
Div8 EXPR(3289=0xcd9) ABS 
 setresetpage 4$ EXPR(3254=0xcb6) ABS 
 setresetpage 6$ EXPR(3251=0xcb3) ABS 
 setresetpage 2$ EXPR(3235=0xca3) ABS 
 setresetpage 1$ EXPR(3230=0xc9e) ABS 
getmallocrelativebase EXPR(3257=0xcb9) ABS 
setresetpage EXPR(3199=0xc7f) ABS 
malloctable EXPR(3840=0xf00) ABS 
getmalloctable EXPR(3185=0xc71) ABS 
getcommandparams EXPR(3172=0xc64) ABS 
endprocesstable EXPR(3172=0xc64) UNUSED ABS 
maxprocesses EXPR(3138=0xc42) UNUSED ABS 
 deleteprocessbyid 0$ EXPR(3121=0xc31) ABS 
 deleteprocessbyid 1$ EXPR(3125=0xc35) ABS 
deleteprocessbyid EXPR(3108=0xc24) UNUSED ABS 
 getprocessbyid 1$ EXPR(3105=0xc21) ABS 
 getprocessbyid 2$ EXPR(3086=0xc0e) ABS 
getprocessbyid EXPR(3083=0xc0b) ABS 
errormsg EXPR(3015=0xbc7) ABS 
failed EXPR(3006=0xbbe) ABS 
 getnewprocessid 3$ EXPR(2952=0xb88) ABS 
 getnewprocessid 2$ EXPR(2930=0xb72) ABS 
 getnewprocessid 1$ EXPR(2906=0xb5a) ABS 
 getprocessslot 1$ EXPR(2900=0xb54) ABS 
 getprocessslot 2$ EXPR(2886=0xb46) ABS 
getprocessslot EXPR(2883=0xb43) ABS 
 nextprocessinfo 1$ EXPR(2873=0xb39) ABS 
processtable EXPR(3140=0xc44) ABS 
Mul8b EXPR(3303=0xce7) ABS 
nextprocessinfo EXPR(2845=0xb1d) ABS 
currentprocessinfo EXPR(3139=0xc43) ABS 
startprocessinfo EXPR(2837=0xb15) ABS 
writeprocessinfo EXPR(2963=0xb93) ABS 
getnewprocessid EXPR(2903=0xb57) ABS 
lastprogramid EXPR(3137=0xc41) ABS 
setprocid EXPR(2818=0xb02) ABS 
procname EXPR(3127=0xc37) ABS 
progloadaddress EXPR(2732=0xaac) ABS 
createnewprocessinfo EXPR(2822=0xb06) ABS 
 createProcess _4$ EXPR(2722=0xaa2) ABS 
_progloadaddr EXPR(2733=0xaad) ABS 
_createProcesserr$1 EXPR(2735=0xaaf) ABS 
copyprogramname EXPR(2740=0xab4) ABS 
theprocessmsg EXPR(2751=0xabf) ABS 
thecommandlinemsg EXPR(2760=0xac8) ABS 
theparams EXPR(2768=0xad0) ABS 
createProcess EXPR(2624=0xa40) ABS 
_exitgetfilename EXPR(2618=0xa3a) ABS 
_getfilename$1 EXPR(2602=0xa2a) ABS 
getfilename EXPR(2596=0xa24) ABS 
nextfile EXPR(2589=0xa1d) ABS 
directoryopen EXPR(2582=0xa16) ABS 
hextobytenumber EXPR(2579=0xa13) ABS 
workhextobyte EXPR(2571=0xa0b) ABS 
hextobyte EXPR(2552=0x9f8) ABS 
stackpages EXPR(2551=0x9f7) UNUSED ABS 
hisize EXPR(2547=0x9f3) UNUSED ABS 
losize EXPR(2546=0x9f2) ABS 
sizeincrement EXPR(2522=0x9da) ABS 
 available _1$ EXPR(2456=0x998) ABS 
_$nextbyte EXPR(2471=0x9a7) ABS 
 loadheader _1$ EXPR(2423=0x977) ABS 
 loadheader _2$ EXPR(2399=0x95f) ABS 
reservemalloc EXPR(3189=0xc75) ABS 
 testloadaddress 45$ EXPR(2370=0x942) ABS 
memorypages EXPR(2550=0x9f6) ABS 
 testloadaddress _4$ EXPR(2392=0x958) ABS 
loadheader EXPR(2395=0x95b) ABS 
available EXPR(2436=0x984) ABS 
sizeloaded EXPR(2488=0x9b8) ABS 
testloadaddress EXPR(2334=0x91e) ABS 
_$openfile EXPR(2315=0x90b) ABS 
_$getnextchar EXPR(2298=0x8fa) ABS 
startaddress EXPR(2548=0x9f4) ABS 
sizereset EXPR(2503=0x9c7) ABS 
putc EXPR(2272=0x8e0) ABS 
_$ EXPR(2259=0x8d3) ABS 
printhexL EXPR(2237=0x8bd) ABS 
_$2 EXPR(2234=0x8ba) ABS 
_$1 EXPR(2223=0x8af) ABS 
crlf EXPR(3571=0xdf3) ABS 
nextcharacter EXPR(2185=0x889) ABS 
converttouppercaseletter EXPR(2182=0x886) ABS 
goagain EXPR(2173=0x87d) ABS 
touppercase EXPR(2171=0x87b) ABS 
_strcpyexit$1 EXPR(2167=0x877) ABS 
 strcpy _1$ EXPR(2155=0x86b) ABS 
strcpy EXPR(2152=0x868) ABS 
strncpy EXPR(2149=0x865) ABS 
strlenexit EXPR(2146=0x862) ABS 
_strlen$ EXPR(2135=0x857) ABS 
strlen EXPR(2131=0x853) ABS 
_metset$1 EXPR(2124=0x84c) ABS 
memset EXPR(2122=0x84a) ABS 
errorloadingmsg EXPR(3602=0xe12) ABS 
printhex EXPR(2250=0x8ca) ABS 
commandline EXPR(2119=0x847) ABS 
println EXPR(2195=0x893) ABS 
_cmdlne EXPR(2120=0x848) ABS 
errorloading EXPR(2107=0x83b) ABS 
loadFILE EXPR(2275=0x8e3) ABS 
commandprocessor EXPR(3598=0xe0e) ABS 
commandprocessloop EXPR(2078=0x81e) ABS 
loadedmsg EXPR(3574=0xdf6) ABS 
jumptable EXPR(4096=0x1000) ABS 
print EXPR(2209=0x8a1) ABS 
readymsg EXPR(3583=0xdff) ABS 
loadaddress EXPR(3316=0xcf4) ABS 
start EXPR(2052=0x804) UNUSED ABS 
boot EXPR(2055=0x807) ABS 
NEXTNUMBER EXPR(29=0x1d) UNUSED 
MULTIPLY8 EXPR(27=0x1b) 
GETPROCESSBYID EXPR(26=0x1a) 
NEXTPROCESSINFO EXPR(23=0x17) 
STARTPROCESSINFO EXPR(22=0x16) 
SETRESETPAGE EXPR(20=0x14) 
DIV8 EXPR(19=0x13) 
GETMALLOCTABLE EXPR(18=0x12) 
GETFILENAME EXPR(15=0xf) 
DIRECTORYNEXTFILE EXPR(14=0xe) UNUSED 
DIRECTORYOPEN EXPR(13=0xd) 
GETCOMMANDPARAMS EXPR(17=0x11) 
CREATEPROCESS EXPR(16=0x10) 
HEXTOBYTE EXPR(8=0x8) 
TOUPPERCASE EXPR(7=0x7) 
PUTC EXPR(6=0x6) 
STRNCPY EXPR(10=0xa) 
STRCPY EXPR(24=0x18) 
STRLEN EXPR(5=0x5) 
MEMSET EXPR(4=0x4) 
LOADFILE EXPR(3=0x3) 
PRINTHEXL EXPR(21=0x15) 
PRINTHEX EXPR(2=0x2) 
PRINTLN EXPR(9=0x9) 
PRINT EXPR(1=0x1) 
SETPROCID EXPR(28=0x1c) 
GetAddress EXPR(2052=0x804) UNUSED 
FALSE EXPR(0=0x0) UNUSED 
TRUE EXPR(1=0x1) UNUSED 
libMemory EXPR(61440=0xf000) UNUSED 
userMemory EXPR(12288=0x3000) 
commandMemory EXPR(8192=0x2000) UNUSED 
SERIALPORT2 EXPR(2=0x2) UNUSED 
SERIALPORT EXPR(1=0x1) 
NEXTFILE EXPR(50=0x32) 
OPENDIRECTORY EXPR(49=0x31) 
NAMEAVAILABLE EXPR(33=0x21) 
GETNAME EXPR(32=0x20) 
WRITEBYTE EXPR(8=0x8) UNUSED 
OPENWRITE EXPR(7=0x7) UNUSED 
AVAILABLE EXPR(6=0x6) 
READNEXTBYTE EXPR(5=0x5) 
FILENAMEAPPEND EXPR(4=0x4) 
CLOSE EXPR(3=0x3) UNUSED 
OPEN EXPR(2=0x2) 
FILENAMECLEAR EXPR(1=0x1) 
SDCARD EXPR(5=0x5) 
PROCINFOSIZE EXPR(8=0x8) 
MAXPROCESSES EXPR(4=0x4) 
__VASM EXPR(0=0x0) INTERNAL 
__MSDOSFS EXPR(0=0x0) INTERNAL 

There have been no errors.

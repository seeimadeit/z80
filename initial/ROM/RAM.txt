F00:0001       
F00:0002       
F00:0003       
F00:0004       #define LOWORD(l) ((WORD)(l))
F00:0005       #define HIWORD(l) ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
F00:0006       #define LOBYTE(w) ((BYTE)(w))
F00:0007       #define HIBYTE(w) ((BYTE)(((WORD)(w) >> 8) & 0xFF))
F00:0008       
F00:0009       
F00:0010       .include "SDCARD.inc"
F01:0001       .equ SDCARD,0x05
F01:0002       ; ******* SDCARD *********
F01:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F01:0004       .equ FILENAMECLEAR ,1
F01:0005       
F01:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F01:0007       .equ OPEN ,2
F01:0008       
F01:0009       ; z80 out - close: no return value
F01:0010       .equ CLOSE ,3
F01:0011       
F01:0012       ; z80 out + out - filenameappend: no return value
F01:0013       .equ FILENAMEAPPEND ,4
F01:0014       
F01:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F01:0016       .equ READNEXTBYTE ,5
F01:0017       
F01:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F01:0019       .equ AVAILABLE ,6
F01:0020       
F01:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F01:0022       .equ OPENWRITE,7
F01:0023       
F01:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F01:0025       .equ WRITEBYTE,8
F01:0026       
F01:0027       ;#===============================
F01:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F01:0029       .equ GETNAME,0x20
F01:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F01:0031       .equ NAMEAVAILABLE,0x21
F01:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F01:0033       .equ OPENDIRECTORY,0x31
F01:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F01:0035       .equ NEXTFILE,0x32
F00:0011       .include "Routines.inc"
F02:0001       
F02:0002       .macro DEBUG CHARACTER='!'
F02:0009       
F02:0010       
F02:0011       .macro DEBUGHEX CHARACTER='!'
F02:0018       
F02:0019       
F02:0020       
F02:0021       # address where user programs load
F02:0022       .include "SERIAL.inc"
F03:0001       .equ SERIALPORT , 0x01
F03:0002       .equ SERIALPORT2, 0x02
F03:0003       
F02:0023       .include "SDCARD.inc"
F04:0001       .equ SDCARD,0x05
F04:0002       ; ******* SDCARD *********
F04:0003       ; z80 out -filenameclear: no return value, will close the previous open file is one already open
F04:0004       .equ FILENAMECLEAR ,1
F04:0005       
F04:0006       ; z80 out + in -open: will return a status 1 if file open successfull, 0 if open failed
F04:0007       .equ OPEN ,2
F04:0008       
F04:0009       ; z80 out - close: no return value
F04:0010       .equ CLOSE ,3
F04:0011       
F04:0012       ; z80 out + out - filenameappend: no return value
F04:0013       .equ FILENAMEAPPEND ,4
F04:0014       
F04:0015       ; z80 out + in - readnextbyte: will return 0xFF is nothing to read, which might be a problem if you don't check the avai
F04:0016       .equ READNEXTBYTE ,5
F04:0017       
F04:0018       ; z80 out + in - available: return 1 is data is available, 0 if no data available
F04:0019       .equ AVAILABLE ,6
F04:0020       
F04:0021       ; z80 out + in - openwrite: open file for write ,will return a status 1 if file open successfull, 0 if open failed
F04:0022       .equ OPENWRITE,7
F04:0023       
F04:0024       ; z80 - out + out -writebyte: will write data to an open file,is no file is open or the file is not writable nothing wil
F04:0025       .equ WRITEBYTE,8
F04:0026       
F04:0027       ;#===============================
F04:0028       ; z80 - out -getname: prepares to get the openfilename, use NAMEAVAILABLE to read the bytes, no return value
F04:0029       .equ GETNAME,0x20
F04:0030       ; z80 out + in - nameavailable: return next character of the filename, or 0 it no more characters
F04:0031       .equ NAMEAVAILABLE,0x21
F04:0032       ;z80 - out - opendirectory : will open the root directory for directory listing, no return value
F04:0033       .equ OPENDIRECTORY,0x31
F04:0034       ;z80 -out - nextfile: move to the next directory entry, no return value
F04:0035       .equ NEXTFILE,0x32
F02:0024       .equ commandMemory, 0x1000
F02:0025       .equ userMemory,0x2000
F02:0026       .equ libMemory,0xF000
F02:0027       
F02:0028       .equ TRUE, 1
F02:0029       .equ FALSE, 0
F02:0030       
F02:0031       # the only fixed address (i hope), use it to get the address of utilities methods
F02:0032       # ld a, PRINT
F02:0033       # call GetAddress
F02:0034       # address for print loaded into hl
F02:0035       # the value in hl can change between os versions so do not hard code the values
F02:0036       
F02:0037       .equ GetAddress, 0x0804
F02:0038       .equ PRINT,		1
F02:0039       .equ PRINTLN,	9
F02:0040       .equ PRINTHEX,	2
F02:0041       .equ PRINTHEXL,21
F02:0042       .equ LOADFILE,	3
F02:0043       .equ MEMSET,	4
F02:0044       .equ STRLEN,	5
F02:0045       .equ PUTC,		6
F02:0046       .equ TOUPPERCASE,7
F02:0047       .equ HEXTOBYTE,	8
F02:0048       .equ STRNCPY,10
F02:0049       .equ CREATEPROCESS,16
F02:0050       .equ GETCOMMANDPARAMS,17
F02:0051       # filesystem - primitive functions, probably going to change 
F02:0052       .equ DIRECTORYOPEN,13
F02:0053       .equ DIRECTORYNEXTFILE,14
F02:0054       .equ GETFILENAME,15
F02:0055       .equ GETMALLOCTABLE,18
F02:0056       .equ DIV8,19
F02:0057       .equ SETRESETPAGE,20
F02:0058       
F02:0059       
F02:0060       
F02:0061       .equ NEXTNUMBER,22
F02:0062       
F02:0063       
F00:0012       
F00:0013       
F00:0014       	.org 0x800
F00:0015       	jp boot
               S01:00000800:  C3 07 08
F00:0016       	.align 2
F00:0017       	start:
F00:0018       	jp loadaddress
               S01:00000804:  C3 41 0B
F00:0019       	
F00:0020       boot:
F00:0021       	ld sp,0xffff
               S01:00000807:  31 FF FF
F00:0022       
F00:0023       	di
               S01:0000080A:  F3
F00:0024       	ld hl,readymsg
               S01:0000080B:  21 16 0C
F00:0025       	call print
               S01:0000080E:  CD A1 08
F00:0026       		;ld b, endlabel2-label2
F00:0027       		;ld c,SERIALPORT
F00:0028       		;otir
F00:0029       		
F00:0030       		im 2 ;/* interrupt mode 2*/
               S01:00000811:  ED 5E
F00:0031       		ld a, jumptable/256 ;// hibyte
               S01:00000813:  3E 0E
F00:0032       		ld i,a
               S01:00000815:  ED 47
F00:0033       		ei   ;#/* enable interrupts*/
               S01:00000817:  FB
F00:0034       
F00:0035       		ld hl,loadedmsg
               S01:00000818:  21 0D 0C
F00:0036       		call print
               S01:0000081B:  CD A1 08
F00:0037       		#== ******* Command processor Loop ******** ==#
F00:0038       	commandprocessloop:	
F00:0039       		ld hl,commandprocessor
               S01:0000081E:  21 25 0C
F00:0040       #		ld de,commandMemory
F00:0041       		ld de,0
               S01:00000821:  11 00 00
F00:0042       		call loadFILE
               S01:00000824:  CD E1 08
F00:0043       		cp 0
               S01:00000827:  FE 00
F00:0044       		jp nz,errorloading
               S01:00000829:  C2 3B 08
F00:0045       		ld (_cmdlne),hl ;# save the load address
               S01:0000082C:  22 48 08
F00:0046       		ld hl,0
               S01:0000082F:  21 00 00
F00:0047       		call println
               S01:00000832:  CD 93 08
F00:0048       #		call commandMemory # run the file just loaded.
F00:0049       		call commandline
               S01:00000835:  CD 47 08
F00:0050       		jp commandprocessloop
               S01:00000838:  C3 1E 08
F00:0051       
F00:0052       	errorloading:
F00:0053       		call printhex
               S01:0000083B:  CD C8 08
F00:0054       		ld hl,errorloadingmsg
               S01:0000083E:  21 29 0C
F00:0055       		call println
               S01:00000841:  CD 93 08
F00:0056       		jp commandprocessloop
               S01:00000844:  C3 1E 08
F00:0057       
F00:0058       commandline: .byte 0xc3
               S01:00000847:  C3
F00:0059       	_cmdlne: .2byte 0
               S01:00000848:  00 00
F00:0060       
F00:0061       		#======================suboutines===============================================#
F00:0062       	# === memset === #
F00:0063       		# ld hl, address to start
F00:0064       		# ld a,0 byte to write into address
F00:0065       		# ld b,1 count of bytes to write
F00:0066       	memset:
F00:0067       		push af
               S01:0000084A:  F5
F00:0068       		push hl
               S01:0000084B:  E5
F00:0069       	_metset$1:
F00:0070       		ld (hl),a
               S01:0000084C:  77
F00:0071       		inc hl
               S01:0000084D:  23
F00:0072       		djnz _metset$1
               S01:0000084E:  10 FC
F00:0073       		pop hl
               S01:00000850:  E1
F00:0074       		pop af
               S01:00000851:  F1
F00:0075       		ret
               S01:00000852:  C9
F00:0076       	#== strlen ==#
F00:0077       		# ld hl, address to start
F00:0078       		# call strlen
F00:0079       		# return len in b
F00:0080       	strlen:
F00:0081       		push hl
               S01:00000853:  E5
F00:0082       		push af
               S01:00000854:  F5
F00:0083       	
F00:0084       		ld b,0
               S01:00000855:  06 00
F00:0085       	_strlen$:
F00:0086       		ld a,(hl)
               S01:00000857:  7E
F00:0087       		cp 0
               S01:00000858:  FE 00
F00:0088       		jp z, strlenexit
               S01:0000085A:  CA 62 08
F00:0089       		inc b
               S01:0000085D:  04
F00:0090       		inc hl
               S01:0000085E:  23
F00:0091       		jp _strlen$:
               S01:0000085F:  C3 57 08
F00:0092       	strlenexit:
F00:0093       	;#	ld a,b
F00:0094       	;#	call printhex
F00:0095       		pop af
               S01:00000862:  F1
F00:0096       		pop hl
               S01:00000863:  E1
F00:0097       		ret
               S01:00000864:  C9
F00:0098       
F00:0099       	#=== strncpy ==#
F00:0100       	;# copy from source into destination size bytes. no validation is done.
F00:0101       	;# ld hl, source
F00:0102       	;# ld de, destination
F00:0103       	;# ld bc, size
F00:0104       
F00:0105       	strncpy:
F00:0106       		ldir
               S01:00000865:  ED B0
F00:0107       		ret
               S01:00000867:  C9
F00:0108       
F00:0109       	# === strcpy == #
F00:0110       	;# copy from source into destination string is zero terminated, no validation is done
F00:0111       	;# ld hl,source
F00:0112       	;# ld de,destination
F00:0113       	;# call strcpy
F00:0114       	strcpy:
F00:0115       		push af
               S01:00000868:  F5
F00:0116       		push hl
               S01:00000869:  E5
F00:0117       		push de
               S01:0000086A:  D5
F00:0118       	_1$:
F00:0119       		ld a,(hl)
               S01:0000086B:  7E
F00:0120       		ld (de),a ;# copy the potential zero before we test because we will need it
               S01:0000086C:  12
F00:0121       		cp 0
               S01:0000086D:  FE 00
F00:0122       		jp z, _strcpyexit$1
               S01:0000086F:  CA 77 08
F00:0123       
F00:0124       		inc de
               S01:00000872:  13
F00:0125       		inc hl
               S01:00000873:  23
F00:0126       		jp _1$
               S01:00000874:  C3 6B 08
F00:0127       	
F00:0128       	_strcpyexit$1:
F00:0129       		pop de
               S01:00000877:  D1
F00:0130       		pop hl
               S01:00000878:  E1
F00:0131       		pop af
               S01:00000879:  F1
F00:0132       		ret
               S01:0000087A:  C9
F00:0133       		# === touppercase ==#
F00:0134       	;#		ld hl,cmd  - zero terminated string
F00:0135       	;#		call touppercase
F00:0136       	;#		ret
F00:0137       	;# the P flag means the comparison was Positive
F00:0138       	;# the M flags means the comparision was Negative
F00:0139       	;# the Z flag means the comparison was equal
F00:0140       	;# the NZ flag means the comparison was not equal.
F00:0141       	;# where:
F00:0142       	;#    A = x  P Positive
F00:0143       	;#			 Z Zero
F00:0144       	;#
F00:0145       	;#    A < x	 M Negative
F00:0146       	;#			 NZ Not zero
F00:0147       	;#
F00:0148       	;#	  A > x  P Positive
F00:0149       	;#			 NZ Not zero
F00:0150       	;#
F00:0151       	;# so a test for JP P,meansSameOrGreater
F00:0152       
F00:0153       
F00:0154       touppercase:
F00:0155       	push af
               S01:0000087B:  F5
F00:0156       	push hl
               S01:0000087C:  E5
F00:0157       	
F00:0158       goagain:
F00:0159       	ld a,(hl)
               S01:0000087D:  7E
F00:0160       	cp 'a'
               S01:0000087E:  FE 61
F00:0161       	jp p, converttouppercaseletter ;# is same or greater then 'a'
               S01:00000880:  F2 86 08
F00:0162       ;# the instructions commented out are implied
F00:0163       	;#cp 'A'
F00:0164       	;#jp p, nextcharacter ;# is same or greater
F00:0165       	;#cp '0'
F00:0166       	;#jp p, nextcharacter
F00:0167       	;# jp nextcharacter replaces the above 4 lines
F00:0168       	jp nextcharacter
               S01:00000883:  C3 89 08
F00:0169       
F00:0170       converttouppercaseletter:
F00:0171       	sub 32
               S01:00000886:  D6 20
F00:0172       	ld (hl),a
               S01:00000888:  77
F00:0173       nextcharacter:
F00:0174       	inc hl
               S01:00000889:  23
F00:0175       	ld a,(hl)
               S01:0000088A:  7E
F00:0176       	cp 0
               S01:0000088B:  FE 00
F00:0177       	jp nz,goagain	
               S01:0000088D:  C2 7D 08
F00:0178       
F00:0179       	pop hl
               S01:00000890:  E1
F00:0180       	pop af
               S01:00000891:  F1
F00:0181       
F00:0182       	ret
               S01:00000892:  C9
F00:0183       	# === PRINTLN == #
F00:0184       	println: ;// same as print but appends CRLF
F00:0185       	call print
               S01:00000893:  CD A1 08
F00:0186       	push hl
               S01:00000896:  E5
F00:0187       	push af
               S01:00000897:  F5
F00:0188       	ld hl,crlf
               S01:00000898:  21 0A 0C
F00:0189       	call print
               S01:0000089B:  CD A1 08
F00:0190       	pop af
               S01:0000089E:  F1
F00:0191       	pop hl
               S01:0000089F:  E1
F00:0192       	ret
               S01:000008A0:  C9
F00:0193       
F00:0194       	# === PRINT === #
F00:0195       	print: ;// expecting a zero terminated string
F00:0196       		push hl
               S01:000008A1:  E5
F00:0197       		push af
               S01:000008A2:  F5
F00:0198       		;# hl can be null so check for that first
F00:0199       		ld a,h
               S01:000008A3:  7C
F00:0200       		cp 0
               S01:000008A4:  FE 00
F00:0201       		jp nz,_$1 ;# hibyte not null, no just print it
               S01:000008A6:  C2 AF 08
F00:0202       		ld a,l
               S01:000008A9:  7D
F00:0203       		cp 0
               S01:000008AA:  FE 00
F00:0204       		jp z,_$2 ;# lobyte is null and hibyte is null so just exit
               S01:000008AC:  CA BA 08
F00:0205       		_$1:
F00:0206       			ld a,(hl)
               S01:000008AF:  7E
F00:0207       			cp 0
               S01:000008B0:  FE 00
F00:0208       			jr z,_$2
               S01:000008B2:  28 06
F00:0209       			out (SERIALPORT),a
               S01:000008B4:  D3 01
F00:0210       			inc hl
               S01:000008B6:  23
F00:0211       			jp _$1
               S01:000008B7:  C3 AF 08
F00:0212       _$2:			
F00:0213       		pop af
               S01:000008BA:  F1
F00:0214       		pop hl
               S01:000008BB:  E1
F00:0215       		ret
               S01:000008BC:  C9
F00:0216       ;#=== printhexL ===#
F00:0217       ;# ld hl,passwords
F00:0218       ;# call printhexL
F00:0219       
F00:0220       printhexL:
F00:0221       	push af
               S01:000008BD:  F5
F00:0222       	ld a,h
               S01:000008BE:  7C
F00:0223       	call printhex
               S01:000008BF:  CD C8 08
F00:0224       	ld a,l
               S01:000008C2:  7D
F00:0225       	call printhex
               S01:000008C3:  CD C8 08
F00:0226       	pop af
               S01:000008C6:  F1
F00:0227       	ret
               S01:000008C7:  C9
F00:0228       # === PRINTHEX === #
F00:0229       		;Display 8-bit number in hex.
F00:0230       		; 	ld a,0xaa
F00:0231       	;       call printhex
F00:0232       printhex:
F00:0233       
F00:0234       ; Input: a
F00:0235       
F00:0236         push af
               S01:000008C8:  F5
F00:0237         ;// remove low nibble
F00:0238          rra
               S01:000008C9:  1F
F00:0239          rra
               S01:000008CA:  1F
F00:0240          rra
               S01:000008CB:  1F
F00:0241          rra
               S01:000008CC:  1F
F00:0242          call  _$
               S01:000008CD:  CD D1 08
F00:0243          ;// restore low nibble
F00:0244          pop af
               S01:000008D0:  F1
F00:0245          
F00:0246       _$:
F00:0247       	push af
               S01:000008D1:  F5
F00:0248       	;// remove high nibble
F00:0249          and  0x0F
               S01:000008D2:  E6 0F
F00:0250          add  a,0x90
               S01:000008D4:  C6 90
F00:0251          ;; bcd adjust
F00:0252          daa
               S01:000008D6:  27
F00:0253          adc  a,0x40
               S01:000008D7:  CE 40
F00:0254          daa
               S01:000008D9:  27
F00:0255          out (SERIALPORT),a 
               S01:000008DA:  D3 01
F00:0256          pop af
               S01:000008DC:  F1
F00:0257          ret
               S01:000008DD:  C9
F00:0258       
F00:0259       # === putc ===== #
F00:0260       ;# ld a,'*'
F00:0261       ;# call putc
F00:0262       ;# no return value
F00:0263       putc:
F00:0264       		out (SERIALPORT),a
               S01:000008DE:  D3 01
F00:0265       		ret
               S01:000008E0:  C9
F00:0266       
F00:0267       		;// end subroutines
F00:0268       # === loadFILE === #
F00:0269       ; ld hl, filename (zero terminated)
F00:0270       ; ld de, memory address to load file into
F00:0271       ; call loadFILE
F00:0272       ; returns 
F00:0273       ;	HL
F00:0274       ;		baseaddress of the dll
F00:0275       ;	A register 
F00:0276       ;			2 = failed to open the file
F00:0277       ;			0 = if file loaded into memory
F00:0278       ;	DE register pair
F00:0279       ;			count of bytes loaded
F00:0280       loadFILE:
F00:0281       	push af
               S01:000008E1:  F5
F00:0282       	push de ; save de for later
               S01:000008E2:  D5
F00:0283       	call sizereset
               S01:000008E3:  CD C5 09
F00:0284       	ld a,0 ;# erase the executable header information
               S01:000008E6:  3E 00
F00:0285       	ld (startaddress),a
               S01:000008E8:  32 F2 09
F00:0286       	ld (startaddress+1),a
               S01:000008EB:  32 F3 09
F00:0287       	ld (startaddress+2),a
               S01:000008EE:  32 F4 09
F00:0288       	ld (startaddress+3),a
               S01:000008F1:  32 F5 09
F00:0289       		; try to open the SD card and read some data
F00:0290       		ld a,FILENAMECLEAR ; // filenameclear
               S01:000008F4:  3E 01
F00:0291       		out (SDCARD),a
               S01:000008F6:  D3 05
F00:0292       
F00:0293       
F00:0294       ;
F00:0295       _$getnextchar:
F00:0296       		ld a,(hl)
               S01:000008F8:  7E
F00:0297       		cp 0
               S01:000008F9:  FE 00
F00:0298       		jp z, _$openfile #; if filename character is null we have finished
               S01:000008FB:  CA 09 09
F00:0299       		ld a,FILENAMEAPPEND
               S01:000008FE:  3E 04
F00:0300       		out (SDCARD),a ; // filenameappend
               S01:00000900:  D3 05
F00:0301       		ld a,(hl)
               S01:00000902:  7E
F00:0302       		out (SDCARD),a
               S01:00000903:  D3 05
F00:0303       		;#out (SERIALPORT),a
F00:0304       		inc hl
               S01:00000905:  23
F00:0305       		jp _$getnextchar
               S01:00000906:  C3 F8 08
F00:0306       
F00:0307       _$openfile:
F00:0308       #openfile will return 1 if the file was opened, 0 if it failed to open
F00:0309       		ld a,OPEN	;// Open
               S01:00000909:  3E 02
F00:0310       		out (SDCARD),a
               S01:0000090B:  D3 05
F00:0311       		in a,(SDCARD)
               S01:0000090D:  DB 05
F00:0312       		pop hl ; get load address - must pop the stack before returning
               S01:0000090F:  E1
F00:0313       		cp 0
               S01:00000910:  FE 00
F00:0314       		jp nz,testloadaddress
               S01:00000912:  C2 1C 09
F00:0315       		pop af ;# a flag not needed now
               S01:00000915:  F1
F00:0316       		call sizeloaded
               S01:00000916:  CD B6 09
F00:0317       		ld a,2 ;we have an error trying to open the file.
               S01:00000919:  3E 02
F00:0318       		ret
               S01:0000091B:  C9
F00:0319       testloadaddress:
F00:0320       	# if loadaddress (hl) = 0, then the file will have load address information in the 1st 2 bytes
F00:0321       	ld a,0
               S01:0000091C:  3E 00
F00:0322       	cp h
               S01:0000091E:  BC
F00:0323       	jp nz,available ;# h is not zero so it must have an address to load into already
               S01:0000091F:  C2 82 09
F00:0324       	cp l
               S01:00000922:  BD
F00:0325       	jp nz,available ;# l is not zero so it must have an address to load intop already
               S01:00000923:  C2 82 09
F00:0326       
F00:0327       	ld hl,startaddress ;# this is the place to store the 2 bytes we need to get at the load address
               S01:00000926:  21 F2 09
F00:0328       	call loadheader
               S01:00000929:  CD 59 09
F00:0329       	cp 1
               S01:0000092C:  FE 01
F00:0330       	jp nz,_4$
               S01:0000092E:  C2 56 09
F00:0331       
F00:0332       	ld hl,(startaddress)
               S01:00000931:  2A F2 09
F00:0333       	inc hl ;#start address
               S01:00000934:  23
F00:0334       	inc hl
               S01:00000935:  23
F00:0335       	inc hl ;# program size in pages
               S01:00000936:  23
F00:0336       	inc hl ;# stack size in pages
               S01:00000937:  23
F00:0337       	ld (startaddress),hl ;# this is now the dll entry point address, will need this later to initialize the library
               S01:00000938:  22 F2 09
F00:0338       
F00:0339       	ld a,(memorypages)
               S01:0000093B:  3A F4 09
F00:0340       	ld b,a
               S01:0000093E:  47
F00:0341       	ld a,h
               S01:0000093F:  7C
F00:0342       
F00:0343       45$:	DEBUGHEX a
F05:0001       # example : DEBUGHEX '!'
F05:0002       #      or : DEBUGHEX h
F05:0003       		push af
               S01:00000940:  F5
F05:0004       		ld a,a
               S01:00000941:  7F
F05:0005       		call printhex
               S01:00000942:  CD C8 08
F05:0006       		pop af
               S01:00000945:  F1
F00:0344       	DEBUG '\n'
F06:0001       # example : DEBUG '!'
F06:0002       #      or : DEBUG h
F06:0003       		push af
               S01:00000946:  F5
F06:0004       		ld a,10
               S01:00000947:  3E 0A
F06:0005       		call putc
               S01:00000949:  CD DE 08
F06:0006       		pop af
               S01:0000094C:  F1
F00:0345       
F00:0346       	call reservemalloc
               S01:0000094D:  CD CF 0A
F00:0347       	inc a
               S01:00000950:  3C
F00:0348       	djnz 45$
               S01:00000951:  10 ED
F00:0349       
F00:0350       	jp available
               S01:00000953:  C3 82 09
F00:0351       _4$:
F00:0352       	ld a,3 ;#new error code
               S01:00000956:  3E 03
F00:0353       	ret
               S01:00000958:  C9
F00:0354       	#if we reach here then the first 2 bytes have the address information so let read them now
F00:0355       	;# header information
F00:0356       	;# 2bytes program load address
F00:0357       	;# 1byte memory required in pages
F00:0358       	;# 1byte stack required in pages
F00:0359       loadheader:
F00:0360       	ld b,4
               S01:00000959:  06 04
F00:0361       	ld c,0
               S01:0000095B:  0E 00
F00:0362       _2$:
F00:0363       	ld a, AVAILABLE
               S01:0000095D:  3E 06
F00:0364       	out (SDCARD),a
               S01:0000095F:  D3 05
F00:0365       	in a,(SDCARD) ;# is data available?
               S01:00000961:  DB 05
F00:0366       	cp 0
               S01:00000963:  FE 00
F00:0367       	jp nz,_1$
               S01:00000965:  C2 75 09
F00:0368       	pop af ;#restore af
               S01:00000968:  F1
F00:0369       	ld hl,0
               S01:00000969:  21 00 00
F00:0370       		call println
               S01:0000096C:  CD 93 08
F00:0371       		call sizeloaded
               S01:0000096F:  CD B6 09
F00:0372       		ld a,0 ;# use 0 in A to indicate a fail
               S01:00000972:  3E 00
F00:0373       		ret ;#- exit loadheader because the file read had a problem
               S01:00000974:  C9
F00:0374       _1$:
F00:0375       		;// if we get here then there is data to read
F00:0376       		ld a,READNEXTBYTE
               S01:00000975:  3E 05
F00:0377       		out (SDCARD),a ;// read nextbyte
               S01:00000977:  D3 05
F00:0378       		in a,(SDCARD)
               S01:00000979:  DB 05
F00:0379       		ld (hl),a ; // store byte in RAM (OSLOAD)
               S01:0000097B:  77
F00:0380       		inc hl 
               S01:0000097C:  23
F00:0381       		djnz _2$
               S01:0000097D:  10 DE
F00:0382       		ld a,1 ;# use 1 in A to indicate a success
               S01:0000097F:  3E 01
F00:0383       		ret ;# exit loadheader because we have loaded 4 bytes
               S01:00000981:  C9
F00:0384       available:
F00:0385       	#available will return 1 if there is data to read, 0 if no data to read
F00:0386       		ld a, AVAILABLE ; // available
               S01:00000982:  3E 06
F00:0387       		out (SDCARD),a
               S01:00000984:  D3 05
F00:0388       		in a,(SDCARD) ;// read the value from the device
               S01:00000986:  DB 05
F00:0389       	;	ld b,a ; // going to malipulate the a register so save it as not to destroy the A result
F00:0390       	;	add a,'0' ;// make it printable
F00:0391       	;	out (SERIALPORT),a ;// print response
F00:0392       	;	ld a,b
F00:0393       		cp 0 ;// compare the A reg returned by the device
               S01:00000988:  FE 00
F00:0394       		jp nz,_$nextbyte
               S01:0000098A:  C2 A5 09
F00:0395       		pop af ;# restore the af registers because it will tell me if I need to zero terminate the loaded file
               S01:0000098D:  F1
F00:0396       		cp 1
               S01:0000098E:  FE 01
F00:0397       		jp nz,_1$
               S01:00000990:  C2 96 09
F00:0398       		;# the hl register pair contains the last address we need to write a zero here because the user wants it
F00:0399       		ld a,0
               S01:00000993:  3E 00
F00:0400       		ld (hl),a ;# zero terminated
               S01:00000995:  77
F00:0401       
F00:0402       _1$:
F00:0403       		ld hl,0
               S01:00000996:  21 00 00
F00:0404       		call println
               S01:00000999:  CD 93 08
F00:0405       		call sizeloaded
               S01:0000099C:  CD B6 09
F00:0406       		ld hl,(startaddress) ;# return the startaddress
               S01:0000099F:  2A F2 09
F00:0407       		ld a,0
               S01:000009A2:  3E 00
F00:0408       		ret
               S01:000009A4:  C9
F00:0409       _$nextbyte:
F00:0410       		;// if we get here then there is data to read
F00:0411       		ld a,READNEXTBYTE
               S01:000009A5:  3E 05
F00:0412       		out (SDCARD),a ;// read nextbyte
               S01:000009A7:  D3 05
F00:0413       		in a,(SDCARD)
               S01:000009A9:  DB 05
F00:0414       		ld (hl),a ; // store byte in RAM (OSLOAD)
               S01:000009AB:  77
F00:0415       		inc hl 
               S01:000009AC:  23
F00:0416       		ld a,'#'
               S01:000009AD:  3E 23
F00:0417       		out (SERIALPORT),a ;// just echo it back for now
               S01:000009AF:  D3 01
F00:0418       		call sizeincrement
               S01:000009B1:  CD D8 09
F00:0419       		jr available ;
               S01:000009B4:  18 CC
F00:0420       
F00:0421       sizeloaded:
F00:0422       	push ix
               S01:000009B6:  DD E5
F00:0423       	ld ix,losize
               S01:000009B8:  DD 21 F0 09
F00:0424       	ld e,(ix)
               S01:000009BC:  DD 5E 00
F00:0425       	ld d,(ix+1)
               S01:000009BF:  DD 56 01
F00:0426       	pop ix
               S01:000009C2:  DD E1
F00:0427       	ret
               S01:000009C4:  C9
F00:0428       sizereset:
F00:0429       	push ix
               S01:000009C5:  DD E5
F00:0430       	push af
               S01:000009C7:  F5
F00:0431       	ld a,0
               S01:000009C8:  3E 00
F00:0432       	ld ix,losize
               S01:000009CA:  DD 21 F0 09
F00:0433       	ld (ix),a
               S01:000009CE:  DD 77 00
F00:0434       	ld (ix+1),a
               S01:000009D1:  DD 77 01
F00:0435       	pop af
               S01:000009D4:  F1
F00:0436       	pop ix
               S01:000009D5:  DD E1
F00:0437       	ret
               S01:000009D7:  C9
F00:0438       sizeincrement:
F00:0439       	push ix
               S01:000009D8:  DD E5
F00:0440       	push hl
               S01:000009DA:  E5
F00:0441       
F00:0442       	ld ix,losize
               S01:000009DB:  DD 21 F0 09
F00:0443       	ld l,(ix)
               S01:000009DF:  DD 6E 00
F00:0444       	ld h,(ix+1)
               S01:000009E2:  DD 66 01
F00:0445       	inc HL
               S01:000009E5:  23
F00:0446       	ld (ix),l
               S01:000009E6:  DD 75 00
F00:0447       	ld (ix+1),h
               S01:000009E9:  DD 74 01
F00:0448       
F00:0449       	pop hl
               S01:000009EC:  E1
F00:0450       	pop ix
               S01:000009ED:  DD E1
F00:0451       	ret
               S01:000009EF:  C9
F00:0452       
F00:0453       losize: .byte 0
               S01:000009F0:  00
F00:0454       hisize: .byte 0
               S01:000009F1:  00
F00:0455       
F00:0456       ;# executable header information
F00:0457       startaddress: .2byte 0
               S01:000009F2:  00 00
F00:0458       memorypages: .byte 0
               S01:000009F4:  00
F00:0459       stackpages: .byte 0
               S01:000009F5:  00
F00:0460       ;# ====== hextobyte ==========
F00:0461       ;#    load HL registers with the 2 ascii characters of a hexadecimal value
F00:0462       ;# note routine does not validate the inputs.
F00:0463       ;# alphabeta expected in uppercase
F00:0464       ;#	ld h,'c'
F00:0465       ;#	ld l,'3'
F00:0466       ;#	call hextobyte
F00:0467       ;#	value stored in A register
F00:0468       
F00:0469       
F00:0470       hextobyte:
F00:0471       	push hl
               S01:000009F6:  E5
F00:0472       	push bc
               S01:000009F7:  C5
F00:0473       	ld a,l ;# prepare the low nibble
               S01:000009F8:  7D
F00:0474       	call workhextobyte
               S01:000009F9:  CD 09 0A
F00:0475       	ld b,a ;# save it later
               S01:000009FC:  47
F00:0476       	ld a,h ;# prepare the high nibble
               S01:000009FD:  7C
F00:0477       	call workhextobyte
               S01:000009FE:  CD 09 0A
F00:0478       	rla ;# a contains the result from the high nibble
               S01:00000A01:  17
F00:0479       	rla ;# so move the nibble to make room for the low nibble
               S01:00000A02:  17
F00:0480       	rla
               S01:00000A03:  17
F00:0481       	rla
               S01:00000A04:  17
F00:0482       	or b ;# add the low nibble
               S01:00000A05:  B0
F00:0483       
F00:0484       	pop bc
               S01:00000A06:  C1
F00:0485       	pop hl
               S01:00000A07:  E1
F00:0486       	ret
               S01:00000A08:  C9
F00:0487       workhextobyte:
F00:0488       	cp 'A' ;# alphabeta sub 55
               S01:00000A09:  FE 41
F00:0489       	jp m,hextobytenumber
               S01:00000A0B:  FA 11 0A
F00:0490       	sub 55
               S01:00000A0E:  D6 37
F00:0491       	ret
               S01:00000A10:  C9
F00:0492       hextobytenumber:
F00:0493       	sub 48 ;# if number sub 48
               S01:00000A11:  D6 30
F00:0494       	ret
               S01:00000A13:  C9
F00:0495       
F00:0496       	;# === directory open === #
F00:0497       
F00:0498       directoryopen:
F00:0499       	push af
               S01:00000A14:  F5
F00:0500       	ld a,OPENDIRECTORY
               S01:00000A15:  3E 31
F00:0501       	out (SDCARD),a
               S01:00000A17:  D3 05
F00:0502       	pop af
               S01:00000A19:  F1
F00:0503       	ret
               S01:00000A1A:  C9
F00:0504       	;# === nextfile === #
F00:0505       nextfile:
F00:0506       	push af
               S01:00000A1B:  F5
F00:0507       	ld a,NEXTFILE
               S01:00000A1C:  3E 32
F00:0508       	out (SDCARD),a
               S01:00000A1E:  D3 05
F00:0509       	pop af
               S01:00000A20:  F1
F00:0510       	ret
               S01:00000A21:  C9
F00:0511       	;# === getfilename or currently open file ===#
F00:0512       	;# ld hl,storagelocation - for the filename
F00:0513       	;# call getfilename
F00:0514       
F00:0515       getfilename:
F00:0516       	push af
               S01:00000A22:  F5
F00:0517       	push hl
               S01:00000A23:  E5
F00:0518       	ld a,GETNAME
               S01:00000A24:  3E 20
F00:0519       	out (SDCARD),a
               S01:00000A26:  D3 05
F00:0520       
F00:0521       _getfilename$1:
F00:0522       	ld a,NAMEAVAILABLE
               S01:00000A28:  3E 21
F00:0523       	out (SDCARD),a
               S01:00000A2A:  D3 05
F00:0524       	in a,(SDCARD)
               S01:00000A2C:  DB 05
F00:0525       	cp 0
               S01:00000A2E:  FE 00
F00:0526       	jp z, _exitgetfilename
               S01:00000A30:  CA 38 0A
F00:0527       
F00:0528       	ld (hl),a
               S01:00000A33:  77
F00:0529       	inc hl
               S01:00000A34:  23
F00:0530       	
F00:0531       	jp _getfilename$1
               S01:00000A35:  C3 28 0A
F00:0532       
F00:0533       _exitgetfilename:
F00:0534       	ld a,0
               S01:00000A38:  3E 00
F00:0535       	ld (hl),a
               S01:00000A3A:  77
F00:0536       	pop hl
               S01:00000A3B:  E1
F00:0537       	pop af
               S01:00000A3C:  F1
F00:0538       	ret
               S01:00000A3D:  C9
F00:0539       
F00:0540       	# === createProcess == #
F00:0541       	;# stack - note the example below is using the registers as an example, it really don't matter
F00:0542       	;# which register pair put that data on the stack, the sequence in which the parameters are put on the stack
F00:0543       	;# does matter.
F00:0544       	;# push hl,program - zero terminated
F00:0545       	;# push de,commandline - zero terminated
F00:0546       	;# call createProcess
F00:0547       	;# that should do for now
F00:0548       	createProcess: ;# this is messy need to have another go at this
F00:0549       		ld a,0
               S01:00000A3E:  3E 00
F00:0550       		call printhex
               S01:00000A40:  CD C8 08
F00:0551       
F00:0552       		pop hl ;# get the return address
               S01:00000A43:  E1
F00:0553       		exx ;# exchange with other registers
               S01:00000A44:  D9
F00:0554       
F00:0555       		ld de,userMemory-50 ;# whooa
               S01:00000A45:  11 CE 1F
F00:0556       		;# copy the command params
F00:0557       		pop hl ;# get the command params
               S01:00000A48:  E1
F00:0558       		ld a,1
               S01:00000A49:  3E 01
F00:0559       		call printhex
               S01:00000A4B:  CD C8 08
F00:0560       
F00:0561       		call strcpy
               S01:00000A4E:  CD 68 08
F00:0562       		ld a,2
               S01:00000A51:  3E 02
F00:0563       		call printhex
               S01:00000A53:  CD C8 08
F00:0564       		push hl
               S01:00000A56:  E5
F00:0565       		ld hl,thecommandlinemsg
               S01:00000A57:  21 B6 0A
F00:0566       		call println
               S01:00000A5A:  CD 93 08
F00:0567       		pop hl
               S01:00000A5D:  E1
F00:0568       		call println ;# print command params
               S01:00000A5E:  CD 93 08
F00:0569       
F00:0570       		ld a,3
               S01:00000A61:  3E 03
F00:0571       		call printhex
               S01:00000A63:  CD C8 08
F00:0572       
F00:0573       		pop hl ;# get the program
               S01:00000A66:  E1
F00:0574       		push HL
               S01:00000A67:  E5
F00:0575       		ld hl,theprocessmsg
               S01:00000A68:  21 AD 0A
F00:0576       		call println
               S01:00000A6B:  CD 93 08
F00:0577       		pop hl
               S01:00000A6E:  E1
F00:0578       		call println ;# print program name
               S01:00000A6F:  CD 93 08
F00:0579       #		ld de,userMemory
F00:0580       		ld a,0
               S01:00000A72:  3E 00
F00:0581       		ld d,a ;# use dynamic load address if possible
               S01:00000A74:  57
F00:0582       		ld e,a
               S01:00000A75:  5F
F00:0583       		ld a,4
               S01:00000A76:  3E 04
F00:0584       		call printhex
               S01:00000A78:  CD C8 08
F00:0585       
F00:0586       		call loadFILE
               S01:00000A7B:  CD E1 08
F00:0587       		cp 0
               S01:00000A7E:  FE 00
F00:0588       		jp nz, _createProcesserr$1
               S01:00000A80:  C2 A8 0A
F00:0589       		ld (_progloadaddr),hl ;# save the address the program was loaded into. if null is means use the default userMemory
               S01:00000A83:  22 A6 0A
F00:0590       		
F00:0591       		exx ;# restore the other original registers
               S01:00000A86:  D9
F00:0592       		push hl ; # restore the return address
               S01:00000A87:  E5
F00:0593       		# test if we need to use the default address or the program/library supplied address
F00:0594       		# we can do that by checking if the hl pair is null, null = use fault, not null = custom address
F00:0595       		ld hl,(_progloadaddr)
               S01:00000A88:  2A A6 0A
F00:0596       		ld a,h
               S01:00000A8B:  7C
F00:0597       		cp 0
               S01:00000A8C:  FE 00
F00:0598       		jp nz, _4$
               S01:00000A8E:  C2 9E 0A
F00:0599       		ld a,l
               S01:00000A91:  7D
F00:0600       		cp 0
               S01:00000A92:  FE 00
F00:0601       		jp nz,_4$
               S01:00000A94:  C2 9E 0A
F00:0602       		# hl was null so call the default address
F00:0603       		call printhexL
               S01:00000A97:  CD BD 08
F00:0604       		call userMemory
               S01:00000A9A:  CD 00 20
F00:0605       		ret
               S01:00000A9D:  C9
F00:0606       _4$:
F00:0607       	call printhexL
               S01:00000A9E:  CD BD 08
F00:0608       	call progloadaddress
               S01:00000AA1:  CD A5 0A
F00:0609       	ret
               S01:00000AA4:  C9
F00:0610       progloadaddress: .byte 0xc3
               S01:00000AA5:  C3
F00:0611       	_progloadaddr: .2byte 0
               S01:00000AA6:  00 00
F00:0612       
F00:0613       _createProcesserr$1:
F00:0614       		push af
               S01:00000AA8:  F5
F00:0615       		exx ;# restore the other original registers
               S01:00000AA9:  D9
F00:0616       		pop af
               S01:00000AAA:  F1
F00:0617       		push hl ; # restore the return address
               S01:00000AAB:  E5
F00:0618       		ret
               S01:00000AAC:  C9
F00:0619       
F00:0620       theprocessmsg: .string "process:"
               S01:00000AAD:  70 72 6F 63 65 73 73 3A
F00:0621       thecommandlinemsg: .string "params:"
               S01:00000AB6:  70 61 72 61 6D 73 3A
F00:0622       
F00:0623       	# === getcommandparams == #
F00:0624       	;# ld hl,buffer - address of where to copy the data
F00:0625       	;# call getcommandparams
F00:0626       	;# returns zero termined string at buffer 
F00:0627       getcommandparams:
F00:0628       	push de
               S01:00000ABE:  D5
F00:0629       	push hl
               S01:00000ABF:  E5
F00:0630       	push hl ;# save hl to move into de
               S01:00000AC0:  E5
F00:0631       	pop de ;# load hl into de
               S01:00000AC1:  D1
F00:0632       	ld hl,userMemory-50   ;# ********* I dont remember why I did this, it needs investigating
               S01:00000AC2:  21 CE 1F
F00:0633       	call strcpy
               S01:00000AC5:  CD 68 08
F00:0634       	pop hl
               S01:00000AC8:  E1
F00:0635       	pop de
               S01:00000AC9:  D1
F00:0636       	ret
               S01:00000ACA:  C9
F00:0637       
F00:0638       ;# ================ getmalloctable ======#
F00:0639       	getmalloctable:
F00:0640       		ld hl,malloctable
               S01:00000ACB:  21 00 0D
F00:0641       		ret
               S01:00000ACE:  C9
F00:0642       
F00:0643       ;# ====== reserve memory alloc table entry ===#
F00:0644       
F00:0645       	reservemalloc:
F00:0646       		push bc
               S01:00000ACF:  C5
F00:0647       		push af
               S01:00000AD0:  F5
F00:0648       		ld b,1
               S01:00000AD1:  06 01
F00:0649       		call setresetpage
               S01:00000AD3:  CD D9 0A
F00:0650       		pop af
               S01:00000AD6:  F1
F00:0651       		pop bc
               S01:00000AD7:  C1
F00:0652       	ret
               S01:00000AD8:  C9
F00:0653       ;# ======= setresetpage - memory alloc table management ===#
F00:0654       setresetpage:
F00:0655       ;# ld a, page
F00:0656       ;# ld b, setorreset , 0 = reset, 1 = set
F00:0657       		push hl
               S01:00000AD9:  E5
F00:0658       		push bc
               S01:00000ADA:  C5
F00:0659       		push af
               S01:00000ADB:  F5
F00:0660       	
F00:0661       		
F00:0662       		DEBUG '@'
F07:0001       # example : DEBUG '!'
F07:0002       #      or : DEBUG h
F07:0003       		push af
               S01:00000ADC:  F5
F07:0004       		ld a,64
               S01:00000ADD:  3E 40
F07:0005       		call putc
               S01:00000ADF:  CD DE 08
F07:0006       		pop af
               S01:00000AE2:  F1
F00:0663       
F00:0664       		call getmallocrelativebase
               S01:00000AE3:  CD 13 0B
F00:0665       
F00:0666       		DEBUG '%'
F08:0001       # example : DEBUG '!'
F08:0002       #      or : DEBUG h
F08:0003       		push af
               S01:00000AE6:  F5
F08:0004       		ld a,37
               S01:00000AE7:  3E 25
F08:0005       		call putc
               S01:00000AE9:  CD DE 08
F08:0006       		pop af
               S01:00000AEC:  F1
F00:0667       		pop af
               S01:00000AED:  F1
F00:0668       		and 0x0f
               S01:00000AEE:  E6 0F
F00:0669       		cp 8
               S01:00000AF0:  FE 08
F00:0670       		jp m,1$
               S01:00000AF2:  FA F8 0A
F00:0671       		inc hl
               S01:00000AF5:  23
F00:0672       		sub 8
               S01:00000AF6:  D6 08
F00:0673       1$:
F00:0674       	
F00:0675       		ld b,a
               S01:00000AF8:  47
F00:0676       		inc b
               S01:00000AF9:  04
F00:0677       		scf
               S01:00000AFA:  37
F00:0678       		ld a,0
               S01:00000AFB:  3E 00
F00:0679       
F00:0680       2$:		rra 	
               S01:00000AFD:  1F
F00:0681       		djnz 2$
               S01:00000AFE:  10 FD
F00:0682       		pop bc
               S01:00000B00:  C1
F00:0683       
F00:0684       		push af
               S01:00000B01:  F5
F00:0685       		ld a,b
               S01:00000B02:  78
F00:0686       		cp 0
               S01:00000B03:  FE 00
F00:0687       		jp z,6$
               S01:00000B05:  CA 0D 0B
F00:0688       ;# set
F00:0689       		pop af
               S01:00000B08:  F1
F00:0690       		or (hl)
               S01:00000B09:  B6
F00:0691       		jp 4$
               S01:00000B0A:  C3 10 0B
F00:0692       
F00:0693       ;# reset
F00:0694       6$:		pop af
               S01:00000B0D:  F1
F00:0695       		cpl
               S01:00000B0E:  2F
F00:0696       		and (hl)
               S01:00000B0F:  A6
F00:0697       
F00:0698       4$:
F00:0699       		ld (hl),a
               S01:00000B10:  77
F00:0700       		pop hl
               S01:00000B11:  E1
F00:0701       		ret
               S01:00000B12:  C9
F00:0702       
F00:0703       getmallocrelativebase:
F00:0704       ;# ld a,page
F00:0705       ;# call getmallocrelativebase
F00:0706       ;# return in hl = malloctable address adjusted for page
F00:0707       	push de
               S01:00000B13:  D5
F00:0708       		and 0xf0
               S01:00000B14:  E6 F0
F00:0709       
F00:0710       		ld l,a
               S01:00000B16:  6F
F00:0711       		ld h,0
               S01:00000B17:  26 00
F00:0712       		ld d,8
               S01:00000B19:  16 08
F00:0713       		call Div8
               S01:00000B1B:  CD 33 0B
F00:0714       
F00:0715       		ex de,hl
               S01:00000B1E:  EB
F00:0716       		#.byte 0xeb
F00:0717       
F00:0718       		DEBUG '!'
F09:0001       # example : DEBUG '!'
F09:0002       #      or : DEBUG h
F09:0003       		push af
               S01:00000B1F:  F5
F09:0004       		ld a,33
               S01:00000B20:  3E 21
F09:0005       		call putc
               S01:00000B22:  CD DE 08
F09:0006       		pop af
               S01:00000B25:  F1
F00:0719       
F00:0720       		call getmalloctable
               S01:00000B26:  CD CB 0A
F00:0721       		DEBUG '^'
F10:0001       # example : DEBUG '!'
F10:0002       #      or : DEBUG h
F10:0003       		push af
               S01:00000B29:  F5
F10:0004       		ld a,94
               S01:00000B2A:  3E 5E
F10:0005       		call putc
               S01:00000B2C:  CD DE 08
F10:0006       		pop af
               S01:00000B2F:  F1
F00:0722       		add hl,de
               S01:00000B30:  19
F00:0723       		pop de
               S01:00000B31:  D1
F00:0724       		ret
               S01:00000B32:  C9
F00:0725       
F00:0726       
F00:0727       
F00:0728       ;# ========== Div8 8bit division =======#
F00:0729       ;# http://tutorials.eeems.ca/Z80ASM/part4.htm#div8
F00:0730       ;# result stored in HL
F00:0731       ;# ld hl,4
F00:0732       ;# ld d,2
F00:0733       ;# call Div8
F00:0734       Div8:                            ; this routine performs the operation HL=HL/D
F00:0735         xor a                          ; clearing the upper 8 bits of AHL
               S01:00000B33:  AF
F00:0736         ld b,16                        ; the length of the dividend (16 bits)
               S01:00000B34:  06 10
F00:0737       Div8Loop:
F00:0738         add hl,hl                      ; advancing a bit
               S01:00000B36:  29
F00:0739         rla
               S01:00000B37:  17
F00:0740         cp d                           ; checking if the divisor divides the digits chosen (in A)
               S01:00000B38:  BA
F00:0741         jp c,Div8NextBit               ; if not, advancing without subtraction
               S01:00000B39:  DA 3E 0B
F00:0742         sub d                          ; subtracting the divisor
               S01:00000B3C:  92
F00:0743         inc l                          ; and setting the next digit of the quotient
               S01:00000B3D:  2C
F00:0744       Div8NextBit:
F00:0745         djnz Div8Loop
               S01:00000B3E:  10 F6
F00:0746         ret
               S01:00000B40:  C9
F00:0747       
F00:0748       ;================================
F00:0749       ; # === loadaddress == #
F00:0750       ; ld a,x - where x = instruction id
F00:0751       ;				id = 1, print
F00:0752       ;					 2, printhex
F00:0753       ;					3,loadFILE
F00:0754       loadaddress:
F00:0755       	cp PRINT
               S01:00000B41:  FE 01
F00:0756       	jp nz,_loadaddress$2
               S01:00000B43:  C2 4A 0B
F00:0757       	ld hl,print
               S01:00000B46:  21 A1 08
F00:0758       	ret
               S01:00000B49:  C9
F00:0759       _loadaddress$2:
F00:0760       	cp PRINTHEX
               S01:00000B4A:  FE 02
F00:0761       	jp nz,_loadaddress$3
               S01:00000B4C:  C2 53 0B
F00:0762       	ld hl,printhex
               S01:00000B4F:  21 C8 08
F00:0763       	ret
               S01:00000B52:  C9
F00:0764       _loadaddress$3:
F00:0765       	cp LOADFILE
               S01:00000B53:  FE 03
F00:0766       	jp nz,_loadaddress$4
               S01:00000B55:  C2 5C 0B
F00:0767       	ld hl,loadFILE
               S01:00000B58:  21 E1 08
F00:0768       	ret
               S01:00000B5B:  C9
F00:0769       _loadaddress$4:
F00:0770       	cp MEMSET
               S01:00000B5C:  FE 04
F00:0771       	jp nz,_loadaddress$5
               S01:00000B5E:  C2 65 0B
F00:0772       	ld hl,memset
               S01:00000B61:  21 4A 08
F00:0773       	ret
               S01:00000B64:  C9
F00:0774       _loadaddress$5:
F00:0775       	cp STRLEN
               S01:00000B65:  FE 05
F00:0776       	jp nz,_loadaddress$6
               S01:00000B67:  C2 6E 0B
F00:0777       	ld hl,strlen
               S01:00000B6A:  21 53 08
F00:0778       	ret
               S01:00000B6D:  C9
F00:0779       _loadaddress$6:
F00:0780       	cp PUTC
               S01:00000B6E:  FE 06
F00:0781       	jp nz,_loadaddress$7
               S01:00000B70:  C2 77 0B
F00:0782       	ld hl,putc
               S01:00000B73:  21 DE 08
F00:0783       	ret
               S01:00000B76:  C9
F00:0784       _loadaddress$7:
F00:0785       	cp TOUPPERCASE
               S01:00000B77:  FE 07
F00:0786       	jp nz,_loadaddress$8
               S01:00000B79:  C2 80 0B
F00:0787       	ld hl,touppercase
               S01:00000B7C:  21 7B 08
F00:0788       	ret
               S01:00000B7F:  C9
F00:0789       _loadaddress$8:
F00:0790       	cp HEXTOBYTE
               S01:00000B80:  FE 08
F00:0791       	jp nz,_loadaddress$9
               S01:00000B82:  C2 89 0B
F00:0792       	ld hl,hextobyte
               S01:00000B85:  21 F6 09
F00:0793       	ret
               S01:00000B88:  C9
F00:0794       _loadaddress$9:
F00:0795       	cp PRINTLN
               S01:00000B89:  FE 09
F00:0796       	jp nz,_loadaddress$10
               S01:00000B8B:  C2 92 0B
F00:0797       	ld hl,println
               S01:00000B8E:  21 93 08
F00:0798       	ret
               S01:00000B91:  C9
F00:0799       _loadaddress$10:
F00:0800       	cp STRNCPY
               S01:00000B92:  FE 0A
F00:0801       	jp nz,_loadaddress$11
               S01:00000B94:  C2 9B 0B
F00:0802       	ld hl,strncpy
               S01:00000B97:  21 65 08
F00:0803       	ret
               S01:00000B9A:  C9
F00:0804       _loadaddress$11:
F00:0805       	cp DIRECTORYOPEN
               S01:00000B9B:  FE 0D
F00:0806       	jp nz,_loadaddress$12
               S01:00000B9D:  C2 A4 0B
F00:0807       	ld hl,directoryopen
               S01:00000BA0:  21 14 0A
F00:0808       	ret
               S01:00000BA3:  C9
F00:0809       _loadaddress$12:
F00:0810       	cp GETFILENAME:
               S01:00000BA4:  FE 0F
F00:0811       	jp nz,_loadaddress$13
               S01:00000BA6:  C2 AD 0B
F00:0812       	ld hl,getfilename
               S01:00000BA9:  21 22 0A
F00:0813       	ret
               S01:00000BAC:  C9
F00:0814       _loadaddress$13:
F00:0815       	cp NEXTFILE
               S01:00000BAD:  FE 32
F00:0816       	jp nz,_loadaddress$14
               S01:00000BAF:  C2 B6 0B
F00:0817       	ld hl,nextfile
               S01:00000BB2:  21 1B 0A
F00:0818       	ret
               S01:00000BB5:  C9
F00:0819       _loadaddress$14:
F00:0820       	cp CREATEPROCESS
               S01:00000BB6:  FE 10
F00:0821       	jp nz,_loadaddress$15
               S01:00000BB8:  C2 BF 0B
F00:0822       	ld hl,createProcess
               S01:00000BBB:  21 3E 0A
F00:0823       	ret
               S01:00000BBE:  C9
F00:0824       _loadaddress$15:
F00:0825       	cp GETCOMMANDPARAMS
               S01:00000BBF:  FE 11
F00:0826       	jp nz,_loadaddress$16
               S01:00000BC1:  C2 C8 0B
F00:0827       	ld hl,getcommandparams
               S01:00000BC4:  21 BE 0A
F00:0828       	ret
               S01:00000BC7:  C9
F00:0829       _loadaddress$16:
F00:0830       	cp GETMALLOCTABLE
               S01:00000BC8:  FE 12
F00:0831       	jp nz,_loadaddress$17
               S01:00000BCA:  C2 D1 0B
F00:0832       	ld hl,getmalloctable
               S01:00000BCD:  21 CB 0A
F00:0833       	ret
               S01:00000BD0:  C9
F00:0834       _loadaddress$17:
F00:0835       	cp DIV8
               S01:00000BD1:  FE 13
F00:0836       	jp nz,_loadaddress18$
               S01:00000BD3:  C2 DA 0B
F00:0837       	ld hl,Div8
               S01:00000BD6:  21 33 0B
F00:0838       	ret
               S01:00000BD9:  C9
F00:0839       _loadaddress18$:
F00:0840       	cp SETRESETPAGE
               S01:00000BDA:  FE 14
F00:0841       	jp nz,_loadaddress19$
               S01:00000BDC:  C2 E3 0B
F00:0842       	ld hl,setresetpage
               S01:00000BDF:  21 D9 0A
F00:0843       	ret
               S01:00000BE2:  C9
F00:0844       _loadaddress19$:
F00:0845       	cp PRINTHEXL
               S01:00000BE3:  FE 15
F00:0846       	jp nz,_loadaddress20$
               S01:00000BE5:  C2 EC 0B
F00:0847       	ld hl,printhexL
               S01:00000BE8:  21 BD 08
F00:0848       	ret
               S01:00000BEB:  C9
F00:0849       _loadaddress20$:
F00:0850       	#----- not defined ---
F00:0851       	ld hl,addressfailedmsg
               S01:00000BEC:  21 43 0C
F00:0852       	call print 
               S01:00000BEF:  CD A1 08
F00:0853       	call printhex
               S01:00000BF2:  CD C8 08
F00:0854       
F00:0855       	ld hl,0
               S01:00000BF5:  21 00 00
F00:0856       	ret
               S01:00000BF8:  C9
F00:0857       
F00:0858       
F00:0859       	# ======================== end subroutines ========== #
F00:0860       	
F00:0861       	nullroutine: 
F00:0862       		ei
               S01:00000BF9:  FB
F00:0863       		reti
               S01:00000BFA:  ED 4D
F00:0864       
F00:0865       	serialport: ;#/* interrupt 2, echo what was sent*/
F00:0866       	#	di
F00:0867       		#ld a,'*'
F00:0868       		#out (SERIALPORT),a
F00:0869       
F00:0870       		in a,(SERIALPORT)
               S01:00000BFC:  DB 01
F00:0871       		cp 0
               S01:00000BFE:  FE 00
F00:0872       		jp nz,_1$
               S01:00000C00:  C2 05 0C
F00:0873       		ld a,'`'
               S01:00000C03:  3E 60
F00:0874       _1$:
F00:0875       		out (SERIALPORT),a
               S01:00000C05:  D3 01
F00:0876       		ei
               S01:00000C07:  FB
F00:0877       		reti
               S01:00000C08:  ED 4D
F00:0878       	crlf: .string "\r\n"
               S01:00000C0A:  0D 0A
F00:0879       	loadedmsg: .string "JOSHUA\r\n"
               S01:00000C0D:  4A 4F 53 48 55 41 0D 0A
F00:0880       	readymsg: .string "\r\nReady v0.0\r\n"
               S01:00000C16:  0D 0A 52 65 61 64 79 20 76 30 2E 30 0D 0A
F00:0881       	commandprocessor: .string "cmd"
               S01:00000C25:  63 6D 64
F00:0882       	errorloadingmsg: .string "error loading program.\r\n\"
               S01:00000C29:  65 72 72 6F 72 20 6C 6F 61 64 69 6E 67 20 70 72
               S01:00000C39:  6F 67 72 61 6D 2E 0D 0A 22
F00:0883       	addressfailedmsg: .string "GetAddress failed for code:"
               S01:00000C43:  47 65 74 41 64 64 72 65 73 73 20 66 61 69 6C 65
               S01:00000C53:  64 20 66 6F 72 20 63 6F 64 65 3A
F00:0884       
F00:0885       	.align 8
F00:0886       malloctable: .space 255
F00:0887       
F00:0888       	; I could set the org address but I'm going to let that move as needed	.org 0x????
F00:0889       	;#.org 0x0A00-start
F00:0890       
F00:0891       	.align 8
F00:0892       	jumptable:
F00:0893       	.2byte nullroutine ;0
               S01:00000E00:  F9 0B
F00:0894       	.2byte serialport ;2
               S01:00000E02:  FC 0B
F00:0895       	.2byte nullroutine ;4
               S01:00000E04:  F9 0B
F00:0896       	.2byte nullroutine ;6
               S01:00000E06:  F9 0B
F00:0897       	.2byte nullroutine ;0
               S01:00000E08:  F9 0B
F00:0898       	.2byte nullroutine ;0
               S01:00000E0A:  F9 0B
F00:0899       	.2byte nullroutine ;0
               S01:00000E0C:  F9 0B
F00:0900       	.2byte nullroutine ;0
               S01:00000E0E:  F9 0B
F00:0901       	.2byte nullroutine ;0
               S01:00000E10:  F9 0B
F00:0902       	.2byte nullroutine ;0
               S01:00000E12:  F9 0B
F00:0903       #/* 10 */
F00:0904       	.2byte nullroutine ;0
               S01:00000E14:  F9 0B
F00:0905       	.2byte nullroutine ;0
               S01:00000E16:  F9 0B
F00:0906       	.2byte nullroutine ;0
               S01:00000E18:  F9 0B
F00:0907       	.2byte nullroutine ;0
               S01:00000E1A:  F9 0B
F00:0908       	.2byte nullroutine ;0
               S01:00000E1C:  F9 0B
F00:0909       	.2byte nullroutine ;0
               S01:00000E1E:  F9 0B
F00:0910       	.2byte nullroutine ;0
               S01:00000E20:  F9 0B
F00:0911       	.2byte nullroutine ;0
               S01:00000E22:  F9 0B
F00:0912       	.2byte nullroutine ;0
               S01:00000E24:  F9 0B
F00:0913       	.2byte nullroutine ;0
               S01:00000E26:  F9 0B
F00:0914       #/* 20 */
F00:0915       	.2byte nullroutine ;0
               S01:00000E28:  F9 0B
F00:0916       	.2byte nullroutine ;0
               S01:00000E2A:  F9 0B
F00:0917       	.2byte nullroutine ;0
               S01:00000E2C:  F9 0B
F00:0918       	.2byte nullroutine ;0
               S01:00000E2E:  F9 0B
F00:0919       	.2byte nullroutine ;0
               S01:00000E30:  F9 0B
F00:0920       	.2byte nullroutine ;0
               S01:00000E32:  F9 0B
F00:0921       	.2byte nullroutine ;0
               S01:00000E34:  F9 0B
F00:0922       	.2byte nullroutine ;0
               S01:00000E36:  F9 0B
F00:0923       	.2byte nullroutine ;0
               S01:00000E38:  F9 0B
F00:0924       	.2byte nullroutine ;0
               S01:00000E3A:  F9 0B
F00:0925       #/* 30 */
F00:0926       	.2byte nullroutine ;0
               S01:00000E3C:  F9 0B
F00:0927       	.2byte nullroutine ;0
               S01:00000E3E:  F9 0B
F00:0928       	.2byte nullroutine ;0
               S01:00000E40:  F9 0B
F00:0929       	.2byte nullroutine ;0
               S01:00000E42:  F9 0B
F00:0930       	.2byte nullroutine ;0
               S01:00000E44:  F9 0B
F00:0931       	.2byte nullroutine ;0
               S01:00000E46:  F9 0B
F00:0932       	.2byte nullroutine ;0
               S01:00000E48:  F9 0B
F00:0933       	.2byte nullroutine ;0
               S01:00000E4A:  F9 0B
F00:0934       	.2byte nullroutine ;0
               S01:00000E4C:  F9 0B
F00:0935       	.2byte nullroutine ;0
               S01:00000E4E:  F9 0B
F00:0936       #/* 40 */
F00:0937       	.2byte nullroutine ;0
               S01:00000E50:  F9 0B
F00:0938       	.2byte nullroutine ;0
               S01:00000E52:  F9 0B
F00:0939       	.2byte nullroutine ;0
               S01:00000E54:  F9 0B
F00:0940       	.2byte nullroutine ;0
               S01:00000E56:  F9 0B
F00:0941       	.2byte nullroutine ;0
               S01:00000E58:  F9 0B
F00:0942       	.2byte nullroutine ;0
               S01:00000E5A:  F9 0B
F00:0943       	.2byte nullroutine ;0
               S01:00000E5C:  F9 0B
F00:0944       	.2byte nullroutine ;0
               S01:00000E5E:  F9 0B
F00:0945       	.2byte nullroutine ;0
               S01:00000E60:  F9 0B
F00:0946       	.2byte nullroutine ;0
               S01:00000E62:  F9 0B
F00:0947       #/* 50 */
F00:0948       	.2byte nullroutine ;0
               S01:00000E64:  F9 0B
F00:0949       	.2byte nullroutine ;0
               S01:00000E66:  F9 0B
F00:0950       	.2byte nullroutine ;0
               S01:00000E68:  F9 0B
F00:0951       	.2byte nullroutine ;0
               S01:00000E6A:  F9 0B
F00:0952       	.2byte nullroutine ;0
               S01:00000E6C:  F9 0B
F00:0953       	.2byte nullroutine ;0
               S01:00000E6E:  F9 0B
F00:0954       	.2byte nullroutine ;0
               S01:00000E70:  F9 0B
F00:0955       	.2byte nullroutine ;0
               S01:00000E72:  F9 0B
F00:0956       	.2byte nullroutine ;0
               S01:00000E74:  F9 0B
F00:0957       	.2byte nullroutine ;0
               S01:00000E76:  F9 0B
F00:0958       #/* 60 */
F00:0959       	.2byte nullroutine ;0
               S01:00000E78:  F9 0B
F00:0960       	.2byte nullroutine ;0
               S01:00000E7A:  F9 0B
F00:0961       	.2byte nullroutine ;0
               S01:00000E7C:  F9 0B
F00:0962       	.2byte nullroutine ;0
               S01:00000E7E:  F9 0B
F00:0963       	.2byte nullroutine ;0
               S01:00000E80:  F9 0B
F00:0964       	.2byte nullroutine ;0
               S01:00000E82:  F9 0B
F00:0965       	.2byte nullroutine ;0
               S01:00000E84:  F9 0B
F00:0966       	.2byte nullroutine ;0
               S01:00000E86:  F9 0B
F00:0967       	.2byte nullroutine ;0
               S01:00000E88:  F9 0B
F00:0968       	.2byte nullroutine ;0
               S01:00000E8A:  F9 0B
F00:0969       #/* 70 */
F00:0970       	.2byte nullroutine ;0
               S01:00000E8C:  F9 0B
F00:0971       	.2byte nullroutine ;0
               S01:00000E8E:  F9 0B
F00:0972       	.2byte nullroutine ;0
               S01:00000E90:  F9 0B
F00:0973       	.2byte nullroutine ;0
               S01:00000E92:  F9 0B
F00:0974       	.2byte nullroutine ;0
               S01:00000E94:  F9 0B
F00:0975       	.2byte nullroutine ;0
               S01:00000E96:  F9 0B
F00:0976       	.2byte nullroutine ;0
               S01:00000E98:  F9 0B
F00:0977       	.2byte nullroutine ;0
               S01:00000E9A:  F9 0B
F00:0978       	.2byte nullroutine ;0
               S01:00000E9C:  F9 0B
F00:0979       	.2byte nullroutine ;0
               S01:00000E9E:  F9 0B
F00:0980       #/* 80 */
F00:0981       	.2byte nullroutine ;0
               S01:00000EA0:  F9 0B
F00:0982       	.2byte nullroutine ;0
               S01:00000EA2:  F9 0B
F00:0983       	.2byte nullroutine ;0
               S01:00000EA4:  F9 0B
F00:0984       	.2byte nullroutine ;0
               S01:00000EA6:  F9 0B
F00:0985       	.2byte nullroutine ;0
               S01:00000EA8:  F9 0B
F00:0986       	.2byte nullroutine ;0
               S01:00000EAA:  F9 0B
F00:0987       	.2byte nullroutine ;0
               S01:00000EAC:  F9 0B
F00:0988       	.2byte nullroutine ;0
               S01:00000EAE:  F9 0B
F00:0989       	.2byte nullroutine ;0
               S01:00000EB0:  F9 0B
F00:0990       	.2byte nullroutine ;0
               S01:00000EB2:  F9 0B
F00:0991       #/* 90 */
F00:0992       	.2byte nullroutine ;0
               S01:00000EB4:  F9 0B
F00:0993       	.2byte nullroutine ;0
               S01:00000EB6:  F9 0B
F00:0994       	.2byte nullroutine ;0
               S01:00000EB8:  F9 0B
F00:0995       	.2byte nullroutine ;0
               S01:00000EBA:  F9 0B
F00:0996       	.2byte nullroutine ;0
               S01:00000EBC:  F9 0B
F00:0997       	.2byte nullroutine ;0
               S01:00000EBE:  F9 0B
F00:0998       	.2byte nullroutine ;0
               S01:00000EC0:  F9 0B
F00:0999       	.2byte nullroutine ;0
               S01:00000EC2:  F9 0B
F00:1000       	.2byte nullroutine ;0
               S01:00000EC4:  F9 0B
F00:1001       	.2byte nullroutine ;0
               S01:00000EC6:  F9 0B
F00:1002       #/* 100 */
F00:1003       	.2byte nullroutine ;0
               S01:00000EC8:  F9 0B
F00:1004       	.2byte nullroutine ;0
               S01:00000ECA:  F9 0B
F00:1005       	.2byte nullroutine ;0
               S01:00000ECC:  F9 0B
F00:1006       	.2byte nullroutine ;0
               S01:00000ECE:  F9 0B
F00:1007       	.2byte nullroutine ;0
               S01:00000ED0:  F9 0B
F00:1008       	.2byte nullroutine ;0
               S01:00000ED2:  F9 0B
F00:1009       	.2byte nullroutine ;0
               S01:00000ED4:  F9 0B
F00:1010       	.2byte nullroutine ;0
               S01:00000ED6:  F9 0B
F00:1011       	.2byte nullroutine ;0
               S01:00000ED8:  F9 0B
F00:1012       	.2byte nullroutine ;0
               S01:00000EDA:  F9 0B
F00:1013       #/* 110 */
F00:1014       	.2byte nullroutine ;0
               S01:00000EDC:  F9 0B
F00:1015       	.2byte nullroutine ;0
               S01:00000EDE:  F9 0B
F00:1016       	.2byte nullroutine ;0
               S01:00000EE0:  F9 0B
F00:1017       	.2byte nullroutine ;0
               S01:00000EE2:  F9 0B
F00:1018       	.2byte nullroutine ;0
               S01:00000EE4:  F9 0B
F00:1019       	.2byte nullroutine ;0
               S01:00000EE6:  F9 0B
F00:1020       	.2byte nullroutine ;0
               S01:00000EE8:  F9 0B
F00:1021       	.2byte nullroutine ;0
               S01:00000EEA:  F9 0B
F00:1022       	.2byte nullroutine ;0
               S01:00000EEC:  F9 0B
F00:1023       	.2byte nullroutine ;0
               S01:00000EEE:  F9 0B
F00:1024       #/* 120 */
F00:1025       	.2byte nullroutine ;0
               S01:00000EF0:  F9 0B
F00:1026       	.2byte nullroutine ;0
               S01:00000EF2:  F9 0B
F00:1027       	.2byte nullroutine ;0
               S01:00000EF4:  F9 0B
F00:1028       	.2byte nullroutine ;0
               S01:00000EF6:  F9 0B
F00:1029       	.2byte nullroutine ;0
               S01:00000EF8:  F9 0B
F00:1030       	.2byte nullroutine ;0
               S01:00000EFA:  F9 0B
F00:1031       	.2byte nullroutine ;0
               S01:00000EFC:  F9 0B
F00:1032       	.2byte nullroutine ;0
               S01:00000EFE:  F9 0B
F00:1033       
F00:1034       	ENDOFLINE:
F00:1035       	.if (ENDOFLINE > 0x0fff)
F00:1036       		.abort "PROGRAM TOO LARGE TO FIT BELOW <0x1000"
F00:1037       	.endif
F00:1038       	


Sections:
S01  seg800


Sources:
F00  RAM.s
F01  SDCARD.inc
F02  Routines.inc
F03  SERIAL.inc
F04  SDCARD.inc
F05  debughex
F06  debug
F07  debug
F08  debug
F09  debug
F10  debug


Symbols:
ENDOFLINE EXPR(3840=0xf00) ABS 
 serialport _1$ EXPR(3077=0xc05) ABS 
serialport EXPR(3068=0xbfc) ABS 
nullroutine EXPR(3065=0xbf9) ABS 
addressfailedmsg EXPR(3139=0xc43) ABS 
_loadaddress20$ EXPR(3052=0xbec) ABS 
_loadaddress19$ EXPR(3043=0xbe3) ABS 
_loadaddress18$ EXPR(3034=0xbda) ABS 
_loadaddress$17 EXPR(3025=0xbd1) ABS 
_loadaddress$16 EXPR(3016=0xbc8) ABS 
_loadaddress$15 EXPR(3007=0xbbf) ABS 
_loadaddress$14 EXPR(2998=0xbb6) ABS 
_loadaddress$13 EXPR(2989=0xbad) ABS 
_loadaddress$12 EXPR(2980=0xba4) ABS 
_loadaddress$11 EXPR(2971=0xb9b) ABS 
_loadaddress$10 EXPR(2962=0xb92) ABS 
_loadaddress$9 EXPR(2953=0xb89) ABS 
_loadaddress$8 EXPR(2944=0xb80) ABS 
_loadaddress$7 EXPR(2935=0xb77) ABS 
_loadaddress$6 EXPR(2926=0xb6e) ABS 
_loadaddress$5 EXPR(2917=0xb65) ABS 
_loadaddress$4 EXPR(2908=0xb5c) ABS 
_loadaddress$3 EXPR(2899=0xb53) ABS 
_loadaddress$2 EXPR(2890=0xb4a) ABS 
Div8NextBit EXPR(2878=0xb3e) ABS 
Div8Loop EXPR(2870=0xb36) ABS 
Div8 EXPR(2867=0xb33) ABS 
 setresetpage 4$ EXPR(2832=0xb10) ABS 
 setresetpage 6$ EXPR(2829=0xb0d) ABS 
 setresetpage 2$ EXPR(2813=0xafd) ABS 
 setresetpage 1$ EXPR(2808=0xaf8) ABS 
getmallocrelativebase EXPR(2835=0xb13) ABS 
setresetpage EXPR(2777=0xad9) ABS 
malloctable EXPR(3328=0xd00) ABS 
getmalloctable EXPR(2763=0xacb) ABS 
getcommandparams EXPR(2750=0xabe) ABS 
progloadaddress EXPR(2725=0xaa5) ABS 
 createProcess _4$ EXPR(2718=0xa9e) ABS 
_progloadaddr EXPR(2726=0xaa6) ABS 
_createProcesserr$1 EXPR(2728=0xaa8) ABS 
theprocessmsg EXPR(2733=0xaad) ABS 
thecommandlinemsg EXPR(2742=0xab6) ABS 
createProcess EXPR(2622=0xa3e) ABS 
_exitgetfilename EXPR(2616=0xa38) ABS 
_getfilename$1 EXPR(2600=0xa28) ABS 
getfilename EXPR(2594=0xa22) ABS 
nextfile EXPR(2587=0xa1b) ABS 
directoryopen EXPR(2580=0xa14) ABS 
hextobytenumber EXPR(2577=0xa11) ABS 
workhextobyte EXPR(2569=0xa09) ABS 
hextobyte EXPR(2550=0x9f6) ABS 
stackpages EXPR(2549=0x9f5) UNUSED ABS 
hisize EXPR(2545=0x9f1) UNUSED ABS 
losize EXPR(2544=0x9f0) ABS 
sizeincrement EXPR(2520=0x9d8) ABS 
 available _1$ EXPR(2454=0x996) ABS 
_$nextbyte EXPR(2469=0x9a5) ABS 
 loadheader _1$ EXPR(2421=0x975) ABS 
 loadheader _2$ EXPR(2397=0x95d) ABS 
reservemalloc EXPR(2767=0xacf) ABS 
 testloadaddress 45$ EXPR(2368=0x940) ABS 
memorypages EXPR(2548=0x9f4) ABS 
 testloadaddress _4$ EXPR(2390=0x956) ABS 
loadheader EXPR(2393=0x959) ABS 
available EXPR(2434=0x982) ABS 
sizeloaded EXPR(2486=0x9b6) ABS 
testloadaddress EXPR(2332=0x91c) ABS 
_$openfile EXPR(2313=0x909) ABS 
_$getnextchar EXPR(2296=0x8f8) ABS 
startaddress EXPR(2546=0x9f2) ABS 
sizereset EXPR(2501=0x9c5) ABS 
putc EXPR(2270=0x8de) ABS 
_$ EXPR(2257=0x8d1) ABS 
printhexL EXPR(2237=0x8bd) ABS 
_$2 EXPR(2234=0x8ba) ABS 
_$1 EXPR(2223=0x8af) ABS 
crlf EXPR(3082=0xc0a) ABS 
nextcharacter EXPR(2185=0x889) ABS 
converttouppercaseletter EXPR(2182=0x886) ABS 
goagain EXPR(2173=0x87d) ABS 
touppercase EXPR(2171=0x87b) ABS 
_strcpyexit$1 EXPR(2167=0x877) ABS 
 strcpy _1$ EXPR(2155=0x86b) ABS 
strcpy EXPR(2152=0x868) ABS 
strncpy EXPR(2149=0x865) ABS 
strlenexit EXPR(2146=0x862) ABS 
_strlen$ EXPR(2135=0x857) ABS 
strlen EXPR(2131=0x853) ABS 
_metset$1 EXPR(2124=0x84c) ABS 
memset EXPR(2122=0x84a) ABS 
errorloadingmsg EXPR(3113=0xc29) ABS 
printhex EXPR(2248=0x8c8) ABS 
commandline EXPR(2119=0x847) ABS 
println EXPR(2195=0x893) ABS 
_cmdlne EXPR(2120=0x848) ABS 
errorloading EXPR(2107=0x83b) ABS 
loadFILE EXPR(2273=0x8e1) ABS 
commandprocessor EXPR(3109=0xc25) ABS 
commandprocessloop EXPR(2078=0x81e) ABS 
loadedmsg EXPR(3085=0xc0d) ABS 
jumptable EXPR(3584=0xe00) ABS 
print EXPR(2209=0x8a1) ABS 
readymsg EXPR(3094=0xc16) ABS 
loadaddress EXPR(2881=0xb41) ABS 
start EXPR(2052=0x804) UNUSED ABS 
boot EXPR(2055=0x807) ABS 
NEXTNUMBER EXPR(22=0x16) UNUSED 
SETRESETPAGE EXPR(20=0x14) 
DIV8 EXPR(19=0x13) 
GETMALLOCTABLE EXPR(18=0x12) 
GETFILENAME EXPR(15=0xf) 
DIRECTORYNEXTFILE EXPR(14=0xe) UNUSED 
DIRECTORYOPEN EXPR(13=0xd) 
GETCOMMANDPARAMS EXPR(17=0x11) 
CREATEPROCESS EXPR(16=0x10) 
STRNCPY EXPR(10=0xa) 
HEXTOBYTE EXPR(8=0x8) 
TOUPPERCASE EXPR(7=0x7) 
PUTC EXPR(6=0x6) 
STRLEN EXPR(5=0x5) 
MEMSET EXPR(4=0x4) 
LOADFILE EXPR(3=0x3) 
PRINTHEXL EXPR(21=0x15) 
PRINTHEX EXPR(2=0x2) 
PRINTLN EXPR(9=0x9) 
PRINT EXPR(1=0x1) 
GetAddress EXPR(2052=0x804) UNUSED 
FALSE EXPR(0=0x0) UNUSED 
TRUE EXPR(1=0x1) UNUSED 
libMemory EXPR(61440=0xf000) UNUSED 
userMemory EXPR(8192=0x2000) 
commandMemory EXPR(4096=0x1000) UNUSED 
SERIALPORT2 EXPR(2=0x2) UNUSED 
SERIALPORT EXPR(1=0x1) 
NEXTFILE EXPR(50=0x32) 
OPENDIRECTORY EXPR(49=0x31) 
NAMEAVAILABLE EXPR(33=0x21) 
GETNAME EXPR(32=0x20) 
WRITEBYTE EXPR(8=0x8) UNUSED 
OPENWRITE EXPR(7=0x7) UNUSED 
AVAILABLE EXPR(6=0x6) 
READNEXTBYTE EXPR(5=0x5) 
FILENAMEAPPEND EXPR(4=0x4) 
CLOSE EXPR(3=0x3) UNUSED 
OPEN EXPR(2=0x2) 
FILENAMECLEAR EXPR(1=0x1) 
SDCARD EXPR(5=0x5) 
__VASM EXPR(0=0x0) INTERNAL 
__MSDOSFS EXPR(0=0x0) INTERNAL 

There have been no errors.
